{
    "task_id": "gabime__spdlog-2588",
    "setup_info": {
        "repo_path": "testbed/gabime__spdlog-2588_2025-06-30_11-19-49",
        "repo_cache_path": "testbed/gabime/spdlog_cache"
    },
    "task_info": {
        "repo": "gabime/spdlog",
        "pull_number": 2588,
        "instance_id": "gabime__spdlog-2588",
        "issue_numbers": [
            "2587"
        ],
        "base_commit": "edc51df1bdad8667b628999394a1e7c4dc6f3658",
        "patch": "diff --git a/include/spdlog/details/mpmc_blocking_q.h b/include/spdlog/details/mpmc_blocking_q.h\n--- a/include/spdlog/details/mpmc_blocking_q.h\n+++ b/include/spdlog/details/mpmc_blocking_q.h\n@@ -49,7 +49,7 @@ class mpmc_blocking_queue\n         push_cv_.notify_one();\n     }\n \n-    // try to dequeue item. if no item found. wait up to timeout and try again\n+    // dequeue with a timeout.\n     // Return true, if succeeded dequeue item, false otherwise\n     bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)\n     {\n@@ -66,6 +66,18 @@ class mpmc_blocking_queue\n         return true;\n     }\n \n+    // blocking dequeue without a timeout.\n+    void dequeue(T &popped_item)\n+    {\n+        {\n+            std::unique_lock<std::mutex> lock(queue_mutex_);\n+            push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n+            popped_item = std::move(q_.front());\n+            q_.pop_front();\n+        }\n+        pop_cv_.notify_one();\n+    }\n+\n #else\n     // apparently mingw deadlocks if the mutex is released before cv.notify_one(),\n     // so release the mutex at the very end each function.\n@@ -87,7 +99,7 @@ class mpmc_blocking_queue\n         push_cv_.notify_one();\n     }\n \n-    // try to dequeue item. if no item found. wait up to timeout and try again\n+    // dequeue with a timeout.\n     // Return true, if succeeded dequeue item, false otherwise\n     bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)\n     {\n@@ -102,6 +114,16 @@ class mpmc_blocking_queue\n         return true;\n     }\n \n+    // blocking dequeue without a timeout.\n+    void dequeue(T &popped_item)\n+    {\n+        std::unique_lock<std::mutex> lock(queue_mutex_);\n+        push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n+        popped_item = std::move(q_.front());\n+        q_.pop_front();\n+        pop_cv_.notify_one();\n+    }\n+\n #endif\n \n     size_t overrun_counter()\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -108,11 +108,7 @@ void SPDLOG_INLINE thread_pool::worker_loop_()\n bool SPDLOG_INLINE thread_pool::process_next_msg_()\n {\n     async_msg incoming_async_msg;\n-    bool dequeued = q_.dequeue_for(incoming_async_msg, std::chrono::seconds(10));\n-    if (!dequeued)\n-    {\n-        return true;\n-    }\n+    q_.dequeue(incoming_async_msg);\n \n     switch (incoming_async_msg.msg_type)\n     {\n",
        "test_patch": "diff --git a/tests/test_mpmc_q.cpp b/tests/test_mpmc_q.cpp\n--- a/tests/test_mpmc_q.cpp\n+++ b/tests/test_mpmc_q.cpp\n@@ -43,6 +43,26 @@ TEST_CASE(\"dequeue-empty-wait\", \"[mpmc_blocking_q]\")\n     REQUIRE(delta_ms <= wait_ms + tolerance_wait);\n }\n \n+TEST_CASE(\"dequeue-full-nowait\", \"[mpmc_blocking_q]\")\n+{\n+    spdlog::details::mpmc_blocking_queue<int> q(1);\n+    q.enqueue(42);\n+\n+    int item = 0;\n+    q.dequeue_for(item, milliseconds::zero());\n+    REQUIRE(item == 42);\n+}\n+\n+TEST_CASE(\"dequeue-full-wait\", \"[mpmc_blocking_q]\")\n+{\n+    spdlog::details::mpmc_blocking_queue<int> q(1);\n+    q.enqueue(42);\n+\n+    int item = 0;\n+    q.dequeue(item);\n+    REQUIRE(item == 42);\n+}\n+\n TEST_CASE(\"enqueue_nowait\", \"[mpmc_blocking_q]\")\n {\n \n@@ -95,12 +115,12 @@ TEST_CASE(\"full_queue\", \"[mpmc_blocking_q]\")\n     for (int i = 1; i < static_cast<int>(q_size); i++)\n     {\n         int item = -1;\n-        q.dequeue_for(item, milliseconds(0));\n+        q.dequeue(item);\n         REQUIRE(item == i);\n     }\n \n     // last item pushed has overridden the oldest.\n     int item = -1;\n-    q.dequeue_for(item, milliseconds(0));\n+    q.dequeue(item);\n     REQUIRE(item == 123456);\n }\n",
        "problem_statement": "tsan false warnings for mpmc_blocking_queue::dequeue_for\ngcc 11.3.0 on Ubuntu 22.04 reports \"data race\" and \"double lock of a mutex\" for `mpmc_blocking_queue::dequeue_for`\r\n\r\nThis is most probably due to this gcc bug - https://gcc.gnu.org/bugzilla//show_bug.cgi?id=101978\r\n\r\nReplacing timed [wait_for](https://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/mpmc_blocking_q.h#L58) with `std::condition_variable::wait` avoids the tsan warnings.\r\n\r\nThis of course should be fixed in gcc, but I am curious what is the reason for wait_for in the first place? Do you see any issues with replacing `wait_for` with `wait`?\n",
        "hints_text": "This is because `mpmc_blocking_queue` is designed as a queue for the Producer-Consumer pattern (as described at the top of the header file).\r\n\r\nhttps://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/mpmc_blocking_q.h#L6-L11\r\n\r\nMany developers may want to allow the Consumer thread to perform other tasks while there are no messages in the queue.\r\nIt is a commonplace idea to implement a dequeue (pop) API with a timeout on the queue for this purpose.\nThe `mpmc_blocking_queue` is only used in `thread_pool` though, where the consumer thread does not perform any idle task. It unnecessarily wakes up the thread every 10s only to go back to waiting for the next message - https://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/thread_pool-inl.h#L114\r\n\r\nIf there is a desire for `mpmc_blocking_queue` to be a generic producer-consumer queue, may be we could add another blocking non-timed `dequeue` and use that in `thread_pool`? Unless I am missing some other reason for the timeout?\nI did not develop `thread_pool` so I don't know why it uses `dequeue_for()`.\r\n\r\nIf you think wakeup every 10 seconds is useless, you can create a PR, but I personally don't see the need to change the current implementation for the purpose of avoiding the compiler sanitizer bug.",
        "created_at": "2022-12-29T22:59:33Z",
        "version": "1.11"
    }
}