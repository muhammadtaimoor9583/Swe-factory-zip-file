{
    "task_id": "gabime__spdlog-892",
    "setup_info": {
        "repo_path": "testbed/gabime__spdlog-892_2025-06-30_11-19-49",
        "repo_cache_path": "testbed/gabime/spdlog_cache"
    },
    "task_info": {
        "repo": "gabime/spdlog",
        "pull_number": 892,
        "instance_id": "gabime__spdlog-892",
        "issue_numbers": [
            "712"
        ],
        "base_commit": "1aace95c8d14944358c0374bbda3ce44d759bef7",
        "patch": "diff --git a/include/spdlog/async.h b/include/spdlog/async.h\n--- a/include/spdlog/async.h\n+++ b/include/spdlog/async.h\n@@ -52,7 +52,7 @@ struct async_factory_impl\n \n         auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n         auto new_logger = std::make_shared<async_logger>(std::move(logger_name), std::move(sink), std::move(tp), OverflowPolicy);\n-        registry_inst.register_and_init(new_logger);\n+        registry_inst.initialize_logger(new_logger);\n         return new_logger;\n     }\n };\ndiff --git a/include/spdlog/details/registry.h b/include/spdlog/details/registry.h\n--- a/include/spdlog/details/registry.h\n+++ b/include/spdlog/details/registry.h\n@@ -47,13 +47,9 @@ class registry\n         loggers_[logger_name] = std::move(new_logger);\n     }\n \n-    void register_and_init(std::shared_ptr<logger> new_logger)\n+    void initialize_logger(std::shared_ptr<logger> new_logger)\n     {\n         std::lock_guard<std::mutex> lock(logger_map_mutex_);\n-        auto logger_name = new_logger->name();\n-        throw_if_exists_(logger_name);\n-\n-        // set the global formatter pattern\n         new_logger->set_formatter(formatter_->clone());\n \n         if (err_handler_)\n@@ -64,8 +60,11 @@ class registry\n         new_logger->set_level(level_);\n         new_logger->flush_on(flush_level_);\n \n-        // add to registry\n-        loggers_[logger_name] = std::move(new_logger);\n+        if (automatic_registration_)\n+        {\n+            throw_if_exists_(new_logger->name());\n+            loggers_[new_logger->name()] = std::move(new_logger);\n+        }\n     }\n \n     std::shared_ptr<logger> get(const std::string &logger_name)\n@@ -223,6 +222,12 @@ class registry\n         return tp_mutex_;\n     }\n \n+    void set_automatic_registration(bool automatic_regsistration)\n+    {\n+        std::lock_guard<std::mutex> lock(logger_map_mutex_);\n+        automatic_registration_ = automatic_regsistration;\n+    }\n+\n     static registry &instance()\n     {\n         static registry s_instance;\n@@ -269,6 +274,7 @@ class registry\n     std::shared_ptr<thread_pool> tp_;\n     std::unique_ptr<periodic_worker> periodic_flusher_;\n     std::shared_ptr<logger> default_logger_;\n+    bool automatic_registration_ = true;\n };\n \n } // namespace details\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -29,7 +29,7 @@ struct synchronous_factory\n     {\n         auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n         auto new_logger = std::make_shared<logger>(std::move(logger_name), std::move(sink));\n-        details::registry::instance().register_and_init(new_logger);\n+        details::registry::instance().initialize_logger(new_logger);\n         return new_logger;\n     }\n };\n@@ -125,6 +125,12 @@ inline void shutdown()\n     details::registry::instance().shutdown();\n }\n \n+// Automatic registration of loggers when using spdlog::create() or spdlog::create_async\n+inline void set_automatic_registration(bool automatic_registation)\n+{\n+    details::registry::instance().set_automatic_registration(automatic_registation);\n+}\n+\n // API for using default logger (stdout_color_mt),\n // e.g: spdlog::info(\"Message {}\", 1);\n //\n",
        "test_patch": "diff --git a/tests/test_registry.cpp b/tests/test_registry.cpp\n--- a/tests/test_registry.cpp\n+++ b/tests/test_registry.cpp\n@@ -93,3 +93,20 @@ TEST_CASE(\"set_default_logger(nullptr)\", \"[registry]\")\n     spdlog::set_default_logger(nullptr);\n     REQUIRE_FALSE(spdlog::default_logger());\n }\n+\n+TEST_CASE(\"disable automatic registration\", \"[registry]\")\n+{\n+    // set some global parameters\n+    spdlog::level::level_enum log_level = spdlog::level::level_enum::warn;\n+    spdlog::set_level(log_level);\n+    // but disable automatic registration\n+    spdlog::set_automatic_registration(false);\n+    auto logger1 = spdlog::create<spdlog::sinks::daily_file_sink_st>(tested_logger_name, \"filename\", 11, 59);\n+    auto logger2 = spdlog::create_async<spdlog::sinks::stdout_color_sink_mt>(tested_logger_name2);\n+    // loggers should not be part of the registry\n+    REQUIRE_FALSE(spdlog::get(tested_logger_name));\n+    REQUIRE_FALSE(spdlog::get(tested_logger_name2));\n+    // but make sure they are still initialized according to global defaults\n+    REQUIRE(logger1->level() == log_level);\n+    REQUIRE(logger2->level() == log_level);\n+}\n",
        "problem_statement": "Create logger without automatic registration\nIt is treacherous that if one wants to create loggers on the spot or have loggers with the same name, they have to do manually everything that `create` does (choose async or not, set level, flush policy, etc). Same things for many other functions whose documentation starts with \"Create and register\"...\r\n\r\nPersonally I do not foresee a case when I will need to register my loggers, so automatic registration is just an impediment. \r\n\r\nSome proposition for backward compatible changes:\r\n- a global flag (`set_automatic_registration`) to disable registration in convenience functions\r\n- an optional argument added to `create` (and maybe every other function automatically registering)\r\n- extra functions which would not register, naming is tricky, `create_local` ? `create_noregister`?\r\n- have the constructor of `logger`lookup the different global variables like `create` does (most intuitive, but casting for `async_logger` would be an issue)\r\n... ?\r\n\n",
        "hints_text": "I think the first option would be the easiest. \nthat would be fine yes",
        "created_at": "2018-11-04T19:31:48Z",
        "version": "1.2"
    }
}