{
    "task_id": "gabime__spdlog-3235",
    "setup_info": {
        "repo_path": "testbed/gabime__spdlog-3235_2025-06-30_12-10-16",
        "repo_cache_path": "testbed/gabime/spdlog_cache"
    },
    "task_info": {
        "repo": "gabime/spdlog",
        "pull_number": 3235,
        "instance_id": "gabime__spdlog-3235",
        "issue_numbers": [
            "3221"
        ],
        "base_commit": "b6da59447f165ad70a4e3ca1c575b14ea66d92c9",
        "patch": "diff --git a/include/spdlog/async_logger-inl.h b/include/spdlog/async_logger-inl.h\n--- a/include/spdlog/async_logger-inl.h\n+++ b/include/spdlog/async_logger-inl.h\n@@ -32,30 +32,26 @@ SPDLOG_INLINE spdlog::async_logger::async_logger(std::string logger_name,\n \n // send the log message to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::sink_it_(const details::log_msg &msg){\n-    SPDLOG_TRY {\n-        if (auto pool_ptr = thread_pool_.lock()){\n-            pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n-        }\n-        else {\n-            throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n-        }\n-    }\n-    SPDLOG_LOGGER_CATCH(msg.source)\n+    SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n+        pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n+}\n+else {\n+    throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n+}\n+}\n+SPDLOG_LOGGER_CATCH(msg.source)\n }\n \n // send flush request to the thread pool\n-SPDLOG_INLINE void spdlog::async_logger::flush_() {\n-    SPDLOG_TRY {\n-        auto pool_ptr = thread_pool_.lock();\n-        if (!pool_ptr) {\n-            throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n-        }\n-\n-        // Wait for the flush operation to complete.\n-        // This might throw exception if the flush message get dropped because of overflow.\n-        pool_ptr->post_and_wait_for_flush(shared_from_this(), overflow_policy_);\n-    }\n-    SPDLOG_LOGGER_CATCH(source_loc())\n+SPDLOG_INLINE void spdlog::async_logger::flush_(){\n+    SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n+        pool_ptr->post_flush(shared_from_this(), overflow_policy_);\n+}\n+else {\n+    throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n+}\n+}\n+SPDLOG_LOGGER_CATCH(source_loc())\n }\n \n //\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -62,25 +62,9 @@ void SPDLOG_INLINE thread_pool::post_log(async_logger_ptr &&worker_ptr,\n     post_async_msg_(std::move(async_m), overflow_policy);\n }\n \n-void SPDLOG_INLINE thread_pool::post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n-                                                        async_overflow_policy overflow_policy) {\n-    std::mutex m;\n-    std::unique_lock<std::mutex> l(m);\n-    std::condition_variable cv;\n-    std::atomic<async_msg_flush> cv_flag{async_msg_flush::not_synced};\n-    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush, [&cv, &cv_flag](async_msg_flush flushed) {\n-        cv_flag.store(flushed, std::memory_order_relaxed);\n-        cv.notify_all();\n-    }), overflow_policy);\n-    while(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::not_synced) {\n-        cv.wait_for(l, std::chrono::milliseconds(100), [&cv_flag]() {\n-            return cv_flag.load(std::memory_order_relaxed) != async_msg_flush::not_synced;\n-        });\n-    }\n-\n-    if(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::synced_not_flushed) {\n-        throw spdlog_ex(\"Request for flushing got dropped.\");\n-    }\n+void SPDLOG_INLINE thread_pool::post_flush(async_logger_ptr &&worker_ptr,\n+                                           async_overflow_policy overflow_policy) {\n+    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush), overflow_policy);\n }\n \n size_t SPDLOG_INLINE thread_pool::overrun_counter() { return q_.overrun_counter(); }\n@@ -124,10 +108,6 @@ bool SPDLOG_INLINE thread_pool::process_next_msg_() {\n         }\n         case async_msg_type::flush: {\n             incoming_async_msg.worker_ptr->backend_flush_();\n-            if(incoming_async_msg.flush_callback) {\n-                incoming_async_msg.flush_callback(async_msg_flush::synced_flushed);\n-                incoming_async_msg.flush_callback = nullptr;\n-            }\n             return true;\n         }\n \ndiff --git a/include/spdlog/details/thread_pool.h b/include/spdlog/details/thread_pool.h\n--- a/include/spdlog/details/thread_pool.h\n+++ b/include/spdlog/details/thread_pool.h\n@@ -22,60 +22,46 @@ using async_logger_ptr = std::shared_ptr<spdlog::async_logger>;\n \n enum class async_msg_type { log, flush, terminate };\n \n-enum class async_msg_flush { not_synced, synced_flushed, synced_not_flushed };\n-\n // Async msg to move to/from the queue\n // Movable only. should never be copied\n struct async_msg : log_msg_buffer {\n     async_msg_type msg_type{async_msg_type::log};\n     async_logger_ptr worker_ptr;\n-    std::function<void(async_msg_flush)> flush_callback;\n \n     async_msg() = default;\n-    ~async_msg() {\n-        if (flush_callback) {\n-            flush_callback(async_msg_flush::synced_not_flushed);\n-            flush_callback = nullptr;\n-        }\n-    }\n+    ~async_msg() = default;\n \n     // should only be moved in or out of the queue..\n     async_msg(const async_msg &) = delete;\n \n-    async_msg(async_msg &&other) SPDLOG_NOEXCEPT\n+// support for vs2013 move\n+#if defined(_MSC_VER) && _MSC_VER <= 1800\n+    async_msg(async_msg &&other)\n         : log_msg_buffer(std::move(other)),\n           msg_type(other.msg_type),\n-          worker_ptr(std::move(other.worker_ptr)),\n-          flush_callback(std::move(other.flush_callback)) {\n-        other.flush_callback = nullptr;\n-    }\n+          worker_ptr(std::move(other.worker_ptr)) {}\n \n-    async_msg &operator=(async_msg &&other) SPDLOG_NOEXCEPT {\n-        *static_cast<log_msg_buffer *>(this) = static_cast<log_msg_buffer&&>(other);\n+    async_msg &operator=(async_msg &&other) {\n+        *static_cast<log_msg_buffer *>(this) = std::move(other);\n         msg_type = other.msg_type;\n         worker_ptr = std::move(other.worker_ptr);\n-        std::swap(flush_callback, other.flush_callback);\n         return *this;\n     }\n+#else  // (_MSC_VER) && _MSC_VER <= 1800\n+    async_msg(async_msg &&) = default;\n+    async_msg &operator=(async_msg &&) = default;\n+#endif\n \n     // construct from log_msg with given type\n     async_msg(async_logger_ptr &&worker, async_msg_type the_type, const details::log_msg &m)\n         : log_msg_buffer{m},\n           msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{} {}\n+          worker_ptr{std::move(worker)} {}\n \n     async_msg(async_logger_ptr &&worker, async_msg_type the_type)\n         : log_msg_buffer{},\n           msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{} {}\n-\n-    async_msg(async_logger_ptr &&worker, async_msg_type the_type, std::function<void(async_msg_flush)> &&callback)\n-        : log_msg_buffer{},\n-          msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{std::move(callback)} {}\n+          worker_ptr{std::move(worker)} {}\n \n     explicit async_msg(async_msg_type the_type)\n         : async_msg{nullptr, the_type} {}\n@@ -102,8 +88,7 @@ class SPDLOG_API thread_pool {\n     void post_log(async_logger_ptr &&worker_ptr,\n                   const details::log_msg &msg,\n                   async_overflow_policy overflow_policy);\n-    void post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n-                                 async_overflow_policy overflow_policy);\n+    void post_flush(async_logger_ptr &&worker_ptr, async_overflow_policy overflow_policy);\n     size_t overrun_counter();\n     void reset_overrun_counter();\n     size_t discard_counter();\n",
        "test_patch": "diff --git a/tests/test_async.cpp b/tests/test_async.cpp\n--- a/tests/test_async.cpp\n+++ b/tests/test_async.cpp\n@@ -93,50 +93,6 @@ TEST_CASE(\"flush\", \"[async]\") {\n     REQUIRE(test_sink->flush_counter() == 1);\n }\n \n-TEST_CASE(\"multithread flush\", \"[async]\") {\n-    auto test_sink = std::make_shared<spdlog::sinks::test_sink_mt>();\n-    size_t queue_size = 2;\n-    size_t messages = 10;\n-    size_t n_threads = 10;\n-    size_t flush_count = 1024;\n-    std::mutex mtx;\n-    std::vector<std::string> errmsgs;\n-    {\n-        auto tp = std::make_shared<spdlog::details::thread_pool>(queue_size, 1);\n-        auto logger = std::make_shared<spdlog::async_logger>(\n-            \"as\", test_sink, tp, spdlog::async_overflow_policy::discard_new);\n-\n-        logger->set_error_handler([&](const std::string &) {\n-            std::unique_lock<std::mutex> lock(mtx);\n-            errmsgs.push_back(\"Broken promise\");\n-        });\n-\n-        for (size_t i = 0; i < messages; i++) {\n-            logger->info(\"Hello message #{}\", i);\n-        }\n-\n-        std::vector<std::thread> threads;\n-        for (size_t i = 0; i < n_threads; i++) {\n-            threads.emplace_back([logger, flush_count] {\n-                for (size_t j = 0; j < flush_count; j++) {\n-                    // flush does not throw exception even if failed.\n-                    // Instead, the error handler is invoked.\n-                    logger->flush();\n-                }\n-            });\n-        }\n-\n-        for (auto &t : threads) {\n-            t.join();\n-        }\n-    }\n-    REQUIRE(test_sink->flush_counter() >= 1);\n-    REQUIRE(test_sink->flush_counter() + errmsgs.size() == n_threads * flush_count);\n-    if (errmsgs.size() > 0) {\n-        REQUIRE(errmsgs[0] == \"Broken promise\");\n-    }\n-}\n-\n TEST_CASE(\"async periodic flush\", \"[async]\") {\n     auto logger = spdlog::create_async<spdlog::sinks::test_sink_mt>(\"as\");\n     auto test_sink = std::static_pointer_cast<spdlog::sinks::test_sink_mt>(logger->sinks()[0]);\n",
        "problem_statement": "1.14.1 unresolvable R_X86_64_TPOFF32 relocation \nUpdating spdlog to 1.14.1, I get the following linker error:\r\n```\r\n/usr/bin/c++ -Wno-maybe-uninitialized  -ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries test/CMakeFiles/EtcdTests.dir/EtcdTests.cpp.o -o /opt/ichor/src/bin/EtcdTests  /opt/ichor/src/bin/libichor.a  /opt/ichor/src/bin/libCatch2Main.a  -lsystemd  /usr/lib/libboost_coroutine.a  /usr/lib/libboost_fiber.a  /usr/lib/libboost_context.a  /usr/lib/libboost_filesystem.a  /usr/lib/libssl.a  /usr/lib/libcrypto.a  -ldl  -lhiredis  -ldl  -lrt  /opt/ichor/src/bin/libCatch2.a && :\r\n/usr/bin/ld: /opt/ichor/src/bin/libichor.a(async.cpp.o)(.text+0x266e): unresolvable R_X86_64_TPOFF32 relocation against symbol `_ZSt15__once_callable@@GLIBCXX_3.4.11'\r\n```\r\n\r\nThis doesn't happen with 1.13.0, or when `ftls-model=local-exec` is removed from the compiler flags.\r\n\r\nCompiler: gcc 12.3.0\r\nLinux: Ubuntu Jammy\r\ncxxflags: `-O2 -std=c++20 -fpie -fstack-protector-strong -fcf-protection -fstack-clash-protection -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -D_GLIBCXX_ASSERTIONS -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_FAST -ftls-model=local-exec`\r\nlinkflags: `-ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries`\n",
        "hints_text": "It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\nMaybe duplicate #1405\n> It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\r\n\r\nonce_callable is likely a thread_local related symbol, which glibc uses. The error shows that this happens in [async.cpp](https://github.com/gabime/spdlog/blob/v1.x/src/async.cpp), which includes a bunch of spdlog related files. \r\n\r\n\r\n\r\n> Maybe duplicate #1405\r\n\r\n`-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\n> `-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\r\n\r\nAs far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\n> As far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\r\n\r\nYour linked stackoverflow is saying the same thing as I am. As long as the end result is a dynamic library (either directly, or by first creating a static library which is then linked into a dynamic library), `-fPIC` is useful. This can also be gleaned from the [gcc manual](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html): \r\n\r\n> Generate position-independent code (PIC) suitable for use in a shared library ...\r\n\r\nHowever, I am not creating a shared library anywhere in my workflow. I make a static library and link it directly into an executable. Therefore, I use `-fpie` (since my GOT tables aren't too big to need to use `-fPIE`) and `-fPIC` has no effect on the problem at hand. I know, because I've added it to the compiler flags and it resulted in the same error I mentioned above.\r\n\r\nI have bisected the problem to [6725584e27ca93f50527165696d7cf34e3978373](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373). And specifically, the call to `set_value()` in [thread_pool-inl.h:115](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373#diff-6c9b5dd2454f632886023e6bc86e7b04fe7d0f1be5c25d505679987a7da7b05dR115). \r\n\r\n`promise<>::set_value()` ends up calling [std::call_once](https://github.com/gcc-mirror/gcc/blob/8fc1a49c9312b05d925b7d21f1d2145d70818151/libstdc%2B%2B-v3/include/std/future#L426), which requires thread local storage and GCC requires the glibcxx once_callable symbol (which is probably some pthread_once alias). `ftls-model=local-exec` disables the usage of `thread_local` storage which has not been defined inside the executable itself. And the `once_callable` symbol resides in `libc.so.6`. \r\n\r\nOn top of that, unfortunately, gcc has had a [pretty bad bug](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146) with `std::call_once` and exceptions since gcc 5.x, making it impossible to support handling exceptions during a `std::call_once` call on musl and other non-glibc, non-x86 targets. Not the case here, but certainly something to consider.\r\n\r\nThe options I see are as follows:\r\n* Change compiler flags to `ftls-model=initial-exec`, losing some performance whenever I access `thread_local` variables\r\n* Refactor the `std::promise`/`std::future` to a `std::function` of sorts.\r\n* Patch out the specific commit in my own fork\nThanks for the accurate investigation.\r\nI had never heard of the `std::call_once` bug in GCC.\r\nIt would be helpful if you could send the PR.\nSure, I'll take a stab when I have some free time. It would likely be a backwards incompatible change though. Or should I put in a `#ifdef` to control the function signature?\nPersonally, I think it is a bug and should be fixed even if it is not compatible.\r\nHowever, I am not this repository maintainer, so the final decision is up to @gabime.",
        "created_at": "2024-11-01T09:13:47Z",
        "version": "1.14"
    }
}