{
    "task_id": "gabime__spdlog-3398",
    "setup_info": {
        "repo_path": "testbed/gabime__spdlog-3398_2025-06-30_12-10-16",
        "repo_cache_path": "testbed/gabime/spdlog_cache"
    },
    "task_info": {
        "repo": "gabime/spdlog",
        "pull_number": 3398,
        "instance_id": "gabime__spdlog-3398",
        "issue_numbers": [
            "3391"
        ],
        "base_commit": "7e022c430053f71c3db80bf0eb3432392932f7e3",
        "patch": "diff --git a/include/spdlog/details/registry-inl.h b/include/spdlog/details/registry-inl.h\n--- a/include/spdlog/details/registry-inl.h\n+++ b/include/spdlog/details/registry-inl.h\n@@ -54,6 +54,11 @@ SPDLOG_INLINE void registry::register_logger(std::shared_ptr<logger> new_logger)\n     register_logger_(std::move(new_logger));\n }\n \n+SPDLOG_INLINE void registry::register_or_replace(std::shared_ptr<logger> new_logger) {\n+    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n+    register_or_replace_(std::move(new_logger));\n+}\n+\n SPDLOG_INLINE void registry::initialize_logger(std::shared_ptr<logger> new_logger) {\n     std::lock_guard<std::mutex> lock(logger_map_mutex_);\n     new_logger->set_formatter(formatter_->clone());\n@@ -252,10 +257,14 @@ SPDLOG_INLINE void registry::throw_if_exists_(const std::string &logger_name) {\n }\n \n SPDLOG_INLINE void registry::register_logger_(std::shared_ptr<logger> new_logger) {\n-    auto logger_name = new_logger->name();\n+    auto &logger_name = new_logger->name();\n     throw_if_exists_(logger_name);\n     loggers_[logger_name] = std::move(new_logger);\n }\n \n+SPDLOG_INLINE void registry::register_or_replace_(std::shared_ptr<logger> new_logger) {\n+    loggers_[new_logger->name()] = std::move(new_logger);\n+}\n+\n }  // namespace details\n }  // namespace spdlog\ndiff --git a/include/spdlog/details/registry.h b/include/spdlog/details/registry.h\n--- a/include/spdlog/details/registry.h\n+++ b/include/spdlog/details/registry.h\n@@ -31,6 +31,7 @@ class SPDLOG_API registry {\n     registry &operator=(const registry &) = delete;\n \n     void register_logger(std::shared_ptr<logger> new_logger);\n+    void register_or_replace(std::shared_ptr<logger> new_logger);\n     void initialize_logger(std::shared_ptr<logger> new_logger);\n     std::shared_ptr<logger> get(const std::string &logger_name);\n     std::shared_ptr<logger> default_logger();\n@@ -105,6 +106,7 @@ class SPDLOG_API registry {\n \n     void throw_if_exists_(const std::string &logger_name);\n     void register_logger_(std::shared_ptr<logger> new_logger);\n+    void register_or_replace_(std::shared_ptr<logger> new_logger);\n     bool set_level_from_cfg_(logger *logger);\n     std::mutex logger_map_mutex_, flusher_mutex_;\n     std::recursive_mutex tp_mutex_;\ndiff --git a/include/spdlog/spdlog-inl.h b/include/spdlog/spdlog-inl.h\n--- a/include/spdlog/spdlog-inl.h\n+++ b/include/spdlog/spdlog-inl.h\n@@ -59,6 +59,10 @@ SPDLOG_INLINE void register_logger(std::shared_ptr<logger> logger) {\n     details::registry::instance().register_logger(std::move(logger));\n }\n \n+SPDLOG_INLINE void register_or_replace(std::shared_ptr<logger> logger) {\n+    details::registry::instance().register_or_replace(std::move(logger));\n+}\n+\n SPDLOG_INLINE void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun) {\n     details::registry::instance().apply_all(fun);\n }\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -25,7 +25,7 @@ namespace spdlog {\n using default_factory = synchronous_factory;\n \n // Create and register a logger with a templated sink type\n-// The logger's level, formatter and flush level will be set according the\n+// The logger's level, formatter and flush level will be set according to the\n // global settings.\n //\n // Example:\n@@ -46,7 +46,7 @@ inline std::shared_ptr<spdlog::logger> create(std::string logger_name, SinkArgs\n //   spdlog::initialize_logger(mylogger);\n SPDLOG_API void initialize_logger(std::shared_ptr<logger> logger);\n \n-// Return an existing logger or nullptr if a logger with such name doesn't\n+// Return an existing logger or nullptr if a logger with such a name doesn't\n // exist.\n // example: spdlog::get(\"my_logger\")->info(\"hello {}\", \"world\");\n SPDLOG_API std::shared_ptr<logger> get(const std::string &name);\n@@ -71,13 +71,13 @@ SPDLOG_API void dump_backtrace();\n // Get global logging level\n SPDLOG_API level::level_enum get_level();\n \n-// Set global logging level\n+// Set the global logging level\n SPDLOG_API void set_level(level::level_enum log_level);\n \n // Determine whether the default logger should log messages with a certain level\n SPDLOG_API bool should_log(level::level_enum lvl);\n \n-// Set global flush level\n+// Set a global flush level\n SPDLOG_API void flush_on(level::level_enum log_level);\n \n // Start/Restart a periodic flusher thread\n@@ -91,9 +91,14 @@ inline void flush_every(std::chrono::duration<Rep, Period> interval) {\n SPDLOG_API void set_error_handler(void (*handler)(const std::string &msg));\n \n // Register the given logger with the given name\n+// Will throw if a logger with the same name already exists.\n SPDLOG_API void register_logger(std::shared_ptr<logger> logger);\n \n-// Apply a user defined function on all registered loggers\n+// Register the given logger with the given name\n+// Will replace any the existing logger with the same name if exists.\n+SPDLOG_API void register_or_replace(std::shared_ptr<logger> logger);\n+\n+// Apply a user-defined function on all registered loggers\n // Example:\n // spdlog::apply_all([&](std::shared_ptr<spdlog::logger> l) {l->flush();});\n SPDLOG_API void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun);\n@@ -111,19 +116,19 @@ SPDLOG_API void shutdown();\n SPDLOG_API void set_automatic_registration(bool automatic_registration);\n \n // API for using default logger (stdout_color_mt),\n-// e.g: spdlog::info(\"Message {}\", 1);\n+// e.g.: spdlog::info(\"Message {}\", 1);\n //\n // The default logger object can be accessed using the spdlog::default_logger():\n // For example, to add another sink to it:\n // spdlog::default_logger()->sinks().push_back(some_sink);\n //\n-// The default logger can replaced using spdlog::set_default_logger(new_logger).\n+// The default logger can be replaced using spdlog::set_default_logger(new_logger).\n // For example, to replace it with a file logger.\n //\n // IMPORTANT:\n // The default API is thread safe (for _mt loggers), but:\n // set_default_logger() *should not* be used concurrently with the default API.\n-// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.\n+// e.g., do not call set_default_logger() from one thread while calling spdlog::info() from another.\n \n SPDLOG_API std::shared_ptr<spdlog::logger> default_logger();\n \n",
        "test_patch": "diff --git a/tests/test_registry.cpp b/tests/test_registry.cpp\n--- a/tests/test_registry.cpp\n+++ b/tests/test_registry.cpp\n@@ -25,6 +25,18 @@ TEST_CASE(\"explicit register\", \"[registry]\") {\n }\n #endif\n \n+TEST_CASE(\"register_or_replace\", \"[registry]\") {\n+    spdlog::drop_all();\n+    auto logger1 = std::make_shared<spdlog::logger>(tested_logger_name,\n+                                                   std::make_shared<spdlog::sinks::null_sink_st>());\n+    spdlog::register_logger(logger1);\n+    REQUIRE(spdlog::get(tested_logger_name) == logger1);\n+\n+    auto logger2 = std::make_shared<spdlog::logger>(tested_logger_name, std::make_shared<spdlog::sinks::null_sink_st>());\n+    spdlog::register_or_replace(logger2);\n+    REQUIRE(spdlog::get(tested_logger_name) == logger2);\n+}\n+\n TEST_CASE(\"apply_all\", \"[registry]\") {\n     spdlog::drop_all();\n     auto logger = std::make_shared<spdlog::logger>(tested_logger_name,\n",
        "problem_statement": "How can I safely replace a registered logger?\nThis issue is related to #820 and #3014.\n\nI have an already initialized and registered logger that may already be in use in several threads. The logger is retrieved by calling `spdlog::get(\"mylibraryname\")`. I wish to overwrite the sink list with a different set of sinks. As noted in https://github.com/gabime/spdlog/issues/820#issuecomment-418174191, this operation is not thread safe, so my library would have to implement a global spdlog mutex on top of spdlog's own mutexes, which is highly impractical.\n\nA safer option is to create a new logger, fill it with the desired sinks, unregister the old one and register the new logger under the same name. Any functions (possibly running in different threads while the logger exchange is taking place) which still have a `std::shared_ptr<spdlog::logger>` reference to the old logger will still use it after the new logger is registered. I believe that this is unavoidable and safe behavior.\n\nThe old logger will eventually be destructed once the functions in different threads which hold a reference to it return (unless they store the shared pointer somewhere; spdlog's documentation recommends storing such references as private members of classes; this can be highly problematic in this scenario, but it is easier to fix than to mutex everything spdlog related manually).\n\nThe problem is that spdlog (to my knowledge) provides no \"overwrite register\" function. Functions can only be registered and unregistered, not assigned into. This can lead to the following problem:\n\n```cpp\nstd::shared_ptr<spdlog::logger> new_logger = ...;\nspdlog::drop(\"mylibraryname\");\n// Here a second thread calls spdlog::get(\"mylibraryname\"), which fails\nspdlog::register_logger(std::move(new_logger));\n```\n\n**Desired solution:**\nAdd a function to the `spdlog` namespace implementing this functionality and document the issues with replacing sinks/loggers somewhere.\n",
        "hints_text": "Right, PR is welcome\nFYI.\nI believe that the request to replace the logger means that you want to replace sinks in most cases.\nIf so, `spdlog::sinks::dist_sink::set_sink(std::vector<std::shared_ptr<sink>>)` should be able to accomplish that.\n\nhttps://github.com/gabime/spdlog/blob/847db3375f35dca23e45f9daf7ad3c7b19027f8b/include/spdlog/sinks/dist_sink.h#L42-L45\n\n```cpp\nauto sinks = ...\nauto dist_sink = std::make_shared<spdlog::sinks::dist_sink_mt>(sinks);\nauto logger = std::make_shared<spdlog::logger>(\"dist_logger\", dist_sink);\nspdlog::register_logger(logger);\n\n// Replace sinks;\nauto new_sinks = ...\ndist_sink->set_sink(new_sinks);\n```\n@tt4g You are right, this seems to be the best solution. Adding one level of indirection (having logger -> dist_sink -> sinks... instead of logger -> sinks...) should solve this problem. It also doesn't suffer from the primary drawback of my approach, the old logger still lingering.\n\n`spdlog::sinks::dist_sink::add_sink()`, `spdlog::sinks::dist_sink::remove_sink()` and `spdlog::sinks::dist_sink::set_sinks()` seem to be thread safe, they use the base_sink's mutex.\n\nEven though my specific issue is solved, being able to overwrite/swap a registered logger may still prove to be useful to someone.\n\n> I believe that the request to replace the logger means that you want to replace sinks in most cases.\n\nIf that is indeed the case, providing a function to replace a registered logger may not be necessary, the solution you have provided covers that.\nRight, though I still think having a way to atomically change a logger in registry is an easier solution. \n\nWhy was this issue closed?\nBecause there is a solution using the dist sink. ",
        "created_at": "2025-05-08T12:34:24Z",
        "version": "1.15"
    }
}