{"repo": "gabime/spdlog", "pull_number": 3398, "instance_id": "gabime__spdlog-3398", "issue_numbers": ["3391"], "base_commit": "7e022c430053f71c3db80bf0eb3432392932f7e3", "patch": "diff --git a/include/spdlog/details/registry-inl.h b/include/spdlog/details/registry-inl.h\n--- a/include/spdlog/details/registry-inl.h\n+++ b/include/spdlog/details/registry-inl.h\n@@ -54,6 +54,11 @@ SPDLOG_INLINE void registry::register_logger(std::shared_ptr<logger> new_logger)\n     register_logger_(std::move(new_logger));\n }\n \n+SPDLOG_INLINE void registry::register_or_replace(std::shared_ptr<logger> new_logger) {\n+    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n+    register_or_replace_(std::move(new_logger));\n+}\n+\n SPDLOG_INLINE void registry::initialize_logger(std::shared_ptr<logger> new_logger) {\n     std::lock_guard<std::mutex> lock(logger_map_mutex_);\n     new_logger->set_formatter(formatter_->clone());\n@@ -252,10 +257,14 @@ SPDLOG_INLINE void registry::throw_if_exists_(const std::string &logger_name) {\n }\n \n SPDLOG_INLINE void registry::register_logger_(std::shared_ptr<logger> new_logger) {\n-    auto logger_name = new_logger->name();\n+    auto &logger_name = new_logger->name();\n     throw_if_exists_(logger_name);\n     loggers_[logger_name] = std::move(new_logger);\n }\n \n+SPDLOG_INLINE void registry::register_or_replace_(std::shared_ptr<logger> new_logger) {\n+    loggers_[new_logger->name()] = std::move(new_logger);\n+}\n+\n }  // namespace details\n }  // namespace spdlog\ndiff --git a/include/spdlog/details/registry.h b/include/spdlog/details/registry.h\n--- a/include/spdlog/details/registry.h\n+++ b/include/spdlog/details/registry.h\n@@ -31,6 +31,7 @@ class SPDLOG_API registry {\n     registry &operator=(const registry &) = delete;\n \n     void register_logger(std::shared_ptr<logger> new_logger);\n+    void register_or_replace(std::shared_ptr<logger> new_logger);\n     void initialize_logger(std::shared_ptr<logger> new_logger);\n     std::shared_ptr<logger> get(const std::string &logger_name);\n     std::shared_ptr<logger> default_logger();\n@@ -105,6 +106,7 @@ class SPDLOG_API registry {\n \n     void throw_if_exists_(const std::string &logger_name);\n     void register_logger_(std::shared_ptr<logger> new_logger);\n+    void register_or_replace_(std::shared_ptr<logger> new_logger);\n     bool set_level_from_cfg_(logger *logger);\n     std::mutex logger_map_mutex_, flusher_mutex_;\n     std::recursive_mutex tp_mutex_;\ndiff --git a/include/spdlog/spdlog-inl.h b/include/spdlog/spdlog-inl.h\n--- a/include/spdlog/spdlog-inl.h\n+++ b/include/spdlog/spdlog-inl.h\n@@ -59,6 +59,10 @@ SPDLOG_INLINE void register_logger(std::shared_ptr<logger> logger) {\n     details::registry::instance().register_logger(std::move(logger));\n }\n \n+SPDLOG_INLINE void register_or_replace(std::shared_ptr<logger> logger) {\n+    details::registry::instance().register_or_replace(std::move(logger));\n+}\n+\n SPDLOG_INLINE void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun) {\n     details::registry::instance().apply_all(fun);\n }\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -25,7 +25,7 @@ namespace spdlog {\n using default_factory = synchronous_factory;\n \n // Create and register a logger with a templated sink type\n-// The logger's level, formatter and flush level will be set according the\n+// The logger's level, formatter and flush level will be set according to the\n // global settings.\n //\n // Example:\n@@ -46,7 +46,7 @@ inline std::shared_ptr<spdlog::logger> create(std::string logger_name, SinkArgs\n //   spdlog::initialize_logger(mylogger);\n SPDLOG_API void initialize_logger(std::shared_ptr<logger> logger);\n \n-// Return an existing logger or nullptr if a logger with such name doesn't\n+// Return an existing logger or nullptr if a logger with such a name doesn't\n // exist.\n // example: spdlog::get(\"my_logger\")->info(\"hello {}\", \"world\");\n SPDLOG_API std::shared_ptr<logger> get(const std::string &name);\n@@ -71,13 +71,13 @@ SPDLOG_API void dump_backtrace();\n // Get global logging level\n SPDLOG_API level::level_enum get_level();\n \n-// Set global logging level\n+// Set the global logging level\n SPDLOG_API void set_level(level::level_enum log_level);\n \n // Determine whether the default logger should log messages with a certain level\n SPDLOG_API bool should_log(level::level_enum lvl);\n \n-// Set global flush level\n+// Set a global flush level\n SPDLOG_API void flush_on(level::level_enum log_level);\n \n // Start/Restart a periodic flusher thread\n@@ -91,9 +91,14 @@ inline void flush_every(std::chrono::duration<Rep, Period> interval) {\n SPDLOG_API void set_error_handler(void (*handler)(const std::string &msg));\n \n // Register the given logger with the given name\n+// Will throw if a logger with the same name already exists.\n SPDLOG_API void register_logger(std::shared_ptr<logger> logger);\n \n-// Apply a user defined function on all registered loggers\n+// Register the given logger with the given name\n+// Will replace any the existing logger with the same name if exists.\n+SPDLOG_API void register_or_replace(std::shared_ptr<logger> logger);\n+\n+// Apply a user-defined function on all registered loggers\n // Example:\n // spdlog::apply_all([&](std::shared_ptr<spdlog::logger> l) {l->flush();});\n SPDLOG_API void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun);\n@@ -111,19 +116,19 @@ SPDLOG_API void shutdown();\n SPDLOG_API void set_automatic_registration(bool automatic_registration);\n \n // API for using default logger (stdout_color_mt),\n-// e.g: spdlog::info(\"Message {}\", 1);\n+// e.g.: spdlog::info(\"Message {}\", 1);\n //\n // The default logger object can be accessed using the spdlog::default_logger():\n // For example, to add another sink to it:\n // spdlog::default_logger()->sinks().push_back(some_sink);\n //\n-// The default logger can replaced using spdlog::set_default_logger(new_logger).\n+// The default logger can be replaced using spdlog::set_default_logger(new_logger).\n // For example, to replace it with a file logger.\n //\n // IMPORTANT:\n // The default API is thread safe (for _mt loggers), but:\n // set_default_logger() *should not* be used concurrently with the default API.\n-// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.\n+// e.g., do not call set_default_logger() from one thread while calling spdlog::info() from another.\n \n SPDLOG_API std::shared_ptr<spdlog::logger> default_logger();\n \n", "test_patch": "diff --git a/tests/test_registry.cpp b/tests/test_registry.cpp\n--- a/tests/test_registry.cpp\n+++ b/tests/test_registry.cpp\n@@ -25,6 +25,18 @@ TEST_CASE(\"explicit register\", \"[registry]\") {\n }\n #endif\n \n+TEST_CASE(\"register_or_replace\", \"[registry]\") {\n+    spdlog::drop_all();\n+    auto logger1 = std::make_shared<spdlog::logger>(tested_logger_name,\n+                                                   std::make_shared<spdlog::sinks::null_sink_st>());\n+    spdlog::register_logger(logger1);\n+    REQUIRE(spdlog::get(tested_logger_name) == logger1);\n+\n+    auto logger2 = std::make_shared<spdlog::logger>(tested_logger_name, std::make_shared<spdlog::sinks::null_sink_st>());\n+    spdlog::register_or_replace(logger2);\n+    REQUIRE(spdlog::get(tested_logger_name) == logger2);\n+}\n+\n TEST_CASE(\"apply_all\", \"[registry]\") {\n     spdlog::drop_all();\n     auto logger = std::make_shared<spdlog::logger>(tested_logger_name,\n", "problem_statement": "How can I safely replace a registered logger?\nThis issue is related to #820 and #3014.\n\nI have an already initialized and registered logger that may already be in use in several threads. The logger is retrieved by calling `spdlog::get(\"mylibraryname\")`. I wish to overwrite the sink list with a different set of sinks. As noted in https://github.com/gabime/spdlog/issues/820#issuecomment-418174191, this operation is not thread safe, so my library would have to implement a global spdlog mutex on top of spdlog's own mutexes, which is highly impractical.\n\nA safer option is to create a new logger, fill it with the desired sinks, unregister the old one and register the new logger under the same name. Any functions (possibly running in different threads while the logger exchange is taking place) which still have a `std::shared_ptr<spdlog::logger>` reference to the old logger will still use it after the new logger is registered. I believe that this is unavoidable and safe behavior.\n\nThe old logger will eventually be destructed once the functions in different threads which hold a reference to it return (unless they store the shared pointer somewhere; spdlog's documentation recommends storing such references as private members of classes; this can be highly problematic in this scenario, but it is easier to fix than to mutex everything spdlog related manually).\n\nThe problem is that spdlog (to my knowledge) provides no \"overwrite register\" function. Functions can only be registered and unregistered, not assigned into. This can lead to the following problem:\n\n```cpp\nstd::shared_ptr<spdlog::logger> new_logger = ...;\nspdlog::drop(\"mylibraryname\");\n// Here a second thread calls spdlog::get(\"mylibraryname\"), which fails\nspdlog::register_logger(std::move(new_logger));\n```\n\n**Desired solution:**\nAdd a function to the `spdlog` namespace implementing this functionality and document the issues with replacing sinks/loggers somewhere.\n", "hints_text": "Right, PR is welcome\nFYI.\nI believe that the request to replace the logger means that you want to replace sinks in most cases.\nIf so, `spdlog::sinks::dist_sink::set_sink(std::vector<std::shared_ptr<sink>>)` should be able to accomplish that.\n\nhttps://github.com/gabime/spdlog/blob/847db3375f35dca23e45f9daf7ad3c7b19027f8b/include/spdlog/sinks/dist_sink.h#L42-L45\n\n```cpp\nauto sinks = ...\nauto dist_sink = std::make_shared<spdlog::sinks::dist_sink_mt>(sinks);\nauto logger = std::make_shared<spdlog::logger>(\"dist_logger\", dist_sink);\nspdlog::register_logger(logger);\n\n// Replace sinks;\nauto new_sinks = ...\ndist_sink->set_sink(new_sinks);\n```\n@tt4g You are right, this seems to be the best solution. Adding one level of indirection (having logger -> dist_sink -> sinks... instead of logger -> sinks...) should solve this problem. It also doesn't suffer from the primary drawback of my approach, the old logger still lingering.\n\n`spdlog::sinks::dist_sink::add_sink()`, `spdlog::sinks::dist_sink::remove_sink()` and `spdlog::sinks::dist_sink::set_sinks()` seem to be thread safe, they use the base_sink's mutex.\n\nEven though my specific issue is solved, being able to overwrite/swap a registered logger may still prove to be useful to someone.\n\n> I believe that the request to replace the logger means that you want to replace sinks in most cases.\n\nIf that is indeed the case, providing a function to replace a registered logger may not be necessary, the solution you have provided covers that.\nRight, though I still think having a way to atomically change a logger in registry is an easier solution. \n\nWhy was this issue closed?\nBecause there is a solution using the dist sink. ", "created_at": "2025-05-08T12:34:24Z"}
{"repo": "gabime/spdlog", "pull_number": 3397, "instance_id": "gabime__spdlog-3397", "issue_numbers": ["3379", "3379"], "base_commit": "548b264254b7cbbf68f9003315ea958edacb91e5", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -18,39 +18,38 @@ include(GNUInstallDirs)\n # ---------------------------------------------------------------------------------------\n # Set default build to release\n # ---------------------------------------------------------------------------------------\n-if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n+if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n     set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING \"Choose Release or Debug\" FORCE)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Compiler config\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_USE_STD_FORMAT)\n+if(SPDLOG_USE_STD_FORMAT)\n     set(CMAKE_CXX_STANDARD 20)\n     set(CMAKE_CXX_STANDARD_REQUIRED ON)\n-elseif (NOT CMAKE_CXX_STANDARD)\n+elseif(NOT CMAKE_CXX_STANDARD)\n     set(CMAKE_CXX_STANDARD 11)\n     set(CMAKE_CXX_STANDARD_REQUIRED ON)\n-endif ()\n-\n+endif()\n \n set(CMAKE_CXX_EXTENSIONS OFF)\n \n-if (CMAKE_SYSTEM_NAME MATCHES \"CYGWIN\" OR CMAKE_SYSTEM_NAME MATCHES \"MSYS\" OR CMAKE_SYSTEM_NAME MATCHES \"MINGW\")\n+if(CMAKE_SYSTEM_NAME MATCHES \"CYGWIN\" OR CMAKE_SYSTEM_NAME MATCHES \"MSYS\" OR CMAKE_SYSTEM_NAME MATCHES \"MINGW\")\n     set(CMAKE_CXX_EXTENSIONS ON)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Set SPDLOG_MASTER_PROJECT to ON if we are building spdlog\n # ---------------------------------------------------------------------------------------\n # Check if spdlog is being used directly or via add_subdirectory, but allow overriding\n-if (NOT DEFINED SPDLOG_MASTER_PROJECT)\n-    if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n+if(NOT DEFINED SPDLOG_MASTER_PROJECT)\n+    if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n         set(SPDLOG_MASTER_PROJECT ON)\n-    else ()\n+    else()\n         set(SPDLOG_MASTER_PROJECT OFF)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n \n option(SPDLOG_BUILD_ALL \"Build all artifacts\" OFF)\n \n@@ -77,9 +76,9 @@ option(SPDLOG_BUILD_BENCH \"Build benchmarks (Requires https://github.com/google/\n # sanitizer options\n option(SPDLOG_SANITIZE_ADDRESS \"Enable address sanitizer in tests\" OFF)\n option(SPDLOG_SANITIZE_THREAD \"Enable thread sanitizer in tests\" OFF)\n-if (SPDLOG_SANITIZE_ADDRESS AND SPDLOG_SANITIZE_THREAD)\n+if(SPDLOG_SANITIZE_ADDRESS AND SPDLOG_SANITIZE_THREAD)\n     message(FATAL_ERROR \"SPDLOG_SANITIZE_ADDRESS and SPDLOG_SANITIZE_THREAD are mutually exclusive\")\n-endif ()\n+endif()\n \n # warning options\n option(SPDLOG_BUILD_WARNINGS \"Enable compiler warnings\" OFF)\n@@ -92,61 +91,61 @@ option(SPDLOG_FMT_EXTERNAL \"Use external fmt library instead of bundled\" OFF)\n option(SPDLOG_FMT_EXTERNAL_HO \"Use external fmt header-only library instead of bundled\" OFF)\n option(SPDLOG_NO_EXCEPTIONS \"Compile with -fno-exceptions. Call abort() on any spdlog exceptions\" OFF)\n \n-if (SPDLOG_FMT_EXTERNAL AND SPDLOG_FMT_EXTERNAL_HO)\n+if(SPDLOG_FMT_EXTERNAL AND SPDLOG_FMT_EXTERNAL_HO)\n     message(FATAL_ERROR \"SPDLOG_FMT_EXTERNAL and SPDLOG_FMT_EXTERNAL_HO are mutually exclusive\")\n-endif ()\n+endif()\n \n-if (SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL_HO)\n+if(SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL_HO)\n     message(FATAL_ERROR \"SPDLOG_USE_STD_FORMAT and SPDLOG_FMT_EXTERNAL_HO are mutually exclusive\")\n-endif ()\n+endif()\n \n-if (SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL)\n+if(SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL)\n     message(FATAL_ERROR \"SPDLOG_USE_STD_FORMAT and SPDLOG_FMT_EXTERNAL are mutually exclusive\")\n-endif ()\n+endif()\n \n # misc tweakme options\n-if (WIN32)\n+if(WIN32)\n     option(SPDLOG_WCHAR_SUPPORT \"Support wchar api\" OFF)\n     option(SPDLOG_WCHAR_FILENAMES \"Support wchar filenames\" OFF)\n     option(SPDLOG_WCHAR_CONSOLE \"Support wchar output to console\" OFF)\n-else ()\n+else()\n     set(SPDLOG_WCHAR_SUPPORT OFF CACHE BOOL \"non supported option\" FORCE)\n     set(SPDLOG_WCHAR_FILENAMES OFF CACHE BOOL \"non supported option\" FORCE)\n     set(SPDLOG_WCHAR_CONSOLE OFF CACHE BOOL \"non supported option\" FORCE)\n-endif ()\n+endif()\n \n-if (MSVC)\n+if(MSVC)\n     option(SPDLOG_MSVC_UTF8 \"Enable/disable msvc /utf-8 flag required by fmt lib\" ON)\n-endif ()\n+endif()\n \n-if (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n+if(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n     option(SPDLOG_CLOCK_COARSE \"Use CLOCK_REALTIME_COARSE instead of the regular clock,\" OFF)\n-else ()\n+else()\n     set(SPDLOG_CLOCK_COARSE OFF CACHE BOOL \"non supported option\" FORCE)\n-endif ()\n+endif()\n \n option(SPDLOG_PREVENT_CHILD_FD \"Prevent from child processes to inherit log file descriptors\" OFF)\n option(SPDLOG_NO_THREAD_ID \"prevent spdlog from querying the thread id on each log call if thread id is not needed\" OFF)\n option(SPDLOG_NO_TLS \"prevent spdlog from using thread local storage\" OFF)\n option(\n-        SPDLOG_NO_ATOMIC_LEVELS\n-        \"prevent spdlog from using of std::atomic log levels (use only if your code never modifies log levels concurrently\"\n-        OFF)\n+    SPDLOG_NO_ATOMIC_LEVELS\n+    \"prevent spdlog from using of std::atomic log levels (use only if your code never modifies log levels concurrently\"\n+    OFF)\n option(SPDLOG_DISABLE_DEFAULT_LOGGER \"Disable default logger creation\" OFF)\n option(SPDLOG_FWRITE_UNLOCKED \"Use the unlocked variant of fwrite. Leave this on unless your libc doesn't have it\" ON)\n \n # clang-tidy\n option(SPDLOG_TIDY \"run clang-tidy\" OFF)\n \n-if (SPDLOG_TIDY)\n+if(SPDLOG_TIDY)\n     set(CMAKE_CXX_CLANG_TIDY \"clang-tidy\")\n     set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n     message(STATUS \"Enabled clang-tidy\")\n-endif ()\n+endif()\n \n-if (SPDLOG_BUILD_PIC)\n+if(SPDLOG_BUILD_PIC)\n     set(CMAKE_POSITION_INDEPENDENT_CODE ON)\n-endif ()\n+endif()\n \n find_package(Threads REQUIRED)\n message(STATUS \"Build type: \" ${CMAKE_BUILD_TYPE})\n@@ -155,56 +154,56 @@ message(STATUS \"Build type: \" ${CMAKE_BUILD_TYPE})\n # ---------------------------------------------------------------------------------------\n set(SPDLOG_SRCS src/spdlog.cpp src/stdout_sinks.cpp src/color_sinks.cpp src/file_sinks.cpp src/async.cpp src/cfg.cpp)\n \n-if (NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+if(NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n     list(APPEND SPDLOG_SRCS src/bundled_fmtlib_format.cpp)\n-endif ()\n+endif()\n \n-if (SPDLOG_BUILD_SHARED OR BUILD_SHARED_LIBS)\n-    if (WIN32)\n+if(SPDLOG_BUILD_SHARED OR BUILD_SHARED_LIBS)\n+    if(WIN32)\n         configure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/version.rc.in ${CMAKE_CURRENT_BINARY_DIR}/version.rc @ONLY)\n         list(APPEND SPDLOG_SRCS ${CMAKE_CURRENT_BINARY_DIR}/version.rc)\n-    endif ()\n+    endif()\n     add_library(spdlog SHARED ${SPDLOG_SRCS} ${SPDLOG_ALL_HEADERS})\n     target_compile_definitions(spdlog PUBLIC SPDLOG_SHARED_LIB)\n-    if (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n+    if(CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n         target_compile_options(spdlog PUBLIC $<$<AND:$<CXX_COMPILER_ID:MSVC>,$<NOT:$<COMPILE_LANGUAGE:CUDA>>>:/wd4251\n-                /wd4275>)\n-    endif ()\n-    if (NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+                                             /wd4275>)\n+    endif()\n+    if(NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n         target_compile_definitions(spdlog PRIVATE FMT_LIB_EXPORT PUBLIC FMT_SHARED)\n-    endif ()\n-else ()\n+    endif()\n+else()\n     add_library(spdlog STATIC ${SPDLOG_SRCS} ${SPDLOG_ALL_HEADERS})\n-endif ()\n+endif()\n \n add_library(spdlog::spdlog ALIAS spdlog)\n \n set(SPDLOG_INCLUDES_LEVEL \"\")\n-if (SPDLOG_SYSTEM_INCLUDES)\n+if(SPDLOG_SYSTEM_INCLUDES)\n     set(SPDLOG_INCLUDES_LEVEL \"SYSTEM\")\n-endif ()\n+endif()\n \n target_compile_definitions(spdlog PUBLIC SPDLOG_COMPILED_LIB)\n target_include_directories(spdlog ${SPDLOG_INCLUDES_LEVEL} PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>\"\n-        \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n+                                                                  \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n target_link_libraries(spdlog PUBLIC Threads::Threads)\n spdlog_enable_warnings(spdlog)\n \n set_target_properties(spdlog PROPERTIES VERSION ${SPDLOG_VERSION} SOVERSION\n-        ${SPDLOG_VERSION_MAJOR}.${SPDLOG_VERSION_MINOR})\n+                                                                  ${SPDLOG_VERSION_MAJOR}.${SPDLOG_VERSION_MINOR})\n set_target_properties(spdlog PROPERTIES DEBUG_POSTFIX d)\n \n-if (COMMAND target_precompile_headers AND SPDLOG_ENABLE_PCH)\n+if(COMMAND target_precompile_headers AND SPDLOG_ENABLE_PCH)\n     configure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/pch.h.in ${PROJECT_BINARY_DIR}/spdlog_pch.h @ONLY)\n     target_precompile_headers(spdlog PRIVATE ${PROJECT_BINARY_DIR}/spdlog_pch.h)\n-endif ()\n+endif()\n \n # sanitizer support\n-if (SPDLOG_SANITIZE_ADDRESS)\n+if(SPDLOG_SANITIZE_ADDRESS)\n     spdlog_enable_addr_sanitizer(spdlog)\n-elseif (SPDLOG_SANITIZE_THREAD)\n+elseif(SPDLOG_SANITIZE_THREAD)\n     spdlog_enable_thread_sanitizer(spdlog)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Header only version\n@@ -213,133 +212,134 @@ add_library(spdlog_header_only INTERFACE)\n add_library(spdlog::spdlog_header_only ALIAS spdlog_header_only)\n \n target_include_directories(\n-        spdlog_header_only ${SPDLOG_INCLUDES_LEVEL} INTERFACE \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>\"\n-        \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n+    spdlog_header_only ${SPDLOG_INCLUDES_LEVEL} INTERFACE \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>\"\n+                                                          \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n target_link_libraries(spdlog_header_only INTERFACE Threads::Threads)\n \n # ---------------------------------------------------------------------------------------\n # Use fmt package if using external fmt\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_FMT_EXTERNAL OR SPDLOG_FMT_EXTERNAL_HO)\n-    if (NOT TARGET fmt::fmt)\n+if(SPDLOG_FMT_EXTERNAL OR SPDLOG_FMT_EXTERNAL_HO)\n+    if(NOT TARGET fmt::fmt)\n         find_package(fmt CONFIG REQUIRED)\n-    endif ()\n+    endif()\n     target_compile_definitions(spdlog PUBLIC SPDLOG_FMT_EXTERNAL)\n     target_compile_definitions(spdlog_header_only INTERFACE SPDLOG_FMT_EXTERNAL)\n \n     # use external fmt-header-only\n-    if (SPDLOG_FMT_EXTERNAL_HO)\n+    if(SPDLOG_FMT_EXTERNAL_HO)\n         target_link_libraries(spdlog PUBLIC fmt::fmt-header-only)\n         target_link_libraries(spdlog_header_only INTERFACE fmt::fmt-header-only)\n-    else () # use external compile fmt\n+    else() # use external compile fmt\n         target_link_libraries(spdlog PUBLIC fmt::fmt)\n         target_link_libraries(spdlog_header_only INTERFACE fmt::fmt)\n-    endif ()\n+    endif()\n \n     set(PKG_CONFIG_REQUIRES fmt) # add dependency to pkg-config\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Check if fwrite_unlocked/_fwrite_nolock is available\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_FWRITE_UNLOCKED)\n+if(SPDLOG_FWRITE_UNLOCKED)\n     include(CheckSymbolExists)\n-    if (WIN32)\n+    if(WIN32)\n         check_symbol_exists(_fwrite_nolock \"stdio.h\" HAVE_FWRITE_UNLOCKED)\n-    else ()\n+    else()\n         check_symbol_exists(fwrite_unlocked \"stdio.h\" HAVE_FWRITE_UNLOCKED)\n-    endif ()\n-    if (HAVE_FWRITE_UNLOCKED)\n+    endif()\n+    if(HAVE_FWRITE_UNLOCKED)\n         target_compile_definitions(spdlog PRIVATE SPDLOG_FWRITE_UNLOCKED)\n         target_compile_definitions(spdlog_header_only INTERFACE SPDLOG_FWRITE_UNLOCKED)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Add required libraries for Android CMake build\n # ---------------------------------------------------------------------------------------\n-if (ANDROID)\n+if(ANDROID)\n     target_link_libraries(spdlog PUBLIC log)\n     target_link_libraries(spdlog_header_only INTERFACE log)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Misc definitions according to tweak options\n # ---------------------------------------------------------------------------------------\n set(SPDLOG_WCHAR_TO_UTF8_SUPPORT ${SPDLOG_WCHAR_SUPPORT})\n set(SPDLOG_UTF8_TO_WCHAR_CONSOLE ${SPDLOG_WCHAR_CONSOLE})\n-foreach (\n-        SPDLOG_OPTION\n-        SPDLOG_WCHAR_TO_UTF8_SUPPORT\n-        SPDLOG_UTF8_TO_WCHAR_CONSOLE\n-        SPDLOG_WCHAR_FILENAMES\n-        SPDLOG_NO_EXCEPTIONS\n-        SPDLOG_CLOCK_COARSE\n-        SPDLOG_PREVENT_CHILD_FD\n-        SPDLOG_NO_THREAD_ID\n-        SPDLOG_NO_TLS\n-        SPDLOG_NO_ATOMIC_LEVELS\n-        SPDLOG_DISABLE_DEFAULT_LOGGER\n-        SPDLOG_USE_STD_FORMAT)\n-    if (${SPDLOG_OPTION})\n+foreach(\n+    SPDLOG_OPTION\n+    SPDLOG_WCHAR_TO_UTF8_SUPPORT\n+    SPDLOG_UTF8_TO_WCHAR_CONSOLE\n+    SPDLOG_WCHAR_FILENAMES\n+    SPDLOG_NO_EXCEPTIONS\n+    SPDLOG_CLOCK_COARSE\n+    SPDLOG_PREVENT_CHILD_FD\n+    SPDLOG_NO_THREAD_ID\n+    SPDLOG_NO_TLS\n+    SPDLOG_NO_ATOMIC_LEVELS\n+    SPDLOG_DISABLE_DEFAULT_LOGGER\n+    SPDLOG_USE_STD_FORMAT)\n+    if(${SPDLOG_OPTION})\n         target_compile_definitions(spdlog PUBLIC ${SPDLOG_OPTION})\n         target_compile_definitions(spdlog_header_only INTERFACE ${SPDLOG_OPTION})\n-    endif ()\n-endforeach ()\n+    endif()\n+endforeach()\n \n-if (MSVC)\n+if(MSVC)\n     target_compile_options(spdlog PRIVATE \"/Zc:__cplusplus\")\n     target_compile_options(spdlog_header_only INTERFACE \"/Zc:__cplusplus\")\n-    if (SPDLOG_MSVC_UTF8)\n-        # fmtlib requires the /utf-8 flag when building with msvc.\n-        # see https://github.com/fmtlib/fmt/pull/4159 on the purpose of the additional\n+    if(SPDLOG_MSVC_UTF8)\n+        # fmtlib requires the /utf-8 flag when building with msvc. see https://github.com/fmtlib/fmt/pull/4159 on the\n+        # purpose of the additional\n         # \"$<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>\"\n         target_compile_options(spdlog PUBLIC $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)\n-        target_compile_options(spdlog_header_only INTERFACE $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)\n-    endif ()\n-endif ()\n+        target_compile_options(spdlog_header_only\n+                               INTERFACE $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)\n+    endif()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # If exceptions are disabled, disable them in the bundled fmt as well\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_NO_EXCEPTIONS)\n-    if (NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+if(SPDLOG_NO_EXCEPTIONS)\n+    if(NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n         target_compile_definitions(spdlog PUBLIC FMT_USE_EXCEPTIONS=0)\n-    endif ()\n-    if (NOT MSVC)\n+    endif()\n+    if(NOT MSVC)\n         target_compile_options(spdlog PRIVATE -fno-exceptions)\n-    else ()\n+    else()\n         target_compile_options(spdlog PRIVATE /EHs-c-)\n         target_compile_definitions(spdlog PRIVATE _HAS_EXCEPTIONS=0)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n # ---------------------------------------------------------------------------------------\n # Build binaries\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_BUILD_EXAMPLE OR SPDLOG_BUILD_EXAMPLE_HO OR SPDLOG_BUILD_ALL)\n+if(SPDLOG_BUILD_EXAMPLE OR SPDLOG_BUILD_EXAMPLE_HO OR SPDLOG_BUILD_ALL)\n     message(STATUS \"Generating example(s)\")\n     add_subdirectory(example)\n     spdlog_enable_warnings(example)\n-    if (SPDLOG_BUILD_EXAMPLE_HO)\n+    if(SPDLOG_BUILD_EXAMPLE_HO)\n         spdlog_enable_warnings(example_header_only)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n \n-if (SPDLOG_BUILD_TESTS OR SPDLOG_BUILD_TESTS_HO OR SPDLOG_BUILD_ALL)\n+if(SPDLOG_BUILD_TESTS OR SPDLOG_BUILD_TESTS_HO OR SPDLOG_BUILD_ALL)\n     message(STATUS \"Generating tests\")\n     enable_testing()\n     add_subdirectory(tests)\n-endif ()\n+endif()\n \n-if (SPDLOG_BUILD_BENCH OR SPDLOG_BUILD_ALL)\n+if(SPDLOG_BUILD_BENCH OR SPDLOG_BUILD_ALL)\n     message(STATUS \"Generating benchmarks\")\n     add_subdirectory(bench)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Install\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_INSTALL)\n+if(SPDLOG_INSTALL)\n     message(STATUS \"Generating install\")\n     set(project_config_in \"${CMAKE_CURRENT_LIST_DIR}/cmake/spdlogConfig.cmake.in\")\n     set(project_config_out \"${CMAKE_CURRENT_BINARY_DIR}/spdlogConfig.cmake\")\n@@ -354,30 +354,30 @@ if (SPDLOG_INSTALL)\n     # ---------------------------------------------------------------------------------------\n     install(DIRECTORY include/ DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\" PATTERN \"fmt/bundled\" EXCLUDE)\n     install(\n-            TARGETS spdlog spdlog_header_only\n-            EXPORT spdlog\n-            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n+        TARGETS spdlog spdlog_header_only\n+        EXPORT spdlog\n+        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n+        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n+        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n \n-    if (NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+    if(NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n         install(DIRECTORY include/${PROJECT_NAME}/fmt/bundled/\n                 DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME}/fmt/bundled/\")\n-    endif ()\n+    endif()\n \n     # ---------------------------------------------------------------------------------------\n     # Install pkg-config file\n     # ---------------------------------------------------------------------------------------\n-    if (IS_ABSOLUTE \"${CMAKE_INSTALL_INCLUDEDIR}\")\n+    if(IS_ABSOLUTE \"${CMAKE_INSTALL_INCLUDEDIR}\")\n         set(PKG_CONFIG_INCLUDEDIR \"${CMAKE_INSTALL_INCLUDEDIR}\")\n-    else ()\n+    else()\n         set(PKG_CONFIG_INCLUDEDIR \"\\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}\")\n-    endif ()\n-    if (IS_ABSOLUTE \"${CMAKE_INSTALL_LIBDIR}\")\n+    endif()\n+    if(IS_ABSOLUTE \"${CMAKE_INSTALL_LIBDIR}\")\n         set(PKG_CONFIG_LIBDIR \"${CMAKE_INSTALL_LIBDIR}\")\n-    else ()\n+    else()\n         set(PKG_CONFIG_LIBDIR \"\\${exec_prefix}/${CMAKE_INSTALL_LIBDIR}\")\n-    endif ()\n+    endif()\n     get_target_property(PKG_CONFIG_DEFINES spdlog INTERFACE_COMPILE_DEFINITIONS)\n     string(REPLACE \";\" \" -D\" PKG_CONFIG_DEFINES \"${PKG_CONFIG_DEFINES}\")\n     string(CONCAT PKG_CONFIG_DEFINES \"-D\" \"${PKG_CONFIG_DEFINES}\")\n@@ -388,7 +388,7 @@ if (SPDLOG_INSTALL)\n     # Install CMake config files\n     # ---------------------------------------------------------------------------------------\n     export(TARGETS spdlog spdlog_header_only NAMESPACE spdlog::\n-            FILE \"${CMAKE_CURRENT_BINARY_DIR}/${config_targets_file}\")\n+           FILE \"${CMAKE_CURRENT_BINARY_DIR}/${config_targets_file}\")\n     install(EXPORT spdlog DESTINATION ${export_dest_dir} NAMESPACE spdlog:: FILE ${config_targets_file})\n \n     include(CMakePackageConfigHelpers)\n@@ -401,4 +401,4 @@ if (SPDLOG_INSTALL)\n     # Support creation of installable packages\n     # ---------------------------------------------------------------------------------------\n     include(cmake/spdlogCPack.cmake)\n-endif ()\n+endif()\ndiff --git a/example/example.cpp b/example/example.cpp\n--- a/example/example.cpp\n+++ b/example/example.cpp\n@@ -269,7 +269,7 @@ void multi_sink_example() {\n struct my_type {\n     int i = 0;\n     explicit my_type(int i)\n-        : i(i){}\n+        : i(i) {}\n };\n \n #ifndef SPDLOG_USE_STD_FORMAT  // when using fmtlib\n@@ -382,14 +382,14 @@ void replace_default_logger_example() {\n     spdlog::set_default_logger(old_logger);\n }\n \n-// Mapped Diagnostic Context (MDC) is a map that stores key-value pairs (string values) in thread local storage.\n-// Each thread maintains its own MDC, which loggers use to append diagnostic information to log outputs.\n-// Note: it is not supported in asynchronous mode due to its reliance on thread-local storage.\n+// Mapped Diagnostic Context (MDC) is a map that stores key-value pairs (string values) in thread\n+// local storage. Each thread maintains its own MDC, which loggers use to append diagnostic\n+// information to log outputs. Note: it is not supported in asynchronous mode due to its reliance on\n+// thread-local storage.\n \n #ifndef SPDLOG_NO_TLS\n     #include \"spdlog/mdc.h\"\n-void mdc_example()\n-{\n+void mdc_example() {\n     spdlog::mdc::put(\"key1\", \"value1\");\n     spdlog::mdc::put(\"key2\", \"value2\");\n     // if not using the default format, you can use the %& formatter to print mdc data as well\ndiff --git a/include/spdlog/async.h b/include/spdlog/async.h\n--- a/include/spdlog/async.h\n+++ b/include/spdlog/async.h\n@@ -89,8 +89,7 @@ inline void init_thread_pool(size_t q_size,\n }\n \n inline void init_thread_pool(size_t q_size, size_t thread_count) {\n-    init_thread_pool(\n-        q_size, thread_count, [] {}, [] {});\n+    init_thread_pool(q_size, thread_count, [] {}, [] {});\n }\n \n // get the global thread pool.\ndiff --git a/include/spdlog/async_logger-inl.h b/include/spdlog/async_logger-inl.h\n--- a/include/spdlog/async_logger-inl.h\n+++ b/include/spdlog/async_logger-inl.h\n@@ -33,7 +33,7 @@ SPDLOG_INLINE spdlog::async_logger::async_logger(std::string logger_name,\n // send the log message to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::sink_it_(const details::log_msg &msg){\n     SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n-        pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n+        pool_ptr -> post_log(shared_from_this(), msg, overflow_policy_);\n }\n else {\n     throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n@@ -45,7 +45,7 @@ SPDLOG_LOGGER_CATCH(msg.source)\n // send flush request to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::flush_(){\n     SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n-        pool_ptr->post_flush(shared_from_this(), overflow_policy_);\n+        pool_ptr -> post_flush(shared_from_this(), overflow_policy_);\n }\n else {\n     throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\ndiff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -364,7 +364,7 @@ SPDLOG_CONSTEXPR_FUNC spdlog::wstring_view_t to_string_view(spdlog::wstring_view\n }\n #endif\n \n-#if defined(SPDLOG_USE_STD_FORMAT) &&  __cpp_lib_format >= 202207L\n+#if defined(SPDLOG_USE_STD_FORMAT) && __cpp_lib_format >= 202207L\n template <typename T, typename... Args>\n SPDLOG_CONSTEXPR_FUNC std::basic_string_view<T> to_string_view(\n     std::basic_format_string<T, Args...> fmt) SPDLOG_NOEXCEPT {\ndiff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -265,10 +265,10 @@ SPDLOG_INLINE int utc_minutes_offset(const std::tm &tm) {\n     return offset;\n #else\n \n-    #if defined(sun) || defined(__sun) || defined(_AIX) || \\\n-        (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||  \\\n+    #if defined(sun) || defined(__sun) || defined(_AIX) ||                        \\\n+        (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||                         \\\n         (!defined(__APPLE__) && !defined(_BSD_SOURCE) && !defined(_GNU_SOURCE) && \\\n-            (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n+         (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n     // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris\n     struct helper {\n         static long int calculate_gmt_offset(const std::tm &localtm = details::os::localtime(),\n@@ -483,13 +483,12 @@ SPDLOG_INLINE void utf8_to_wstrbuf(string_view_t str, wmemory_buf_t &target) {\n     }\n \n     // find the size to allocate for the result buffer\n-    int result_size =\n-        ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, NULL, 0);\n+    int result_size = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, NULL, 0);\n \n     if (result_size > 0) {\n         target.resize(result_size);\n-        result_size = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, target.data(),\n-                                            result_size);\n+        result_size =\n+            ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, target.data(), result_size);\n         if (result_size > 0) {\n             assert(result_size == target.size());\n             return;\n@@ -593,13 +592,13 @@ SPDLOG_INLINE bool fsync(FILE *fp) {\n // Do non-locking fwrite if possible by the os or use the regular locking fwrite\n // Return true on success.\n SPDLOG_INLINE bool fwrite_bytes(const void *ptr, const size_t n_bytes, FILE *fp) {\n-    #if defined(_WIN32) && defined(SPDLOG_FWRITE_UNLOCKED)\n+#if defined(_WIN32) && defined(SPDLOG_FWRITE_UNLOCKED)\n     return _fwrite_nolock(ptr, 1, n_bytes, fp) == n_bytes;\n-    #elif defined(SPDLOG_FWRITE_UNLOCKED)\n+#elif defined(SPDLOG_FWRITE_UNLOCKED)\n     return ::fwrite_unlocked(ptr, 1, n_bytes, fp) == n_bytes;\n-    #else\n+#else\n     return std::fwrite(ptr, 1, n_bytes, fp) == n_bytes;\n-    #endif\n+#endif\n }\n \n }  // namespace os\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -38,8 +38,7 @@ SPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items,\n     : thread_pool(q_max_items, threads_n, on_thread_start, [] {}) {}\n \n SPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items, size_t threads_n)\n-    : thread_pool(\n-          q_max_items, threads_n, [] {}, [] {}) {}\n+    : thread_pool(q_max_items, threads_n, [] {}, [] {}) {}\n \n // message all threads to terminate gracefully join them\n SPDLOG_INLINE thread_pool::~thread_pool() {\ndiff --git a/include/spdlog/fmt/bin_to_hex.h b/include/spdlog/fmt/bin_to_hex.h\n--- a/include/spdlog/fmt/bin_to_hex.h\n+++ b/include/spdlog/fmt/bin_to_hex.h\n@@ -142,8 +142,8 @@ struct formatter<spdlog::details::dump_info<T>, char> {\n \n     // format the given bytes range as hex\n     template <typename FormatContext, typename Container>\n-    auto format(const spdlog::details::dump_info<Container> &the_range, FormatContext &ctx) const\n-        -> decltype(ctx.out()) {\n+    auto format(const spdlog::details::dump_info<Container> &the_range,\n+                FormatContext &ctx) const -> decltype(ctx.out()) {\n         SPDLOG_CONSTEXPR const char *hex_upper = \"0123456789ABCDEF\";\n         SPDLOG_CONSTEXPR const char *hex_lower = \"0123456789abcdef\";\n         const char *hex_chars = use_uppercase ? hex_upper : hex_lower;\ndiff --git a/include/spdlog/mdc.h b/include/spdlog/mdc.h\n--- a/include/spdlog/mdc.h\n+++ b/include/spdlog/mdc.h\n@@ -12,12 +12,14 @@\n \n #include <spdlog/common.h>\n \n-// MDC is a simple map of key->string values stored in thread local storage whose content will be printed by the loggers.\n-// Note: Not supported in async mode (thread local storage - so the async thread pool have different copy).\n+// MDC is a simple map of key->string values stored in thread local storage whose content will be\n+// printed by the loggers. Note: Not supported in async mode (thread local storage - so the async\n+// thread pool have different copy).\n //\n // Usage example:\n // spdlog::mdc::put(\"mdc_key_1\", \"mdc_value_1\");\n-// spdlog::info(\"Hello, {}\", \"World!\");  // => [2024-04-26 02:08:05.040] [info] [mdc_key_1:mdc_value_1] Hello, World!\n+// spdlog::info(\"Hello, {}\", \"World!\");  // => [2024-04-26 02:08:05.040] [info]\n+// [mdc_key_1:mdc_value_1] Hello, World!\n \n namespace spdlog {\n class SPDLOG_API mdc {\ndiff --git a/include/spdlog/sinks/ansicolor_sink-inl.h b/include/spdlog/sinks/ansicolor_sink-inl.h\n--- a/include/spdlog/sinks/ansicolor_sink-inl.h\n+++ b/include/spdlog/sinks/ansicolor_sink-inl.h\n@@ -111,7 +111,8 @@ SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_color_mode_(color_mode mode\n }\n \n template <typename ConsoleMutex>\n-SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_ccode_(const string_view_t &color_code) const {\n+SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_ccode_(\n+    const string_view_t &color_code) const {\n     details::os::fwrite_bytes(color_code.data(), color_code.size(), target_file_);\n }\n \ndiff --git a/include/spdlog/sinks/callback_sink.h b/include/spdlog/sinks/callback_sink.h\n--- a/include/spdlog/sinks/callback_sink.h\n+++ b/include/spdlog/sinks/callback_sink.h\n@@ -27,7 +27,7 @@ class callback_sink final : public base_sink<Mutex> {\n \n protected:\n     void sink_it_(const details::log_msg &msg) override { callback_(msg); }\n-    void flush_() override{}\n+    void flush_() override {}\n \n private:\n     custom_log_callback callback_;\ndiff --git a/include/spdlog/sinks/rotating_file_sink-inl.h b/include/spdlog/sinks/rotating_file_sink-inl.h\n--- a/include/spdlog/sinks/rotating_file_sink-inl.h\n+++ b/include/spdlog/sinks/rotating_file_sink-inl.h\n@@ -14,7 +14,6 @@\n #include <spdlog/fmt/fmt.h>\n \n #include <cerrno>\n-#include <chrono>\n #include <ctime>\n #include <mutex>\n #include <string>\n@@ -38,8 +37,8 @@ SPDLOG_INLINE rotating_file_sink<Mutex>::rotating_file_sink(\n         throw_spdlog_ex(\"rotating sink constructor: max_size arg cannot be zero\");\n     }\n \n-    if (max_files > 200000) {\n-        throw_spdlog_ex(\"rotating sink constructor: max_files arg cannot exceed 200000\");\n+    if (max_files > MaxFiles) {\n+        throw_spdlog_ex(\"rotating sink constructor: max_files arg cannot exceed MaxFiles\");\n     }\n     file_helper_.open(calc_filename(base_filename_, 0));\n     current_size_ = file_helper_.size();  // expensive. called only once\n@@ -54,11 +53,12 @@ SPDLOG_INLINE rotating_file_sink<Mutex>::rotating_file_sink(\n template <typename Mutex>\n SPDLOG_INLINE filename_t rotating_file_sink<Mutex>::calc_filename(const filename_t &filename,\n                                                                   std::size_t index) {\n-    if (index == 0u) {\n+    if (index == 0U) {\n         return filename;\n     }\n \n-    filename_t basename, ext;\n+    filename_t basename;\n+    filename_t ext;\n     std::tie(basename, ext) = details::file_helper::split_by_extension(filename);\n     return fmt_lib::format(SPDLOG_FMT_STRING(SPDLOG_FILENAME_T(\"{}.{}{}\")), basename, index, ext);\n }\n@@ -74,6 +74,35 @@ SPDLOG_INLINE void rotating_file_sink<Mutex>::rotate_now() {\n     std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n     rotate_();\n }\n+template <typename Mutex>\n+SPDLOG_INLINE void rotating_file_sink<Mutex>::set_max_size(std::size_t max_size) {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    if (max_size == 0) {\n+        throw_spdlog_ex(\"rotating sink set_max_size: max_size arg cannot be zero\");\n+    }\n+    max_size_ = max_size;\n+}\n+\n+template <typename Mutex>\n+SPDLOG_INLINE std::size_t rotating_file_sink<Mutex>::get_max_size() {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    return max_size_;\n+}\n+\n+template <typename Mutex>\n+SPDLOG_INLINE void rotating_file_sink<Mutex>::set_max_files(std::size_t max_files) {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    if (max_files > MaxFiles) {\n+        throw_spdlog_ex(\"rotating sink set_max_files: max_files arg cannot exceed 200000\");\n+    }\n+    max_files_ = max_files;\n+}\n+\n+template <typename Mutex>\n+std::size_t rotating_file_sink<Mutex>::get_max_files() {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    return max_files_;\n+}\n \n template <typename Mutex>\n SPDLOG_INLINE void rotating_file_sink<Mutex>::sink_it_(const details::log_msg &msg) {\ndiff --git a/include/spdlog/sinks/rotating_file_sink.h b/include/spdlog/sinks/rotating_file_sink.h\n--- a/include/spdlog/sinks/rotating_file_sink.h\n+++ b/include/spdlog/sinks/rotating_file_sink.h\n@@ -8,7 +8,6 @@\n #include <spdlog/details/synchronous_factory.h>\n #include <spdlog/sinks/base_sink.h>\n \n-#include <chrono>\n #include <mutex>\n #include <string>\n \n@@ -21,6 +20,7 @@ namespace sinks {\n template <typename Mutex>\n class rotating_file_sink final : public base_sink<Mutex> {\n public:\n+    static constexpr size_t MaxFiles = 200000;\n     rotating_file_sink(filename_t base_filename,\n                        std::size_t max_size,\n                        std::size_t max_files,\n@@ -29,6 +29,10 @@ class rotating_file_sink final : public base_sink<Mutex> {\n     static filename_t calc_filename(const filename_t &filename, std::size_t index);\n     filename_t filename();\n     void rotate_now();\n+    void set_max_size(std::size_t max_size);\n+    std::size_t get_max_size();\n+    void set_max_files(std::size_t max_files);\n+    std::size_t get_max_files();\n \n protected:\n     void sink_it_(const details::log_msg &msg) override;\n@@ -42,7 +46,7 @@ class rotating_file_sink final : public base_sink<Mutex> {\n     // log.3.txt -> delete\n     void rotate_();\n \n-    // delete the target if exists, and rename the src file  to target\n+    // delete the target if exists, and rename the src file to target\n     // return true on success, false otherwise.\n     bool rename_file_(const filename_t &src_filename, const filename_t &target_filename);\n \n@@ -61,25 +65,24 @@ using rotating_file_sink_st = rotating_file_sink<details::null_mutex>;\n //\n // factory functions\n //\n-\n template <typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> rotating_logger_mt(const std::string &logger_name,\n-                                                  const filename_t &filename,\n-                                                  size_t max_file_size,\n-                                                  size_t max_files,\n-                                                  bool rotate_on_open = false,\n-                                                  const file_event_handlers &event_handlers = {}) {\n+std::shared_ptr<logger> rotating_logger_mt(const std::string &logger_name,\n+                                           const filename_t &filename,\n+                                           size_t max_file_size,\n+                                           size_t max_files,\n+                                           bool rotate_on_open = false,\n+                                           const file_event_handlers &event_handlers = {}) {\n     return Factory::template create<sinks::rotating_file_sink_mt>(\n         logger_name, filename, max_file_size, max_files, rotate_on_open, event_handlers);\n }\n \n template <typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> rotating_logger_st(const std::string &logger_name,\n-                                                  const filename_t &filename,\n-                                                  size_t max_file_size,\n-                                                  size_t max_files,\n-                                                  bool rotate_on_open = false,\n-                                                  const file_event_handlers &event_handlers = {}) {\n+std::shared_ptr<logger> rotating_logger_st(const std::string &logger_name,\n+                                           const filename_t &filename,\n+                                           size_t max_file_size,\n+                                           size_t max_files,\n+                                           bool rotate_on_open = false,\n+                                           const file_event_handlers &event_handlers = {}) {\n     return Factory::template create<sinks::rotating_file_sink_st>(\n         logger_name, filename, max_file_size, max_files, rotate_on_open, event_handlers);\n }\ndiff --git a/include/spdlog/sinks/wincolor_sink-inl.h b/include/spdlog/sinks/wincolor_sink-inl.h\n--- a/include/spdlog/sinks/wincolor_sink-inl.h\n+++ b/include/spdlog/sinks/wincolor_sink-inl.h\n@@ -137,10 +137,10 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::print_range_(const memory_buf_t\n #if defined(SPDLOG_UTF8_TO_WCHAR_CONSOLE)\n         wmemory_buf_t wformatted;\n         details::os::utf8_to_wstrbuf(string_view_t(formatted.data() + start, end - start),\n-            wformatted);\n+                                     wformatted);\n         auto size = static_cast<DWORD>(wformatted.size());\n         auto ignored = ::WriteConsoleW(static_cast<HANDLE>(out_handle_), wformatted.data(), size,\n-            nullptr, nullptr);\n+                                       nullptr, nullptr);\n #else\n         auto size = static_cast<DWORD>(end - start);\n         auto ignored = ::WriteConsoleA(static_cast<HANDLE>(out_handle_), formatted.data() + start,\ndiff --git a/include/spdlog/tweakme.h b/include/spdlog/tweakme.h\n--- a/include/spdlog/tweakme.h\n+++ b/include/spdlog/tweakme.h\n@@ -109,8 +109,8 @@\n //\n // #include <string_view>\n // using namespace std::string_view_literals;\n-// #define SPDLOG_LEVEL_NAMES { \"MY TRACE\"sv, \"MY DEBUG\"sv, \"MY INFO\"sv, \"MY WARNING\"sv, \"MY ERROR\"sv, \"MY\n-// CRITICAL\"sv, \"OFF\"sv }\n+// #define SPDLOG_LEVEL_NAMES { \"MY TRACE\"sv, \"MY DEBUG\"sv, \"MY INFO\"sv, \"MY WARNING\"sv, \"MY\n+// ERROR\"sv, \"MY CRITICAL\"sv, \"OFF\"sv }\n ///////////////////////////////////////////////////////////////////////////////\n \n ///////////////////////////////////////////////////////////////////////////////\ndiff --git a/src/bundled_fmtlib_format.cpp b/src/bundled_fmtlib_format.cpp\n--- a/src/bundled_fmtlib_format.cpp\n+++ b/src/bundled_fmtlib_format.cpp\n@@ -13,34 +13,32 @@\n FMT_BEGIN_NAMESPACE\n namespace detail {\n \n-template FMT_API auto dragonbox::to_decimal(float x) noexcept\n-    -> dragonbox::decimal_fp<float>;\n-template FMT_API auto dragonbox::to_decimal(double x) noexcept\n-    -> dragonbox::decimal_fp<double>;\n+template FMT_API auto dragonbox::to_decimal(float x) noexcept -> dragonbox::decimal_fp<float>;\n+template FMT_API auto dragonbox::to_decimal(double x) noexcept -> dragonbox::decimal_fp<double>;\n \n-#if FMT_USE_LOCALE\n+    #if FMT_USE_LOCALE\n // DEPRECATED! locale_ref in the detail namespace\n template FMT_API locale_ref::locale_ref(const std::locale& loc);\n template FMT_API auto locale_ref::get<std::locale>() const -> std::locale;\n-#endif\n+    #endif\n \n // Explicit instantiations for char.\n \n-template FMT_API auto thousands_sep_impl(locale_ref)\n-    -> thousands_sep_result<char>;\n+template FMT_API auto thousands_sep_impl(locale_ref) -> thousands_sep_result<char>;\n template FMT_API auto decimal_point_impl(locale_ref) -> char;\n \n // DEPRECATED!\n template FMT_API void buffer<char>::append(const char*, const char*);\n \n // DEPRECATED!\n-template FMT_API void vformat_to(buffer<char>&, string_view,\n-                                 typename vformat_args<>::type, locale_ref);\n+template FMT_API void vformat_to(buffer<char>&,\n+                                 string_view,\n+                                 typename vformat_args<>::type,\n+                                 locale_ref);\n \n // Explicit instantiations for wchar_t.\n \n-template FMT_API auto thousands_sep_impl(locale_ref)\n-    -> thousands_sep_result<wchar_t>;\n+template FMT_API auto thousands_sep_impl(locale_ref) -> thousands_sep_result<wchar_t>;\n template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;\n \n template FMT_API void buffer<wchar_t>::append(const wchar_t*, const wchar_t*);\n@@ -48,5 +46,4 @@ template FMT_API void buffer<wchar_t>::append(const wchar_t*, const wchar_t*);\n }  // namespace detail\n FMT_END_NAMESPACE\n \n-\n #endif  // !SPDLOG_FMT_EXTERNAL\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -19,9 +19,9 @@ if(Catch2_FOUND)\n else()\n     message(STATUS \"Bundled version of Catch will be downloaded and used.\")\n     include(FetchContent)\n-    FetchContent_Declare(Catch2\n-            GIT_REPOSITORY https://github.com/catchorg/Catch2.git\n-            GIT_TAG 53d0d913a422d356b23dd927547febdf69ee9081 # v3.5.0\n+    FetchContent_Declare(\n+        Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2.git\n+        GIT_TAG 53d0d913a422d356b23dd927547febdf69ee9081 # v3.5.0\n     )\n     FetchContent_MakeAvailable(Catch2)\n endif()\n@@ -71,9 +71,9 @@ function(spdlog_prepare_test test_target spdlog_lib)\n     target_link_libraries(${test_target} PRIVATE Catch2::Catch2WithMain)\n     if(SPDLOG_SANITIZE_ADDRESS)\n         spdlog_enable_addr_sanitizer(${test_target})\n-    elseif (SPDLOG_SANITIZE_THREAD)\n+    elseif(SPDLOG_SANITIZE_THREAD)\n         spdlog_enable_thread_sanitizer(${test_target})\n-    endif ()\n+    endif()\n     add_test(NAME ${test_target} COMMAND ${test_target})\n     set_tests_properties(${test_target} PROPERTIES RUN_SERIAL ON)\n endfunction()\ndiff --git a/tests/test_custom_callbacks.cpp b/tests/test_custom_callbacks.cpp\n--- a/tests/test_custom_callbacks.cpp\n+++ b/tests/test_custom_callbacks.cpp\n@@ -16,7 +16,8 @@ TEST_CASE(\"custom_callback_logger\", \"[custom_callback_logger]\") {\n             spdlog::memory_buf_t formatted;\n             formatter.format(msg, formatted);\n             auto eol_len = strlen(spdlog::details::os::default_eol);\n-            using diff_t = typename std::iterator_traits<decltype(formatted.end())>::difference_type; \n+            using diff_t =\n+                typename std::iterator_traits<decltype(formatted.end())>::difference_type;\n             lines.emplace_back(formatted.begin(), formatted.end() - static_cast<diff_t>(eol_len));\n         });\n     std::shared_ptr<spdlog::sinks::test_sink_st> test_sink(new spdlog::sinks::test_sink_st);\ndiff --git a/tests/test_daily_logger.cpp b/tests/test_daily_logger.cpp\n--- a/tests/test_daily_logger.cpp\n+++ b/tests/test_daily_logger.cpp\n@@ -46,10 +46,8 @@ TEST_CASE(\"daily_logger with dateonly calculator\", \"[daily_logger]\") {\n \n struct custom_daily_file_name_calculator {\n     static spdlog::filename_t calc_filename(const spdlog::filename_t &basename, const tm &now_tm) {\n-        \n-        return spdlog::fmt_lib::format(SPDLOG_FILENAME_T(\"{}{:04d}{:02d}{:02d}\"),\n-                                   basename, now_tm.tm_year + 1900, now_tm.tm_mon + 1,\n-                                   now_tm.tm_mday);        \n+        return spdlog::fmt_lib::format(SPDLOG_FILENAME_T(\"{}{:04d}{:02d}{:02d}\"), basename,\n+                                       now_tm.tm_year + 1900, now_tm.tm_mon + 1, now_tm.tm_mday);\n     }\n };\n \ndiff --git a/tests/test_file_logging.cpp b/tests/test_file_logging.cpp\n--- a/tests/test_file_logging.cpp\n+++ b/tests/test_file_logging.cpp\n@@ -56,7 +56,7 @@ TEST_CASE(\"simple_file_logger\", \"[truncate]\") {\n     logger->info(\"Test message {}\", 2.71);\n     logger->flush();\n     REQUIRE(count_lines(SIMPLE_LOG) == 2);\n-    \n+\n     sink->truncate();\n     REQUIRE(count_lines(SIMPLE_LOG) == 0);\n \n@@ -94,14 +94,11 @@ TEST_CASE(\"rotating_file_logger2\", \"[rotating_logger]\") {\n         // next logger can rename the first output file.\n         spdlog::drop(logger->name());\n     }\n-\n     auto logger = spdlog::rotating_logger_mt(\"logger\", basename, max_size, 2, true);\n     for (int i = 0; i < 10; ++i) {\n         logger->info(\"Test message {}\", i);\n     }\n-\n     logger->flush();\n-\n     require_message_count(ROTATING_LOG, 10);\n \n     for (int i = 0; i < 1000; i++) {\n@@ -141,3 +138,50 @@ TEST_CASE(\"rotating_file_logger4\", \"[rotating_logger]\") {\n     REQUIRE(get_filesize(ROTATING_LOG) > 0);\n     REQUIRE(get_filesize(ROTATING_LOG \".1\") > 0);\n }\n+\n+// test changing the max size of the rotating file sink\n+TEST_CASE(\"rotating_file_logger5\", \"[rotating_logger]\") {\n+    prepare_logdir();\n+    size_t max_size = 5 * 1024;\n+    size_t max_files = 2;\n+    spdlog::filename_t basename = SPDLOG_FILENAME_T(ROTATING_LOG);\n+    auto sink =\n+        std::make_shared<spdlog::sinks::rotating_file_sink_st>(basename, max_size, max_files);\n+    auto logger = std::make_shared<spdlog::logger>(\"rotating_sink_logger\", sink);\n+    logger->set_pattern(\"%v\");\n+\n+    REQUIRE(sink->get_max_size() == max_size);\n+    REQUIRE(sink->get_max_files() == max_files);\n+    max_size = 7 * 1024;\n+    max_files = 3;\n+\n+    sink->set_max_size(max_size);\n+    sink->set_max_files(max_files);\n+    REQUIRE(sink->get_max_size() == max_size);\n+    REQUIRE(sink->get_max_files() == max_files);\n+\n+    const auto message = std::string(200, 'x');\n+    assert(message.size() < max_size);\n+    const auto n_messages = max_files * max_size / message.size();\n+    for (size_t i = 0; i < n_messages; ++i) {\n+        logger->info(message);\n+    }\n+    logger.reset();  // force flush and close the file\n+\n+    // validate that the files were rotated correctly with the new max size and max files\n+    for (size_t i = 0; i <= max_files; i++) {\n+        // calc filenames\n+        // e.g. rotating_log, rotating_log.0 rotating_log.1, rotating_log.2, etc.\n+        std::ostringstream oss;\n+        oss << ROTATING_LOG;\n+        if (i > 0) {\n+            oss << '.' << i;\n+        }\n+        const auto filename = oss.str();\n+        const auto filesize = get_filesize(filename);\n+        REQUIRE(filesize <= max_size);\n+        if (i > 0) {\n+            REQUIRE(filesize >= max_size - message.size() - 2);\n+        }\n+    }\n+}\ndiff --git a/tests/test_misc.cpp b/tests/test_misc.cpp\n--- a/tests/test_misc.cpp\n+++ b/tests/test_misc.cpp\n@@ -1,12 +1,12 @@\n-#ifdef _WIN32 // to prevent fopen warning on windows\n-#define _CRT_SECURE_NO_WARNINGS\n+#ifdef _WIN32  // to prevent fopen warning on windows\n+    #define _CRT_SECURE_NO_WARNINGS\n #endif\n \n #include \"includes.h\"\n #include \"test_sink.h\"\n \n template <class T>\n-std::string log_info(const T &what, spdlog::level::level_enum logger_level = spdlog::level::info) {\n+std::string log_info(const T& what, spdlog::level::level_enum logger_level = spdlog::level::info) {\n     std::ostringstream oss;\n     auto oss_sink = std::make_shared<spdlog::sinks::ostream_sink_mt>(oss);\n \n@@ -182,17 +182,19 @@ TEST_CASE(\"utf8 to utf16 conversion using windows api\", \"[windows utf]\") {\n     spdlog::details::os::utf8_to_wstrbuf(\"abc\", buffer);\n     REQUIRE(std::wstring(buffer.data(), buffer.size()) == std::wstring(L\"abc\"));\n \n-    spdlog::details::os::utf8_to_wstrbuf(\"\\xc3\\x28\", buffer); // Invalid UTF-8 sequence.\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xc3\\x28\", buffer);  // Invalid UTF-8 sequence.\n     REQUIRE(std::wstring(buffer.data(), buffer.size()) == std::wstring(L\"\\xfffd(\"));\n \n-    spdlog::details::os::utf8_to_wstrbuf(\"\\xe3\\x81\\xad\\xe3\\x81\\x93\", buffer); // \"Neko\" in hiragana.\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xe3\\x81\\xad\\xe3\\x81\\x93\",\n+                                         buffer);  // \"Neko\" in hiragana.\n     REQUIRE(std::wstring(buffer.data(), buffer.size()) == std::wstring(L\"\\x306d\\x3053\"));\n }\n #endif\n \n struct auto_closer {\n     FILE* fp = nullptr;\n-    explicit auto_closer(FILE* f) : fp(f) {}\n+    explicit auto_closer(FILE* f)\n+        : fp(f) {}\n     auto_closer(const auto_closer&) = delete;\n     auto_closer& operator=(const auto_closer&) = delete;\n     ~auto_closer() {\n@@ -201,10 +203,10 @@ struct auto_closer {\n };\n \n TEST_CASE(\"os::fwrite_bytes\", \"[os]\") {\n-    using spdlog::details::os::fwrite_bytes;\n     using spdlog::details::os::create_dir;\n+    using spdlog::details::os::fwrite_bytes;\n     const char* filename = \"log_tests/test_fwrite_bytes.txt\";\n-    const char *msg = \"hello\";\n+    const char* msg = \"hello\";\n     prepare_logdir();\n     REQUIRE(create_dir(SPDLOG_FILENAME_T(\"log_tests\")) == true);\n     {\ndiff --git a/tests/test_pattern_formatter.cpp b/tests/test_pattern_formatter.cpp\n--- a/tests/test_pattern_formatter.cpp\n+++ b/tests/test_pattern_formatter.cpp\n@@ -23,7 +23,9 @@ static std::string log_to_str(const std::string &msg, const Args &...args) {\n \n // log to str and return it with time\n template <typename... Args>\n-static std::string log_to_str_with_time(spdlog::log_clock::time_point log_time, const std::string &msg, const Args &...args) {\n+static std::string log_to_str_with_time(spdlog::log_clock::time_point log_time,\n+                                        const std::string &msg,\n+                                        const Args &...args) {\n     std::ostringstream oss;\n     auto oss_sink = std::make_shared<spdlog::sinks::ostream_sink_mt>(oss);\n     spdlog::logger oss_logger(\"pattern_tester\", oss_sink);\n@@ -80,8 +82,8 @@ TEST_CASE(\"GMT offset \", \"[pattern_formatter]\") {\n     const auto now = std::chrono::system_clock::now();\n     const auto yesterday = now - 24h;\n \n-    REQUIRE(log_to_str_with_time(yesterday, \"Some message\", \"%z\", spdlog::pattern_time_type::utc, \"\\n\") ==\n-            \"+00:00\\n\");\n+    REQUIRE(log_to_str_with_time(yesterday, \"Some message\", \"%z\", spdlog::pattern_time_type::utc,\n+                                 \"\\n\") == \"+00:00\\n\");\n }\n \n TEST_CASE(\"color range test1\", \"[pattern_formatter]\") {\ndiff --git a/tests/test_sink.h b/tests/test_sink.h\n--- a/tests/test_sink.h\n+++ b/tests/test_sink.h\n@@ -47,7 +47,7 @@ class test_sink : public base_sink<Mutex> {\n         base_sink<Mutex>::formatter_->format(msg, formatted);\n         // save the line without the eol\n         auto eol_len = strlen(details::os::default_eol);\n-        using diff_t = typename std::iterator_traits<decltype(formatted.end())>::difference_type; \n+        using diff_t = typename std::iterator_traits<decltype(formatted.end())>::difference_type;\n         if (lines_.size() < lines_to_save) {\n             lines_.emplace_back(formatted.begin(), formatted.end() - static_cast<diff_t>(eol_len));\n         }\ndiff --git a/tests/utils.cpp b/tests/utils.cpp\n--- a/tests/utils.cpp\n+++ b/tests/utils.cpp\n@@ -50,9 +50,8 @@ void require_message_count(const std::string &filename, const std::size_t messag\n std::size_t get_filesize(const std::string &filename) {\n     std::ifstream ifs(filename, std::ifstream::ate | std::ifstream::binary);\n     if (!ifs) {\n-        throw std::runtime_error(\"Failed open file \");\n+        throw std::runtime_error(\"Failed open file \" + filename);\n     }\n-\n     return static_cast<std::size_t>(ifs.tellg());\n }\n \n", "problem_statement": "(Probably minor) feature request: It should be possible to change the max_size for rotating_file_sink, after it has been constructed.\nPretty much what the title says.\n\nI imagine such a function would need to trigger a manual rotation first to keep things sane, of course. Why did I think of this? My app has a \"profiling mode\" where it spits time spent doing different things to the log.\n\nI initiallly implemented a logger with rotation a 2 MB, but the other day I turned this mode on and realized that a very short run basically obliterated all previous logs, which is very much not ideal. For now, I think maybe I'll direct these messsages to a separate file, but it would be nice if in the future, I could just change the max_size whenever this gets turned on.\n(Probably minor) feature request: It should be possible to change the max_size for rotating_file_sink, after it has been constructed.\nPretty much what the title says.\n\nI imagine such a function would need to trigger a manual rotation first to keep things sane, of course. Why did I think of this? My app has a \"profiling mode\" where it spits time spent doing different things to the log.\n\nI initiallly implemented a logger with rotation a 2 MB, but the other day I turned this mode on and realized that a very short run basically obliterated all previous logs, which is very much not ideal. For now, I think maybe I'll direct these messsages to a separate file, but it would be nice if in the future, I could just change the max_size whenever this gets turned on.\n", "hints_text": "The same feature request was received: #2288\n\nThe workaround in the current API is the method described in [this comment](https://github.com/gabime/spdlog/issues/2288#issuecomment-1049933773)\nThe same feature request was received: #2288\n\nThe workaround in the current API is the method described in [this comment](https://github.com/gabime/spdlog/issues/2288#issuecomment-1049933773)", "created_at": "2025-05-08T10:37:16Z"}
{"repo": "gabime/spdlog", "pull_number": 3366, "instance_id": "gabime__spdlog-3366", "issue_numbers": ["3352"], "base_commit": "faa0a7a9c5a3550ed5461fab7d8e31c37fd1a2ef", "patch": "diff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -267,7 +267,8 @@ SPDLOG_INLINE int utc_minutes_offset(const std::tm &tm) {\n \n     #if defined(sun) || defined(__sun) || defined(_AIX) || \\\n         (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||  \\\n-        (!defined(_BSD_SOURCE) && !defined(_GNU_SOURCE))\n+        (!defined(__APPLE__) && !defined(_BSD_SOURCE) && !defined(_GNU_SOURCE) && \\\n+            (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n     // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris\n     struct helper {\n         static long int calculate_gmt_offset(const std::tm &localtm = details::os::localtime(),\n", "test_patch": "diff --git a/tests/test_pattern_formatter.cpp b/tests/test_pattern_formatter.cpp\n--- a/tests/test_pattern_formatter.cpp\n+++ b/tests/test_pattern_formatter.cpp\n@@ -1,6 +1,8 @@\n #include \"includes.h\"\n #include \"test_sink.h\"\n \n+#include <chrono>\n+\n using spdlog::memory_buf_t;\n using spdlog::details::to_string_view;\n \n@@ -19,6 +21,21 @@ static std::string log_to_str(const std::string &msg, const Args &...args) {\n     return oss.str();\n }\n \n+// log to str and return it with time\n+template <typename... Args>\n+static std::string log_to_str_with_time(spdlog::log_clock::time_point log_time, const std::string &msg, const Args &...args) {\n+    std::ostringstream oss;\n+    auto oss_sink = std::make_shared<spdlog::sinks::ostream_sink_mt>(oss);\n+    spdlog::logger oss_logger(\"pattern_tester\", oss_sink);\n+    oss_logger.set_level(spdlog::level::info);\n+\n+    oss_logger.set_formatter(\n+        std::unique_ptr<spdlog::formatter>(new spdlog::pattern_formatter(args...)));\n+\n+    oss_logger.log(log_time, {}, spdlog::level::info, msg);\n+    return oss.str();\n+}\n+\n TEST_CASE(\"custom eol\", \"[pattern_formatter]\") {\n     std::string msg = \"Hello custom eol test\";\n     std::string eol = \";)\";\n@@ -58,6 +75,15 @@ TEST_CASE(\"date MM/DD/YY \", \"[pattern_formatter]\") {\n             oss.str());\n }\n \n+TEST_CASE(\"GMT offset \", \"[pattern_formatter]\") {\n+    using namespace std::chrono_literals;\n+    const auto now = std::chrono::system_clock::now();\n+    const auto yesterday = now - 24h;\n+\n+    REQUIRE(log_to_str_with_time(yesterday, \"Some message\", \"%z\", spdlog::pattern_time_type::utc, \"\\n\") ==\n+            \"+00:00\\n\");\n+}\n+\n TEST_CASE(\"color range test1\", \"[pattern_formatter]\") {\n     auto formatter = std::make_shared<spdlog::pattern_formatter>(\n         \"%^%v%$\", spdlog::pattern_time_type::local, \"\\n\");\n", "problem_statement": "Missing test for __APPLE__ chooses buggy SunOS/Solaris workaround in utc_minutes_offset\nspdlog uses the function `utc_minutes_offset` in the `z_formatter` to format the `'%z'`-part of a format string (UTC-offset) when logging time. The function has three implementations, one of which is chosen at compile time via marcro defines (Windows, SunOS/Solaris, default):\n\nhttps://github.com/gabime/spdlog/blob/3335c380a08c5e0f5117a66622df6afdb3d74959/include/spdlog/details/os-inl.h#L268-L271\n\nThis test doesn't detect Apple platforms, which have had the `tm_gmtoff`-field at least since [Mac OS X 10.0](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/ctime.3.html), and also doesn't detect [POSIX.1-2024](https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/time.h.html) conforming systems, which are also required to support `tm_gmtoff`.\n\nOn Apple and POSIX1.-2024 platforms, this has the unfortunate effect to use the SunOS/Solaris fallback, which doesn't compute the correct value if the passed value of `tm` isn't the current system time, i.e. `localtime(::time())` (#3351).\n\nI suggest to fix this by changing the test to something like\n```c++\n    #if defined(sun) || defined(__sun) || defined(_AIX) || \\\n        (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||  \\\n        (!defined(__APPLE__) && !defined(_BSD_SOURCE) && !defined(_GNU_SOURCE) && \\\n            (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n    // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris\n```\n", "hints_text": "Thanks for the report. Is there a test that can be added to tests/ to reproduce this?\nPR is always welcome.", "created_at": "2025-03-29T10:10:34Z"}
{"repo": "gabime/spdlog", "pull_number": 3291, "instance_id": "gabime__spdlog-3291", "issue_numbers": ["3233"], "base_commit": "24dde318fe034f0c7e809daa5a6e81dc85e1155a", "patch": "diff --git a/include/spdlog/tweakme.h b/include/spdlog/tweakme.h\n--- a/include/spdlog/tweakme.h\n+++ b/include/spdlog/tweakme.h\n@@ -104,6 +104,13 @@\n //\n // #define SPDLOG_LEVEL_NAMES { \"MY TRACE\", \"MY DEBUG\", \"MY INFO\", \"MY WARNING\", \"MY ERROR\", \"MY\n // CRITICAL\", \"OFF\" }\n+//\n+// For C++17 use string_view_literals:\n+//\n+// #include <string_view>\n+// using namespace std::string_view_literals;\n+// #define SPDLOG_LEVEL_NAMES { \"MY TRACE\"sv, \"MY DEBUG\"sv, \"MY INFO\"sv, \"MY WARNING\"sv, \"MY ERROR\"sv, \"MY\n+// CRITICAL\"sv, \"OFF\"sv }\n ///////////////////////////////////////////////////////////////////////////////\n \n ///////////////////////////////////////////////////////////////////////////////\n", "test_patch": "", "problem_statement": "#define SPDLOG_LEVEL_NAMES with external FMT doesn't compile, starting from libfmt11.\nThis came up macOS/apple clang:\r\n\r\n```bash\r\nIn file included from /opt/local/include/spdlog/common.h:410:\r\n/opt/local/include/spdlog/common-inl.h:19:26: error: constexpr variable 'level_string_views' must be initialized by a constant expression\r\n    static string_view_t level_string_views[] SPDLOG_LEVEL_NAMES;\r\n                         ^                    ~~~~~~~~~~~~~~~~~~\r\n/opt/local/include/spdlog/common-inl.h:19:47: note: non-constexpr constructor 'basic_string_view' cannot be used in a constant expression\r\n    static string_view_t level_string_views[] SPDLOG_LEVEL_NAMES;\r\n                                              ^\r\n/Users/Koji/performous/game/log.hh:11:30: note: expanded from macro 'SPDLOG_LEVEL_NAMES'\r\n#define SPDLOG_LEVEL_NAMES { \"TRACE\", \"DEBUG\", \"INFO\", \"NOTICE\", \"WARNING\", \"ERROR\", \"OFF\" }\r\n                             ^\r\n/opt/local/include/libfmt11/fmt/base.h:536:3: note: declared here\r\n  basic_string_view(const Char* s)\r\n  ^\r\n```\r\nRemoving the `constexpr` from `static string_view_t level_string_views[] SPDLOG_LEVEL_NAMES;` makes it compile, but I don't think this is really the correct fix?\n", "hints_text": "This is working, and at least is a better work-around IMO:\r\n\r\n```c++\r\n#include <string_view>\r\nusing namespace std::string_view_literals;\r\n#define SPDLOG_LEVEL_NAMES { \"TRACE\"sv, \"DEBUG\"sv, \"INFO\"sv, \"NOTICE\"sv, \"WARNING\"sv, \"ERROR\"sv, \"OFF\"sv }\r\n```\nPR is welcome. Note that the \u201csv\u201d literal is c++17 while spdlog should support 11\n> PR is welcome. Note that the \u201csv\u201d literal is c++17 while spdlog should support 11\r\n\r\nI would open a PR, but I don't really know what the best approach is for the majority of people.\n> PR is welcome. Note that the \u201csv\u201d literal is c++17 while spdlog should support 11\r\n\r\nI was thinking again on this and realized that this would likely not really be an issue, because the problem only presents when `level_string_views[]` is declared `constexpr` and that is gated under a check for c++17 already.\r\n\r\nSo, most likely for now at least the only thing you really need to change is documenting this option, which could likely be done in the same `tweakme` header \n> > PR is welcome. Note that the \u201csv\u201d literal is c++17 while spdlog should support 11\r\n> \r\n> I was thinking again on this and realized that this would likely not really be an issue, because the problem only presents when `level_string_views[]` is declared `constexpr` and that is gated under a check for c++17 already.\r\n> \r\n> So, most likely for now at least the only thing you really need to change is documenting this option, which could likely be done in the same `tweakme` header\r\n\r\nI encountered this issue while compiling the project using C++ 17, and after switching the C++ version to 14 or 20, the compilation was successful.", "created_at": "2024-12-11T08:29:23Z"}
{"repo": "gabime/spdlog", "pull_number": 3244, "instance_id": "gabime__spdlog-3244", "issue_numbers": ["3241"], "base_commit": "63f0875000bf90867aa7c76a831bd834cb7d4b5e", "patch": "diff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -483,12 +483,12 @@ SPDLOG_INLINE void utf8_to_wstrbuf(string_view_t str, wmemory_buf_t &target) {\n \n     // find the size to allocate for the result buffer\n     int result_size =\n-        ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size, NULL, 0);\n+        ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, NULL, 0);\n \n     if (result_size > 0) {\n         target.resize(result_size);\n-        result_size = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size,\n-                                            target.data(), result_size);\n+        result_size = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, target.data(),\n+                                            result_size);\n         if (result_size > 0) {\n             assert(result_size == target.size());\n             return;\n", "test_patch": "diff --git a/tests/includes.h b/tests/includes.h\n--- a/tests/includes.h\n+++ b/tests/includes.h\n@@ -26,6 +26,7 @@\n #include \"spdlog/spdlog.h\"\n #include \"spdlog/async.h\"\n #include \"spdlog/details/fmt_helper.h\"\n+#include \"spdlog/details/os.h\"\n \n #ifndef SPDLOG_NO_TLS\n     #include \"spdlog/mdc.h\"\ndiff --git a/tests/test_misc.cpp b/tests/test_misc.cpp\n--- a/tests/test_misc.cpp\n+++ b/tests/test_misc.cpp\n@@ -167,3 +167,21 @@ TEST_CASE(\"default logger API\", \"[default logger]\") {\n     spdlog::drop_all();\n     spdlog::set_pattern(\"%v\");\n }\n+\n+#if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n+TEST_CASE(\"utf8 to utf16 conversion using windows api\", \"[windows utf]\") {\n+    spdlog::wmemory_buf_t buffer;\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"\", buffer);\n+    REQUIRE(buffer.data() == std::wstring(L\"\"));\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"abc\", buffer);\n+    REQUIRE(buffer.data() == std::wstring(L\"abc\"));\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xc3\\x28\", buffer); // Invalid UTF-8 sequence.\n+    REQUIRE(buffer.data() == std::wstring(L\"\\xfffd(\"));\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xe3\\x81\\xad\\xe3\\x81\\x93\", buffer); // \"Neko\" in hiragana.\n+    REQUIRE(buffer.data() == std::wstring(L\"\\x306d\\x3053\"));\n+}\n+#endif\n", "problem_statement": "msvc_sink throws on invalid utf-8\nThis is what `msvc_sink` is doing:\r\n```cpp\r\n    #if defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)\r\n        wmemory_buf_t wformatted;\r\n        details::os::utf8_to_wstrbuf(string_view_t(formatted.data(), formatted.size()), wformatted);\r\n        OutputDebugStringW(wformatted.data());\r\n    #else\r\n        OutputDebugStringA(formatted.data());\r\n    #endif\r\n```\r\n\r\nThen in `utf8_to_wstrbuf` we have:\r\n```cpp\r\n    int result_size =\r\n        ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size, NULL, 0);\r\n```\r\n\r\n`MB_ERR_INVALID_CHARS` causes the function to fail on invalid characters, and then `utf8_to_wstrbuf` throws.\r\n\r\nWe've run into this when trying to output game data that wasn't utf-8 encoded, had to roll out our own implementation of `msvc_sink` (https://github.com/OpenEnroth/OpenEnroth/pull/1825).\r\n\r\nMy feel here is that logging should work at best effort basis and should not throw unless absolutely necessary (as exception can lead to `std::terminate`). Log calls can be buried somewhere deep in error handling code, and the usual expectation there is that logging calls don't throw.\r\n\r\nIn this particular case writing out text that's a bit garbled is perfectly OK.\n", "hints_text": "Loggers never throw. The sinks might throw but loggers catch everything, so I am not sure what is the problem\n\nAh OK. Then please disregard my comments on safety.\r\n\r\nWhat do you think about just logging the text that's a bit garbled in this case instead of throwing?\nI don't think it's a good idea. Might lead to undefined behavior. \nThere is no UB involved, `MultiByteToWideChar` w/o `MB_ERR_INVALID_CHARS` will just replace invalid code points with `U+FFFD` (\ufffd), or drop them if we're talking older Windows versions.\r\n\r\nThe change is safe, the only concern there is about the difference in behavior. The options are:\r\n1. Throw, potentially causing other loggers in the enclosing `dist_sink` not to run, and write an error to `stderr`.\r\n2. Write out text with \ufffds to msvc debug console.\r\n\r\nMy opinion is that the latter option is strictly better. What am I missing?\nI agree. PR is welcome. Could you also add a simple test for this ?\nSure, will do a PR with a test. Thanks!", "created_at": "2024-11-05T20:10:10Z"}
{"repo": "gabime/spdlog", "pull_number": 3235, "instance_id": "gabime__spdlog-3235", "issue_numbers": ["3221"], "base_commit": "b6da59447f165ad70a4e3ca1c575b14ea66d92c9", "patch": "diff --git a/include/spdlog/async_logger-inl.h b/include/spdlog/async_logger-inl.h\n--- a/include/spdlog/async_logger-inl.h\n+++ b/include/spdlog/async_logger-inl.h\n@@ -32,30 +32,26 @@ SPDLOG_INLINE spdlog::async_logger::async_logger(std::string logger_name,\n \n // send the log message to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::sink_it_(const details::log_msg &msg){\n-    SPDLOG_TRY {\n-        if (auto pool_ptr = thread_pool_.lock()){\n-            pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n-        }\n-        else {\n-            throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n-        }\n-    }\n-    SPDLOG_LOGGER_CATCH(msg.source)\n+    SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n+        pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n+}\n+else {\n+    throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n+}\n+}\n+SPDLOG_LOGGER_CATCH(msg.source)\n }\n \n // send flush request to the thread pool\n-SPDLOG_INLINE void spdlog::async_logger::flush_() {\n-    SPDLOG_TRY {\n-        auto pool_ptr = thread_pool_.lock();\n-        if (!pool_ptr) {\n-            throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n-        }\n-\n-        // Wait for the flush operation to complete.\n-        // This might throw exception if the flush message get dropped because of overflow.\n-        pool_ptr->post_and_wait_for_flush(shared_from_this(), overflow_policy_);\n-    }\n-    SPDLOG_LOGGER_CATCH(source_loc())\n+SPDLOG_INLINE void spdlog::async_logger::flush_(){\n+    SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n+        pool_ptr->post_flush(shared_from_this(), overflow_policy_);\n+}\n+else {\n+    throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n+}\n+}\n+SPDLOG_LOGGER_CATCH(source_loc())\n }\n \n //\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -62,25 +62,9 @@ void SPDLOG_INLINE thread_pool::post_log(async_logger_ptr &&worker_ptr,\n     post_async_msg_(std::move(async_m), overflow_policy);\n }\n \n-void SPDLOG_INLINE thread_pool::post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n-                                                        async_overflow_policy overflow_policy) {\n-    std::mutex m;\n-    std::unique_lock<std::mutex> l(m);\n-    std::condition_variable cv;\n-    std::atomic<async_msg_flush> cv_flag{async_msg_flush::not_synced};\n-    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush, [&cv, &cv_flag](async_msg_flush flushed) {\n-        cv_flag.store(flushed, std::memory_order_relaxed);\n-        cv.notify_all();\n-    }), overflow_policy);\n-    while(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::not_synced) {\n-        cv.wait_for(l, std::chrono::milliseconds(100), [&cv_flag]() {\n-            return cv_flag.load(std::memory_order_relaxed) != async_msg_flush::not_synced;\n-        });\n-    }\n-\n-    if(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::synced_not_flushed) {\n-        throw spdlog_ex(\"Request for flushing got dropped.\");\n-    }\n+void SPDLOG_INLINE thread_pool::post_flush(async_logger_ptr &&worker_ptr,\n+                                           async_overflow_policy overflow_policy) {\n+    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush), overflow_policy);\n }\n \n size_t SPDLOG_INLINE thread_pool::overrun_counter() { return q_.overrun_counter(); }\n@@ -124,10 +108,6 @@ bool SPDLOG_INLINE thread_pool::process_next_msg_() {\n         }\n         case async_msg_type::flush: {\n             incoming_async_msg.worker_ptr->backend_flush_();\n-            if(incoming_async_msg.flush_callback) {\n-                incoming_async_msg.flush_callback(async_msg_flush::synced_flushed);\n-                incoming_async_msg.flush_callback = nullptr;\n-            }\n             return true;\n         }\n \ndiff --git a/include/spdlog/details/thread_pool.h b/include/spdlog/details/thread_pool.h\n--- a/include/spdlog/details/thread_pool.h\n+++ b/include/spdlog/details/thread_pool.h\n@@ -22,60 +22,46 @@ using async_logger_ptr = std::shared_ptr<spdlog::async_logger>;\n \n enum class async_msg_type { log, flush, terminate };\n \n-enum class async_msg_flush { not_synced, synced_flushed, synced_not_flushed };\n-\n // Async msg to move to/from the queue\n // Movable only. should never be copied\n struct async_msg : log_msg_buffer {\n     async_msg_type msg_type{async_msg_type::log};\n     async_logger_ptr worker_ptr;\n-    std::function<void(async_msg_flush)> flush_callback;\n \n     async_msg() = default;\n-    ~async_msg() {\n-        if (flush_callback) {\n-            flush_callback(async_msg_flush::synced_not_flushed);\n-            flush_callback = nullptr;\n-        }\n-    }\n+    ~async_msg() = default;\n \n     // should only be moved in or out of the queue..\n     async_msg(const async_msg &) = delete;\n \n-    async_msg(async_msg &&other) SPDLOG_NOEXCEPT\n+// support for vs2013 move\n+#if defined(_MSC_VER) && _MSC_VER <= 1800\n+    async_msg(async_msg &&other)\n         : log_msg_buffer(std::move(other)),\n           msg_type(other.msg_type),\n-          worker_ptr(std::move(other.worker_ptr)),\n-          flush_callback(std::move(other.flush_callback)) {\n-        other.flush_callback = nullptr;\n-    }\n+          worker_ptr(std::move(other.worker_ptr)) {}\n \n-    async_msg &operator=(async_msg &&other) SPDLOG_NOEXCEPT {\n-        *static_cast<log_msg_buffer *>(this) = static_cast<log_msg_buffer&&>(other);\n+    async_msg &operator=(async_msg &&other) {\n+        *static_cast<log_msg_buffer *>(this) = std::move(other);\n         msg_type = other.msg_type;\n         worker_ptr = std::move(other.worker_ptr);\n-        std::swap(flush_callback, other.flush_callback);\n         return *this;\n     }\n+#else  // (_MSC_VER) && _MSC_VER <= 1800\n+    async_msg(async_msg &&) = default;\n+    async_msg &operator=(async_msg &&) = default;\n+#endif\n \n     // construct from log_msg with given type\n     async_msg(async_logger_ptr &&worker, async_msg_type the_type, const details::log_msg &m)\n         : log_msg_buffer{m},\n           msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{} {}\n+          worker_ptr{std::move(worker)} {}\n \n     async_msg(async_logger_ptr &&worker, async_msg_type the_type)\n         : log_msg_buffer{},\n           msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{} {}\n-\n-    async_msg(async_logger_ptr &&worker, async_msg_type the_type, std::function<void(async_msg_flush)> &&callback)\n-        : log_msg_buffer{},\n-          msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{std::move(callback)} {}\n+          worker_ptr{std::move(worker)} {}\n \n     explicit async_msg(async_msg_type the_type)\n         : async_msg{nullptr, the_type} {}\n@@ -102,8 +88,7 @@ class SPDLOG_API thread_pool {\n     void post_log(async_logger_ptr &&worker_ptr,\n                   const details::log_msg &msg,\n                   async_overflow_policy overflow_policy);\n-    void post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n-                                 async_overflow_policy overflow_policy);\n+    void post_flush(async_logger_ptr &&worker_ptr, async_overflow_policy overflow_policy);\n     size_t overrun_counter();\n     void reset_overrun_counter();\n     size_t discard_counter();\n", "test_patch": "diff --git a/tests/test_async.cpp b/tests/test_async.cpp\n--- a/tests/test_async.cpp\n+++ b/tests/test_async.cpp\n@@ -93,50 +93,6 @@ TEST_CASE(\"flush\", \"[async]\") {\n     REQUIRE(test_sink->flush_counter() == 1);\n }\n \n-TEST_CASE(\"multithread flush\", \"[async]\") {\n-    auto test_sink = std::make_shared<spdlog::sinks::test_sink_mt>();\n-    size_t queue_size = 2;\n-    size_t messages = 10;\n-    size_t n_threads = 10;\n-    size_t flush_count = 1024;\n-    std::mutex mtx;\n-    std::vector<std::string> errmsgs;\n-    {\n-        auto tp = std::make_shared<spdlog::details::thread_pool>(queue_size, 1);\n-        auto logger = std::make_shared<spdlog::async_logger>(\n-            \"as\", test_sink, tp, spdlog::async_overflow_policy::discard_new);\n-\n-        logger->set_error_handler([&](const std::string &) {\n-            std::unique_lock<std::mutex> lock(mtx);\n-            errmsgs.push_back(\"Broken promise\");\n-        });\n-\n-        for (size_t i = 0; i < messages; i++) {\n-            logger->info(\"Hello message #{}\", i);\n-        }\n-\n-        std::vector<std::thread> threads;\n-        for (size_t i = 0; i < n_threads; i++) {\n-            threads.emplace_back([logger, flush_count] {\n-                for (size_t j = 0; j < flush_count; j++) {\n-                    // flush does not throw exception even if failed.\n-                    // Instead, the error handler is invoked.\n-                    logger->flush();\n-                }\n-            });\n-        }\n-\n-        for (auto &t : threads) {\n-            t.join();\n-        }\n-    }\n-    REQUIRE(test_sink->flush_counter() >= 1);\n-    REQUIRE(test_sink->flush_counter() + errmsgs.size() == n_threads * flush_count);\n-    if (errmsgs.size() > 0) {\n-        REQUIRE(errmsgs[0] == \"Broken promise\");\n-    }\n-}\n-\n TEST_CASE(\"async periodic flush\", \"[async]\") {\n     auto logger = spdlog::create_async<spdlog::sinks::test_sink_mt>(\"as\");\n     auto test_sink = std::static_pointer_cast<spdlog::sinks::test_sink_mt>(logger->sinks()[0]);\n", "problem_statement": "1.14.1 unresolvable R_X86_64_TPOFF32 relocation \nUpdating spdlog to 1.14.1, I get the following linker error:\r\n```\r\n/usr/bin/c++ -Wno-maybe-uninitialized  -ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries test/CMakeFiles/EtcdTests.dir/EtcdTests.cpp.o -o /opt/ichor/src/bin/EtcdTests  /opt/ichor/src/bin/libichor.a  /opt/ichor/src/bin/libCatch2Main.a  -lsystemd  /usr/lib/libboost_coroutine.a  /usr/lib/libboost_fiber.a  /usr/lib/libboost_context.a  /usr/lib/libboost_filesystem.a  /usr/lib/libssl.a  /usr/lib/libcrypto.a  -ldl  -lhiredis  -ldl  -lrt  /opt/ichor/src/bin/libCatch2.a && :\r\n/usr/bin/ld: /opt/ichor/src/bin/libichor.a(async.cpp.o)(.text+0x266e): unresolvable R_X86_64_TPOFF32 relocation against symbol `_ZSt15__once_callable@@GLIBCXX_3.4.11'\r\n```\r\n\r\nThis doesn't happen with 1.13.0, or when `ftls-model=local-exec` is removed from the compiler flags.\r\n\r\nCompiler: gcc 12.3.0\r\nLinux: Ubuntu Jammy\r\ncxxflags: `-O2 -std=c++20 -fpie -fstack-protector-strong -fcf-protection -fstack-clash-protection -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -D_GLIBCXX_ASSERTIONS -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_FAST -ftls-model=local-exec`\r\nlinkflags: `-ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries`\n", "hints_text": "It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\nMaybe duplicate #1405\n> It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\r\n\r\nonce_callable is likely a thread_local related symbol, which glibc uses. The error shows that this happens in [async.cpp](https://github.com/gabime/spdlog/blob/v1.x/src/async.cpp), which includes a bunch of spdlog related files. \r\n\r\n\r\n\r\n> Maybe duplicate #1405\r\n\r\n`-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\n> `-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\r\n\r\nAs far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\n> As far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\r\n\r\nYour linked stackoverflow is saying the same thing as I am. As long as the end result is a dynamic library (either directly, or by first creating a static library which is then linked into a dynamic library), `-fPIC` is useful. This can also be gleaned from the [gcc manual](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html): \r\n\r\n> Generate position-independent code (PIC) suitable for use in a shared library ...\r\n\r\nHowever, I am not creating a shared library anywhere in my workflow. I make a static library and link it directly into an executable. Therefore, I use `-fpie` (since my GOT tables aren't too big to need to use `-fPIE`) and `-fPIC` has no effect on the problem at hand. I know, because I've added it to the compiler flags and it resulted in the same error I mentioned above.\r\n\r\nI have bisected the problem to [6725584e27ca93f50527165696d7cf34e3978373](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373). And specifically, the call to `set_value()` in [thread_pool-inl.h:115](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373#diff-6c9b5dd2454f632886023e6bc86e7b04fe7d0f1be5c25d505679987a7da7b05dR115). \r\n\r\n`promise<>::set_value()` ends up calling [std::call_once](https://github.com/gcc-mirror/gcc/blob/8fc1a49c9312b05d925b7d21f1d2145d70818151/libstdc%2B%2B-v3/include/std/future#L426), which requires thread local storage and GCC requires the glibcxx once_callable symbol (which is probably some pthread_once alias). `ftls-model=local-exec` disables the usage of `thread_local` storage which has not been defined inside the executable itself. And the `once_callable` symbol resides in `libc.so.6`. \r\n\r\nOn top of that, unfortunately, gcc has had a [pretty bad bug](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146) with `std::call_once` and exceptions since gcc 5.x, making it impossible to support handling exceptions during a `std::call_once` call on musl and other non-glibc, non-x86 targets. Not the case here, but certainly something to consider.\r\n\r\nThe options I see are as follows:\r\n* Change compiler flags to `ftls-model=initial-exec`, losing some performance whenever I access `thread_local` variables\r\n* Refactor the `std::promise`/`std::future` to a `std::function` of sorts.\r\n* Patch out the specific commit in my own fork\nThanks for the accurate investigation.\r\nI had never heard of the `std::call_once` bug in GCC.\r\nIt would be helpful if you could send the PR.\nSure, I'll take a stab when I have some free time. It would likely be a backwards incompatible change though. Or should I put in a `#ifdef` to control the function signature?\nPersonally, I think it is a bug and should be fixed even if it is not compatible.\r\nHowever, I am not this repository maintainer, so the final decision is up to @gabime.", "created_at": "2024-11-01T09:13:47Z"}
{"repo": "gabime/spdlog", "pull_number": 3228, "instance_id": "gabime__spdlog-3228", "issue_numbers": ["3221"], "base_commit": "e593f6695c6065e6b345fe2862f04a519ed484e0", "patch": "diff --git a/include/spdlog/async_logger-inl.h b/include/spdlog/async_logger-inl.h\n--- a/include/spdlog/async_logger-inl.h\n+++ b/include/spdlog/async_logger-inl.h\n@@ -32,28 +32,30 @@ SPDLOG_INLINE spdlog::async_logger::async_logger(std::string logger_name,\n \n // send the log message to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::sink_it_(const details::log_msg &msg){\n-    SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n-        pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n-}\n-else {\n-    throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n-}\n-}\n-SPDLOG_LOGGER_CATCH(msg.source)\n+    SPDLOG_TRY {\n+        if (auto pool_ptr = thread_pool_.lock()){\n+            pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n+        }\n+        else {\n+            throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n+        }\n+    }\n+    SPDLOG_LOGGER_CATCH(msg.source)\n }\n \n // send flush request to the thread pool\n-SPDLOG_INLINE void spdlog::async_logger::flush_(){SPDLOG_TRY{auto pool_ptr = thread_pool_.lock();\n-if (!pool_ptr) {\n-    throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n-}\n+SPDLOG_INLINE void spdlog::async_logger::flush_() {\n+    SPDLOG_TRY {\n+        auto pool_ptr = thread_pool_.lock();\n+        if (!pool_ptr) {\n+            throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n+        }\n \n-std::future<void> future = pool_ptr->post_flush(shared_from_this(), overflow_policy_);\n-// Wait for the flush operation to complete.\n-// This might throw exception if the flush message get dropped because of overflow.\n-future.get();\n-}\n-SPDLOG_LOGGER_CATCH(source_loc())\n+        // Wait for the flush operation to complete.\n+        // This might throw exception if the flush message get dropped because of overflow.\n+        pool_ptr->post_and_wait_for_flush(shared_from_this(), overflow_policy_);\n+    }\n+    SPDLOG_LOGGER_CATCH(source_loc())\n }\n \n //\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -62,13 +62,25 @@ void SPDLOG_INLINE thread_pool::post_log(async_logger_ptr &&worker_ptr,\n     post_async_msg_(std::move(async_m), overflow_policy);\n }\n \n-std::future<void> SPDLOG_INLINE thread_pool::post_flush(async_logger_ptr &&worker_ptr,\n+void SPDLOG_INLINE thread_pool::post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n                                                         async_overflow_policy overflow_policy) {\n-    std::promise<void> promise;\n-    std::future<void> future = promise.get_future();\n-    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush, std::move(promise)),\n-                    overflow_policy);\n-    return future;\n+    std::mutex m;\n+    std::unique_lock<std::mutex> l(m);\n+    std::condition_variable cv;\n+    std::atomic<async_msg_flush> cv_flag{async_msg_flush::not_synced};\n+    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush, [&cv, &cv_flag](async_msg_flush flushed) {\n+        cv_flag.store(flushed, std::memory_order_relaxed);\n+        cv.notify_all();\n+    }), overflow_policy);\n+    while(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::not_synced) {\n+        cv.wait_for(l, std::chrono::milliseconds(100), [&cv_flag]() {\n+            return cv_flag.load(std::memory_order_relaxed) != async_msg_flush::not_synced;\n+        });\n+    }\n+\n+    if(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::synced_not_flushed) {\n+        throw spdlog_ex(\"Request for flushing got dropped.\");\n+    }\n }\n \n size_t SPDLOG_INLINE thread_pool::overrun_counter() { return q_.overrun_counter(); }\n@@ -112,7 +124,10 @@ bool SPDLOG_INLINE thread_pool::process_next_msg_() {\n         }\n         case async_msg_type::flush: {\n             incoming_async_msg.worker_ptr->backend_flush_();\n-            incoming_async_msg.flush_promise.set_value();\n+            if(incoming_async_msg.flush_callback) {\n+                incoming_async_msg.flush_callback(async_msg_flush::synced_flushed);\n+                incoming_async_msg.flush_callback = nullptr;\n+            }\n             return true;\n         }\n \ndiff --git a/include/spdlog/details/thread_pool.h b/include/spdlog/details/thread_pool.h\n--- a/include/spdlog/details/thread_pool.h\n+++ b/include/spdlog/details/thread_pool.h\n@@ -9,7 +9,6 @@\n \n #include <chrono>\n #include <functional>\n-#include <future>\n #include <memory>\n #include <thread>\n #include <vector>\n@@ -23,55 +22,60 @@ using async_logger_ptr = std::shared_ptr<spdlog::async_logger>;\n \n enum class async_msg_type { log, flush, terminate };\n \n+enum class async_msg_flush { not_synced, synced_flushed, synced_not_flushed };\n+\n // Async msg to move to/from the queue\n // Movable only. should never be copied\n struct async_msg : log_msg_buffer {\n     async_msg_type msg_type{async_msg_type::log};\n     async_logger_ptr worker_ptr;\n-    std::promise<void> flush_promise;\n+    std::function<void(async_msg_flush)> flush_callback;\n \n     async_msg() = default;\n-    ~async_msg() = default;\n+    ~async_msg() {\n+        if (flush_callback) {\n+            flush_callback(async_msg_flush::synced_not_flushed);\n+            flush_callback = nullptr;\n+        }\n+    }\n \n     // should only be moved in or out of the queue..\n     async_msg(const async_msg &) = delete;\n \n-// support for vs2013 move\n-#if defined(_MSC_VER) && _MSC_VER <= 1800\n-    async_msg(async_msg &&other)\n+    async_msg(async_msg &&other) SPDLOG_NOEXCEPT\n         : log_msg_buffer(std::move(other)),\n           msg_type(other.msg_type),\n-          worker_ptr(std::move(other.worker_ptr)) {}\n-\n-    async_msg &operator=(async_msg &&other) {\n-        *static_cast<log_msg_buffer *>(this) = std::move(other);\n+          worker_ptr(std::move(other.worker_ptr)),\n+          flush_callback(std::move(other.flush_callback)) {\n+        other.flush_callback = nullptr;\n+    }\n+    async_msg &operator=(async_msg &&other) SPDLOG_NOEXCEPT {\n+        *static_cast<log_msg_buffer *>(this) = static_cast<log_msg_buffer&&>(other);\n         msg_type = other.msg_type;\n         worker_ptr = std::move(other.worker_ptr);\n+        flush_callback = std::move(other.flush_callback);\n+        other.flush_callback = nullptr;\n         return *this;\n     }\n-#else  // (_MSC_VER) && _MSC_VER <= 1800\n-    async_msg(async_msg &&) = default;\n-    async_msg &operator=(async_msg &&) = default;\n-#endif\n \n     // construct from log_msg with given type\n     async_msg(async_logger_ptr &&worker, async_msg_type the_type, const details::log_msg &m)\n         : log_msg_buffer{m},\n           msg_type{the_type},\n           worker_ptr{std::move(worker)},\n-          flush_promise{} {}\n+          flush_callback{} {}\n \n     async_msg(async_logger_ptr &&worker, async_msg_type the_type)\n         : log_msg_buffer{},\n           msg_type{the_type},\n           worker_ptr{std::move(worker)},\n-          flush_promise{} {}\n+          flush_callback{} {}\n \n-    async_msg(async_logger_ptr &&worker, async_msg_type the_type, std::promise<void> &&promise)\n+    async_msg(async_logger_ptr &&worker, async_msg_type the_type, std::function<void(async_msg_flush)> &&callback)\n         : log_msg_buffer{},\n           msg_type{the_type},\n           worker_ptr{std::move(worker)},\n-          flush_promise{std::move(promise)} {}\n+          flush_callback{std::move(callback)} {}\n \n     explicit async_msg(async_msg_type the_type)\n         : async_msg{nullptr, the_type} {}\n@@ -98,7 +102,7 @@ class SPDLOG_API thread_pool {\n     void post_log(async_logger_ptr &&worker_ptr,\n                   const details::log_msg &msg,\n                   async_overflow_policy overflow_policy);\n-    std::future<void> post_flush(async_logger_ptr &&worker_ptr,\n+    void post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n                                  async_overflow_policy overflow_policy);\n     size_t overrun_counter();\n     void reset_overrun_counter();\n", "test_patch": "", "problem_statement": "1.14.1 unresolvable R_X86_64_TPOFF32 relocation \nUpdating spdlog to 1.14.1, I get the following linker error:\r\n```\r\n/usr/bin/c++ -Wno-maybe-uninitialized  -ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries test/CMakeFiles/EtcdTests.dir/EtcdTests.cpp.o -o /opt/ichor/src/bin/EtcdTests  /opt/ichor/src/bin/libichor.a  /opt/ichor/src/bin/libCatch2Main.a  -lsystemd  /usr/lib/libboost_coroutine.a  /usr/lib/libboost_fiber.a  /usr/lib/libboost_context.a  /usr/lib/libboost_filesystem.a  /usr/lib/libssl.a  /usr/lib/libcrypto.a  -ldl  -lhiredis  -ldl  -lrt  /opt/ichor/src/bin/libCatch2.a && :\r\n/usr/bin/ld: /opt/ichor/src/bin/libichor.a(async.cpp.o)(.text+0x266e): unresolvable R_X86_64_TPOFF32 relocation against symbol `_ZSt15__once_callable@@GLIBCXX_3.4.11'\r\n```\r\n\r\nThis doesn't happen with 1.13.0, or when `ftls-model=local-exec` is removed from the compiler flags.\r\n\r\nCompiler: gcc 12.3.0\r\nLinux: Ubuntu Jammy\r\ncxxflags: `-O2 -std=c++20 -fpie -fstack-protector-strong -fcf-protection -fstack-clash-protection -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -D_GLIBCXX_ASSERTIONS -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_FAST -ftls-model=local-exec`\r\nlinkflags: `-ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries`\n", "hints_text": "It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\nMaybe duplicate #1405\n> It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\r\n\r\nonce_callable is likely a thread_local related symbol, which glibc uses. The error shows that this happens in [async.cpp](https://github.com/gabime/spdlog/blob/v1.x/src/async.cpp), which includes a bunch of spdlog related files. \r\n\r\n\r\n\r\n> Maybe duplicate #1405\r\n\r\n`-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\n> `-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\r\n\r\nAs far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\n> As far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\r\n\r\nYour linked stackoverflow is saying the same thing as I am. As long as the end result is a dynamic library (either directly, or by first creating a static library which is then linked into a dynamic library), `-fPIC` is useful. This can also be gleaned from the [gcc manual](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html): \r\n\r\n> Generate position-independent code (PIC) suitable for use in a shared library ...\r\n\r\nHowever, I am not creating a shared library anywhere in my workflow. I make a static library and link it directly into an executable. Therefore, I use `-fpie` (since my GOT tables aren't too big to need to use `-fPIE`) and `-fPIC` has no effect on the problem at hand. I know, because I've added it to the compiler flags and it resulted in the same error I mentioned above.\r\n\r\nI have bisected the problem to [6725584e27ca93f50527165696d7cf34e3978373](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373). And specifically, the call to `set_value()` in [thread_pool-inl.h:115](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373#diff-6c9b5dd2454f632886023e6bc86e7b04fe7d0f1be5c25d505679987a7da7b05dR115). \r\n\r\n`promise<>::set_value()` ends up calling [std::call_once](https://github.com/gcc-mirror/gcc/blob/8fc1a49c9312b05d925b7d21f1d2145d70818151/libstdc%2B%2B-v3/include/std/future#L426), which requires thread local storage and GCC requires the glibcxx once_callable symbol (which is probably some pthread_once alias). `ftls-model=local-exec` disables the usage of `thread_local` storage which has not been defined inside the executable itself. And the `once_callable` symbol resides in `libc.so.6`. \r\n\r\nOn top of that, unfortunately, gcc has had a [pretty bad bug](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146) with `std::call_once` and exceptions since gcc 5.x, making it impossible to support handling exceptions during a `std::call_once` call on musl and other non-glibc, non-x86 targets. Not the case here, but certainly something to consider.\r\n\r\nThe options I see are as follows:\r\n* Change compiler flags to `ftls-model=initial-exec`, losing some performance whenever I access `thread_local` variables\r\n* Refactor the `std::promise`/`std::future` to a `std::function` of sorts.\r\n* Patch out the specific commit in my own fork\nThanks for the accurate investigation.\r\nI had never heard of the `std::call_once` bug in GCC.\r\nIt would be helpful if you could send the PR.\nSure, I'll take a stab when I have some free time. It would likely be a backwards incompatible change though. Or should I put in a `#ifdef` to control the function signature?\nPersonally, I think it is a bug and should be fixed even if it is not compatible.\r\nHowever, I am not this repository maintainer, so the final decision is up to @gabime.", "created_at": "2024-10-25T19:12:49Z"}
{"repo": "gabime/spdlog", "pull_number": 3130, "instance_id": "gabime__spdlog-3130", "issue_numbers": ["3129"], "base_commit": "eeb22c13bb65f342434c991641b80ecf4821e9b9", "patch": "diff --git a/example/example.cpp b/example/example.cpp\n--- a/example/example.cpp\n+++ b/example/example.cpp\n@@ -272,7 +272,7 @@ struct my_type {\n #ifndef SPDLOG_USE_STD_FORMAT  // when using fmtlib\n template <>\n struct fmt::formatter<my_type> : fmt::formatter<std::string> {\n-    auto format(my_type my, format_context &ctx) -> decltype(ctx.out()) {\n+    auto format(my_type my, format_context &ctx) const -> decltype(ctx.out()) {\n         return fmt::format_to(ctx.out(), \"[my_type i={}]\", my.i);\n     }\n };\n", "test_patch": "", "problem_statement": "spdlog 1.14.1 fails to build with fmt 11.0.1\nUpdating our system copy of fmt to 11.0.1 I see spdlog 1.14.1 fails to build with an issue in example code.\r\n\r\n```\r\n[1/10] /home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -Dspdlog_EXPORTS -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -fPIC -MD -MT CMakeFiles/spdlog.dir/src/spdlog.cpp.o -MF CMakeFiles/spdlog.dir/src/spdlog.cpp.o.d -o CMakeFiles/spdlog.dir/src/spdlog.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/src/spdlog.cpp\r\n[2/10] /home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -Dspdlog_EXPORTS -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -fPIC -MD -MT CMakeFiles/spdlog.dir/src/stdout_sinks.cpp.o -MF CMakeFiles/spdlog.dir/src/stdout_sinks.cpp.o.d -o CMakeFiles/spdlog.dir/src/stdout_sinks.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/src/stdout_sinks.cpp\r\n[3/10] /home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -Dspdlog_EXPORTS -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -fPIC -MD -MT CMakeFiles/spdlog.dir/src/color_sinks.cpp.o -MF CMakeFiles/spdlog.dir/src/color_sinks.cpp.o.d -o CMakeFiles/spdlog.dir/src/color_sinks.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/src/color_sinks.cpp\r\n[4/10] /home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -Dspdlog_EXPORTS -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -fPIC -MD -MT CMakeFiles/spdlog.dir/src/file_sinks.cpp.o -MF CMakeFiles/spdlog.dir/src/file_sinks.cpp.o.d -o CMakeFiles/spdlog.dir/src/file_sinks.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/src/file_sinks.cpp\r\n[5/10] /home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -Dspdlog_EXPORTS -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -fPIC -MD -MT CMakeFiles/spdlog.dir/src/async.cpp.o -MF CMakeFiles/spdlog.dir/src/async.cpp.o.d -o CMakeFiles/spdlog.dir/src/async.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/src/async.cpp\r\n[6/10] /home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -Dspdlog_EXPORTS -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -fPIC -MD -MT CMakeFiles/spdlog.dir/src/cfg.cpp.o -MF CMakeFiles/spdlog.dir/src/cfg.cpp.o.d -o CMakeFiles/spdlog.dir/src/cfg.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/src/cfg.cpp\r\n[7/10] : && /home/ports/pobj/spdlog-1.14.1/bin/c++ -fPIC -O2 -pipe -DNDEBUG   -shared -Wl,-soname,libspdlog.so.2.0 -o libspdlog.so.2.0 CMakeFiles/spdlog.dir/src/spdlog.cpp.o CMakeFiles/spdlog.dir/src/stdout_sinks.cpp.o CMakeFiles/spdlog.dir/src/color_sinks.cpp.o CMakeFiles/spdlog.dir/src/file_sinks.cpp.o CMakeFiles/spdlog.dir/src/async.cpp.o CMakeFiles/spdlog.dir/src/cfg.cpp.o  -Wl,-z,origin,-rpath,/usr/local/lib:  /usr/local/lib/libfmt.so.3.0  -Wl,-rpath-link,/usr/X11R6/lib:/usr/local/lib && :\r\n[8/10] /usr/local/bin/cmake -E cmake_symlink_library libspdlog.so.2.0 libspdlog.so.2.0 libspdlog.so && :\r\n[9/10] /home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -MD -MT example/CMakeFiles/example.dir/example.cpp.o -MF example/CMakeFiles/example.dir/example.cpp.o.d -o example/CMakeFiles/example.dir/example.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/example/example.cpp\r\nFAILED: example/CMakeFiles/example.dir/example.cpp.o\r\n/home/ports/pobj/spdlog-1.14.1/bin/c++ -DFMT_SHARED -DSPDLOG_COMPILED_LIB -DSPDLOG_FMT_EXTERNAL -DSPDLOG_SHARED_LIB -I/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include -isystem /usr/local/include -O2 -pipe -DNDEBUG -std=c++11 -MD -MT example/CMakeFiles/example.dir/example.cpp.o -MF example/CMakeFiles/example.dir/example.cpp.o.d -o example/CMakeFiles/example.dir/example.cpp.o -c /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/example/example.cpp\r\nIn file included from /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/example/example.cpp:31:\r\nIn file included from /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include/spdlog/spdlog.h:12:\r\nIn file included from /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include/spdlog/common.h:50:\r\nIn file included from /home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include/spdlog/fmt/fmt.h:28:\r\nIn file included from /usr/local/include/fmt/core.h:5:\r\nIn file included from /usr/local/include/fmt/format.h:41:\r\n/usr/local/include/fmt/base.h:1392:20: error: 'this' argument to member function 'format' has type 'const fmt::formatter<my_type>', but function is not marked const\r\n    ctx.advance_to(cf.format(*static_cast<qualified_type*>(arg), ctx));\r\n                   ^~\r\n/usr/local/include/fmt/base.h:1373:21: note: in instantiation of function template specialization 'fmt::detail::value<fmt::context>::format_custom_arg<my_type, fmt::formatter<my_type>>' requested here\r\n    custom.format = format_custom_arg<\r\n                    ^\r\n/usr/local/include/fmt/base.h:1631:10: note: in instantiation of function template specialization 'fmt::detail::value<fmt::context>::value<my_type>' requested here\r\n  return {arg_mapper<Context>().map(val)};\r\n         ^\r\n/usr/local/include/fmt/base.h:2002:20: note: in instantiation of function template specialization 'fmt::detail::make_arg<true, fmt::context, my_type, 0>' requested here\r\n  return {{detail::make_arg<NUM_ARGS <= detail::max_packed_args, Context>(\r\n                   ^\r\n/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include/spdlog/logger.h:80:9: note: in instantiation of function template specialization 'spdlog::logger::log_<my_type>' requested here\r\n        log_(loc, lvl, details::to_string_view(fmt), std::forward<Args>(args)...);\r\n        ^\r\n/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include/spdlog/logger.h:85:9: note: in instantiation of function template specialization 'spdlog::logger::log<my_type>' requested here\r\n        log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);\r\n        ^\r\n/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include/spdlog/logger.h:140:9: note: in instantiation of function template specialization 'spdlog::logger::log<my_type>' requested here\r\n        log(level::info, fmt, std::forward<Args>(args)...);\r\n        ^\r\n/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/include/spdlog/spdlog.h:168:27: note: in instantiation of function template specialization 'spdlog::logger::info<my_type>' requested here\r\n    default_logger_raw()->info(fmt, std::forward<Args>(args)...);\r\n                          ^\r\n/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/example/example.cpp:289:39: note: in instantiation of function template specialization 'spdlog::info<my_type>' requested here\r\nvoid user_defined_example() { spdlog::info(\"user defined type: {}\", my_type(14)); }\r\n                                      ^\r\n/home/ports/pobj/spdlog-1.14.1/spdlog-1.14.1/example/example.cpp:275:10: note: 'format' declared here\r\n    auto format(my_type my, format_context &ctx) -> decltype(ctx.out()) {\r\n         ^\r\n1 error generated.\r\n```\n", "hints_text": "Duplicate https://github.com/gabime/spdlog/issues/3115#issuecomment-2180863072\r\n\r\nPRs to make the example code work with the latest fmt would be welcome.\r\nOr skip building example with CMake variable `-DSPDLOG_BUILD_EXAMPLE=OFF`.\n> Duplicate [#3115 (comment)](https://github.com/gabime/spdlog/issues/3115#issuecomment-2180863072)\r\n> \r\n> PRs to make the example code work with the latest fmt would be welcome. Or skip building example with CMake variable `-DSPDLOG_BUILD_EXAMPLE=OFF`.\r\n\r\nThanks. I'll use that for our package anyway.", "created_at": "2024-07-08T19:59:49Z"}
{"repo": "gabime/spdlog", "pull_number": 3044, "instance_id": "gabime__spdlog-3044", "issue_numbers": ["3038"], "base_commit": "d03eb40c179db937d69f40b831c23f8dea7eabb5", "patch": "diff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -439,7 +439,7 @@ SPDLOG_INLINE bool in_terminal(FILE *file) SPDLOG_NOEXCEPT {\n \n #if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n SPDLOG_INLINE void wstr_to_utf8buf(wstring_view_t wstr, memory_buf_t &target) {\n-    if (wstr.size() > static_cast<size_t>((std::numeric_limits<int>::max)()) / 2 - 1) {\n+    if (wstr.size() > static_cast<size_t>((std::numeric_limits<int>::max)()) / 4 - 1) {\n         throw_spdlog_ex(\"UTF-16 string is too big to be converted to UTF-8\");\n     }\n \n@@ -450,7 +450,7 @@ SPDLOG_INLINE void wstr_to_utf8buf(wstring_view_t wstr, memory_buf_t &target) {\n     }\n \n     int result_size = static_cast<int>(target.capacity());\n-    if ((wstr_size + 1) * 2 > result_size) {\n+    if ((wstr_size + 1) * 4 > result_size) {\n         result_size =\n             ::WideCharToMultiByte(CP_UTF8, 0, wstr.data(), wstr_size, NULL, 0, NULL, NULL);\n     }\n", "test_patch": "", "problem_statement": "wstr_to_utf8buf throw exception\nIn \"wstr_to_utf8buf\" function, memory_buf_t 's size is a const value of 250, (wstr_size+1)*2 is less than 250, so there is no resizing of the result_size. In next WideCharToMultiByte call, this step went wrong.The last error is ERROR_INSUFFICIENT_BUFFER(122)(0x7A).\r\nMy test string is\"OnPlayerStateChanged:state not changed \u30081\u3009\u53f6\u5fc3\u97f3\u7684\u7236\u4eb2\u906d\u4eba\u9677\u5bb3\u5165\u72f1\uff0c\u7537\u53cb\u4e0d\u6551\u53cd\u800c\u51fa\u56fd\uff0c\u53cd\u800c\u88ab\u4ed6\u5f1f\u5f1f\u9646\u666f\u9704\u6551\u4e0b\u3002\u53ef\u5979\u4e0d\u77e5\u9053\u5c31\u662f\u7537\u53cb\u9677\u5bb3\u7684\u7236\u4eb2\uff0c\u800c\u81ea\u5df1\u5374\u5df2\u7ecf\u7231\u4e0a\u7537\u53cb\u7684\u5f1f\u5f1f\uff01\u300a\u603b\u88c1\u7684\u91d1\u4e1d\u96c0\u300b,2,1\", and can reproduce of this issue. \r\n\r\n![wstr_to_utf8buf](https://github.com/gabime/spdlog/assets/72930792/f486283b-3216-4b05-92f6-bab9920da012)\r\n\r\n\r\n\n", "hints_text": "PR is welcome.", "created_at": "2024-03-19T08:43:15Z"}
{"repo": "gabime/spdlog", "pull_number": 2978, "instance_id": "gabime__spdlog-2978", "issue_numbers": ["2977"], "base_commit": "7c02e204c92545f869e2f04edaab1f19fe8b19fd", "patch": "diff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -177,12 +177,12 @@ SPDLOG_INLINE int rename(const filename_t &filename1, const filename_t &filename\n // Return true if path exists (file or directory)\n SPDLOG_INLINE bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT {\n #ifdef _WIN32\n+    struct _stat buffer;\n     #ifdef SPDLOG_WCHAR_FILENAMES\n-    auto attribs = ::GetFileAttributesW(filename.c_str());\n+    return (::_wstat(filename.c_str(), &buffer) == 0);\n     #else\n-    auto attribs = ::GetFileAttributesA(filename.c_str());\n+    return (::_stat(filename.c_str(), &buffer) == 0);\n     #endif\n-    return attribs != INVALID_FILE_ATTRIBUTES;\n #else  // common linux/unix all have the stat system call\n     struct stat buffer;\n     return (::stat(filename.c_str(), &buffer) == 0);\n", "test_patch": "", "problem_statement": "details::os::path_exists(const std::string&) doesn't handle UTF8 filename correctly under Windows\nMy application must support both Windows and Linux, so every path and filename inside the app is encoded UTF8 with std::string, and WCHAR is not used (SPDLOG_WCHAR_FILENAMES is not enabled).\r\n\r\n But under Windows (code taken from the latest spdlog 1.13.0):\r\n```\r\nSPDLOG_INLINE bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT {\r\n#ifdef _WIN32\r\n    #ifdef SPDLOG_WCHAR_FILENAMES\r\n    auto attribs = ::GetFileAttributesW(filename.c_str());\r\n    #else\r\n    auto attribs = ::GetFileAttributesA(filename.c_str());\r\n    #endif\r\n    return attribs != INVALID_FILE_ATTRIBUTES;\r\n#else  // common linux/unix all have the stat system call\r\n```\r\n```GetFileAttributesA()``` will use CP_ACP (the default system code page) not CP_UTF8, which will fail if the path contains UTF8-encoded non-ascii characters.\r\nMy current work around for this issue is:\r\n```\r\nSPDLOG_INLINE bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT {\r\n    std::error_code ec;\r\n    return std::filesystem::exists(filename, ec);\r\n}\r\n```\r\nBut I know std::filesystem requires C++17, so it doesn't count as a general solution for spdlog.\r\n\r\nNote for the above code to work under Windows, we need to call\r\n```setlocale(LC_ALL, \".UTF8\")```\r\nat the beginning of the app (https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/setlocale-wsetlocale?view=msvc-170#utf-8-support), so that ```std::filesystem::path``` will treat the pathname as UTF8 encoded string.\r\n\r\nI just open this issue for discussion, still looking for a more general solution. Thanks.\r\n\n", "hints_text": "It turns out removing the ```#ifdef _WIN32``` branch solves the problem perfectly, which leaves:\r\n```\r\n// Return true if path exists (file or directory)\r\nSPDLOG_INLINE bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT {\r\n    struct stat buffer;\r\n    return (::stat(filename.c_str(), &buffer) == 0);\r\n}\r\n```\r\nBecause MSVC also support ```stat()``` function.\r\n\r\nIf ```setlocale(LC_ALL, \".UTF8\")``` is called before doing ```stat()```, the filename will automatically be treated as UTF8 string.\nThe character encoding of `char*` is not specified in C/C++.\r\nEven if `stat()` can be called on Windows, there is no guarantee that other functions that take `char*` in UTF-8 encoding as an argument will work correctly.\r\n\r\nIf you know that the character encoding of `char*` is UTF-8, it is the developer's responsibility to convert it to the character encoding required by the execution environment.\r\n`SPDLOG_WCHAR_FILENAMES` is one way to do this.\n```path_exits()``` is the only odd place that calls Windows API directly, and all other places in os-inl.h just call C runtime functions, such as ```_fsopen()```, ```std::rename()```, ```::stat()```, etc.\r\n\r\nOn Windows as long as ```setlocale(LC_ALL, \".UTF8\")``` is called at the beginning of the app code, all these C runtime functions will treat ```char*``` as UTF8 strings.  These additional layers of indirection via C runtime over Windows API provide a much better way out of the dilemma of choosing SPDLOG_WCHAR_FILENAMES or not.\r\n\r\nSPDLOG_WCHAR_FILENAMES is not an option for me. For cross-platform development, this setup (every string is UTF8, avoid ```std::wstring``` completely) is becoming more and more prevalent.\r\n\r\nIf we can remove the only odd place in ```path_exists()```, it would make UTF8 handling under Windows without SPDLOG_WCHAR_FILENAMES much more smoothly.\r\n\r\nThanks.\nIn my opinion, this solves the issue completely:\r\n```\r\n// Return true if path exists (file or directory)\r\nSPDLOG_INLINE bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT {\r\n#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)\r\n    auto attribs = ::GetFileAttributesW(filename.c_str());\r\n    return attribs != INVALID_FILE_ATTRIBUTES;\r\n#else  // common linux/unix and Windows all have the stat system call\r\n    struct stat buffer;\r\n    return (::stat(filename.c_str(), &buffer) == 0);\r\n#endif\r\n}\r\n```\r\n1) On Windows with SPDLOG_WCHAR_FILENAMES, this goes to ```GetFileAttributesW()``` without any problem.\r\n2) On Windows with ```setlocale(LC_ALL, \".UTF8\")```, the filename will be treated like UTF8 string, which is what we want exactly.\r\n3) On Windows without ```setlocale(LC_ALL, \".UTF8\")```, the filename will be treated with the current code page, which will be the same effect as the old ```GetFileAttributesA()``` code path.\r\n\nI can find `_stat()` in MSDN, but not `stat()`.\r\nIs it really supported on Windows OS?\nWell, I think so. There's an ```stat.h``` in my Windows SDK, and it says:\r\n```\r\n        static __inline int __CRTDECL stat(char const* const _FileName, struct stat* const _Stat)\r\n        {\r\n            _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat64i32));\r\n            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);\r\n        }\r\n```\r\nJust wrapping around some _statxxx function.\nYou can send a pull request, but I am not sure if it will be accepted if you are using an API that is not officially documented.\nHow about this one:\r\n```\r\n// Return true if path exists (file or directory)\r\nSPDLOG_INLINE bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT {\r\n#ifdef _WIN32\r\n    struct _stat64i32 buffer;\r\n    #ifdef SPDLOG_WCHAR_FILENAMES\r\n    return (::_wstat64i32(filename.c_str(), &buffer) == 0);\r\n    #else\r\n    return (::_stat64i32(filename.c_str(), &buffer) == 0);\r\n    #endif\r\n#else  // common linux/unix all have the stat system call\r\n    struct stat buffer;\r\n    return (::stat(filename.c_str(), &buffer) == 0);\r\n#endif\r\n}\r\n```\r\nNeed your opinion before sending the PR.\r\nThanks.\r\n\nLooking at the MSDN (https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/stat-functions?view=msvc-170#time-type-and-file-length-type-variations-of-_stat), the size of the time data and file data differs depending on `_statXXX`.\r\nWill `_stat64i32` (`_wstat64i32`) work correctly on 32bit Windows?\r\n\r\n\nYes, I think so.\r\n\r\nI currently don't have a pure 32bit Windows (I don't think anyone has these days), but I can compile it to x86 mode and run as 32bit process without any problem.\nIf it works, then there is no problem.\r\nPlease send me a PR.\r\nHowever, @gabime is the last person to review and merge.\nOK, thank you very much.\nFor your information.\r\n\r\nI just remembered that I used `std::filesystem::u8path()` when I encountered a similar problem in the past.\r\n`std::filesystem::path::string()` returns a `std::string` character encoding that can be passed to the OS API. This is used for cross-platform support.\r\n\r\n```cpp\r\nstd::string file_path = \"/path/to/file\";\r\n#ifdef _WIN32\r\nfile_path = std::filesystem::u8path(file_path.c_str()).string();\r\n#endif\r\n```\r\n\r\nThis could be a workaround if the PR is not merged.\r\n\r\nHowever, `std::filesystem::u8path()` is deprecated in C++20 because `char8_t` was added in C++20.\nThank you, this is very helpful!\n\nWhat could I use if I happens to compile to C++20?\nIt also works with C++20.\r\nPerhaps `std::filesystem::u8path()` will be removed in a future C++.\r\n\nMaybe std::filesystem::path(reinterpret_cast<const char8_t*>(\"utf8/encoded/path\")) is the new preferred way to do the same as std::filesystem::u8path()?\nIn C++20, yes.\r\nHowever, `reinterpret_cast<const char8_t*>(const char *)` is not safe in C++20.\r\nSee the following link\r\n\r\n- [c\\+\\+ \\- How to safely convert const char\\* to const char8\\_t\\* in C\\+\\+20? \\- Stack Overflow](https://stackoverflow.com/questions/57603013/how-to-safely-convert-const-char-to-const-char8-t-in-c20)\r\n- [c\\+\\+ \\- Is C\\+\\+20 'char8\\_t' the same as our old 'char'? \\- Stack Overflow](https://stackoverflow.com/questions/57402464/is-c20-char8-t-the-same-as-our-old-char/57453713#57453713)", "created_at": "2024-01-13T08:57:39Z"}
{"repo": "gabime/spdlog", "pull_number": 2923, "instance_id": "gabime__spdlog-2923", "issue_numbers": ["2922"], "base_commit": "8b331e2cd18ab102415bcee7339d70228fd8a412", "patch": "diff --git a/include/spdlog/fmt/chrono.h b/include/spdlog/fmt/chrono.h\n--- a/include/spdlog/fmt/chrono.h\n+++ b/include/spdlog/fmt/chrono.h\n@@ -7,6 +7,7 @@\n //\n // include bundled or external copy of fmtlib's chrono support\n //\n+#include <spdlog/tweakme.h>\n \n #if !defined(SPDLOG_USE_STD_FORMAT)\n     #if !defined(SPDLOG_FMT_EXTERNAL)\ndiff --git a/include/spdlog/fmt/compile.h b/include/spdlog/fmt/compile.h\n--- a/include/spdlog/fmt/compile.h\n+++ b/include/spdlog/fmt/compile.h\n@@ -7,6 +7,7 @@\n //\n // include bundled or external copy of fmtlib's compile-time support\n //\n+#include <spdlog/tweakme.h>\n \n #if !defined(SPDLOG_USE_STD_FORMAT)\n     #if !defined(SPDLOG_FMT_EXTERNAL)\ndiff --git a/include/spdlog/fmt/fmt.h b/include/spdlog/fmt/fmt.h\n--- a/include/spdlog/fmt/fmt.h\n+++ b/include/spdlog/fmt/fmt.h\n@@ -9,6 +9,7 @@\n // Include a bundled header-only copy of fmtlib or an external one.\n // By default spdlog include its own copy.\n //\n+#include <spdlog/tweakme.h>\n \n #if defined(SPDLOG_USE_STD_FORMAT)  // SPDLOG_USE_STD_FORMAT is defined - use std::format\n     #include <format>\ndiff --git a/include/spdlog/fmt/ostr.h b/include/spdlog/fmt/ostr.h\n--- a/include/spdlog/fmt/ostr.h\n+++ b/include/spdlog/fmt/ostr.h\n@@ -7,6 +7,7 @@\n //\n // include bundled or external copy of fmtlib's ostream support\n //\n+#include <spdlog/tweakme.h>\n \n #if !defined(SPDLOG_USE_STD_FORMAT)\n     #if !defined(SPDLOG_FMT_EXTERNAL)\ndiff --git a/include/spdlog/fmt/ranges.h b/include/spdlog/fmt/ranges.h\n--- a/include/spdlog/fmt/ranges.h\n+++ b/include/spdlog/fmt/ranges.h\n@@ -7,6 +7,7 @@\n //\n // include bundled or external copy of fmtlib's ranges support\n //\n+#include <spdlog/tweakme.h>\n \n #if !defined(SPDLOG_USE_STD_FORMAT)\n     #if !defined(SPDLOG_FMT_EXTERNAL)\ndiff --git a/include/spdlog/fmt/std.h b/include/spdlog/fmt/std.h\n--- a/include/spdlog/fmt/std.h\n+++ b/include/spdlog/fmt/std.h\n@@ -8,6 +8,7 @@\n // include bundled or external copy of fmtlib's std support (for formatting e.g.\n // std::filesystem::path, std::thread::id, std::monostate, std::variant, ...)\n //\n+#include <spdlog/tweakme.h>\n \n #if !defined(SPDLOG_USE_STD_FORMAT)\n     #if !defined(SPDLOG_FMT_EXTERNAL)\ndiff --git a/include/spdlog/fmt/xchar.h b/include/spdlog/fmt/xchar.h\n--- a/include/spdlog/fmt/xchar.h\n+++ b/include/spdlog/fmt/xchar.h\n@@ -7,6 +7,7 @@\n //\n // include bundled or external copy of fmtlib's xchar support\n //\n+#include <spdlog/tweakme.h>\n \n #if !defined(SPDLOG_USE_STD_FORMAT)\n     #if !defined(SPDLOG_FMT_EXTERNAL)\n", "test_patch": "", "problem_statement": "fmt/*.h needs to #include <spdlog/tweakme.h> to set `SPDLOG_FMT_EXTERNAL` correctly\nExperiencing build [failures on](https://github.com/gnuradio/gnuradio/issues/6927) machines where tweakme.h set `SPDLOG_FMT_EXTERNAL` when we \r\n\r\n```C++\r\n#include <spdlog/fmt/fmt.h>\r\n```\r\n\r\nin header files which do not otherwise include spdlog before.\r\n\r\nThe reason is simple: \r\n\r\nspdlog/fmt/fmt.h checks for `SPDLOG_FMT_EXTERNAL` to select whether to include the bundled or the system FMT header.\r\n\r\nWithout tweakme.h being included there, this goes wrong, like in https://github.com/gnuradio/gnuradio/issues/6927, where we [simply include `spdlog/fmt/fmt.h`](https://github.com/gnuradio/gnuradio/blob/5eee613e70ff12a02c9d8d1302f8ff29bcd95df3/gnuradio-runtime/include/gnuradio/io_signature.h#L16) in order to define a formatter, without including the whole of spdlog in a public header (which would potentially have wonderful API effects)\n", "hints_text": "", "created_at": "2023-10-24T11:03:18Z"}
{"repo": "gabime/spdlog", "pull_number": 2901, "instance_id": "gabime__spdlog-2901", "issue_numbers": ["2856"], "base_commit": "508d20f0facf33b104f42849c29149041d2324c6", "patch": "diff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -65,14 +65,23 @@\n #if defined(_MSC_VER) && (_MSC_VER < 1900)\n     #define SPDLOG_NOEXCEPT _NOEXCEPT\n     #define SPDLOG_CONSTEXPR\n-    #define SPDLOG_CONSTEXPR_FUNC inline\n #else\n     #define SPDLOG_NOEXCEPT noexcept\n     #define SPDLOG_CONSTEXPR constexpr\n-    #if __cplusplus >= 201402L\n-        #define SPDLOG_CONSTEXPR_FUNC constexpr\n+#endif\n+\n+// If building with std::format, can just use constexpr, otherwise if building with fmt\n+// SPDLOG_CONSTEXPR_FUNC needs to be set the same as FMT_CONSTEXPR to avoid situations where\n+// a constexpr function in spdlog could end up calling a non-constexpr function in fmt\n+// depending on the compiler\n+// If fmt determines it can't use constexpr, we should inline the function instead\n+#ifdef SPDLOG_USE_STD_FORMAT\n+    #define SPDLOG_CONSTEXPR_FUNC constexpr\n+#else  // Being built with fmt\n+    #if FMT_USE_CONSTEXPR\n+        #define SPDLOG_CONSTEXPR_FUNC FMT_CONSTEXPR\n     #else\n-        #define SPDLOG_CONSTEXPR_FUNC inline\n+\t#define SPDLOG_CONSTEXPR_FUNC inline\n     #endif\n #endif\n \n", "test_patch": "", "problem_statement": "Different use_constexpr definitions in spdlog and fmt causes compile time error in NVCC (and possibly other compilers)\n# Description\r\nWhen calling `logger.trace()` in an .cu file compiled using nvcc, I get the following compile time error:\r\n~~~\r\nspdlog/common.h:351:30: error: call to non-\u2018constexpr\u2019 function \u2018const T* fmt::v9::detail::buffer<T>::data() const [with T = char]\u2019\r\n  351 |     return spdlog::string_view_t{buf.data(), buf.size()};\r\n      |                      ~~~~~~~~^~\r\n~~~\r\n\r\n# Cause\r\nThe [to_string_view](https://github.com/gabime/spdlog/blob/cedfeeb95f3af11df7d3b1e7e0d3b86b334dc23b/include/spdlog/common.h#L349) utility function is declared as [SPDLOG_CONSTEXPR_FUNC](https://github.com/gabime/spdlog/blob/cedfeeb95f3af11df7d3b1e7e0d3b86b334dc23b/include/spdlog/common.h#L72C19-L72C19). The functions calls [fmt::v9::detail::buffer<T>::data()](https://github.com/gabime/spdlog/blob/cedfeeb95f3af11df7d3b1e7e0d3b86b334dc23b/include/spdlog/fmt/bundled/core.h#L911) which is declared as [FMT_CONSTEXPR](https://github.com/gabime/spdlog/blob/cedfeeb95f3af11df7d3b1e7e0d3b86b334dc23b/include/spdlog/fmt/bundled/core.h#L95). However, FMT_CONSTEXPR has different conditions than SPDLOG_CONSTEXPR_FUNC and is defined to be empty for NVCC, leading to the data() function not declared as constexpr and thus causing the error.\r\n\r\n# Fix\r\nAdding the [same condition](https://github.com/gabime/spdlog/blob/cedfeeb95f3af11df7d3b1e7e0d3b86b334dc23b/include/spdlog/fmt/bundled/core.h#L95) to the definition of SPDLOG_CONSTEXPR_FUNC fixes the error. However, the two definitions need to be kept in sync in future changes.\r\n\r\nAnother potential fix is to declare the to_string_view functions as inline instead of constexpr.\n", "hints_text": "PR is welcome.\nWhich version of spdlog?\nThis is introduced in [commit 4f800773](https://github.com/gabime/spdlog/commit/4f800773393d3ebac13c1fcd946a315d4d72bcd9) and is included in v1.12.0 and in the current v1.x branch.", "created_at": "2023-10-11T20:25:29Z"}
{"repo": "gabime/spdlog", "pull_number": 2846, "instance_id": "gabime__spdlog-2846", "issue_numbers": ["2678"], "base_commit": "811bc4c7a9a4b192c6fa59109476e214f0eb50c0", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -344,7 +344,7 @@ if(SPDLOG_INSTALL)\n     # ---------------------------------------------------------------------------------------\n     # Install CMake config files\n     # ---------------------------------------------------------------------------------------\n-    export(TARGETS spdlog NAMESPACE spdlog:: FILE \"${CMAKE_CURRENT_BINARY_DIR}/${config_targets_file}\")\n+    export(TARGETS spdlog spdlog_header_only NAMESPACE spdlog:: FILE \"${CMAKE_CURRENT_BINARY_DIR}/${config_targets_file}\")\n     install(EXPORT spdlog DESTINATION ${export_dest_dir} NAMESPACE spdlog:: FILE ${config_targets_file})\n \n     include(CMakePackageConfigHelpers)\n", "test_patch": "", "problem_statement": "CMake: Build directory `spdlogConfigTargets.cmake` doesn't provide a `spdlog::spdlog_header_only` target\nThe installed version of `spdlogConfigTargets.cmake` includes both the `spdlog::spdlog` and `spdlog::spdlog_header_only` targets. The build directory version only provides the compiled library target, which causes issues for dowstream consumers of the header only version.\r\n\r\nThis is caused by a mismatch between what targets are exported via the `install` and `export` commands.\r\nUpdating line https://github.com/gabime/spdlog/blob/v1.x/CMakeLists.txt#L339 to also include spdlog_header_only would fix this issue.\n", "hints_text": "In addition by not exporting the `spdlog_header_only` target it means that any downstream user that uses spdlog from source can't export a dependency that has a public dependency on `spdlog_header_only`\r\n\r\n```cmake\r\n  export called with target \"use_spdlog\" which requires target \"spdlog_header_only\"\r\n  that is not in any export set.\r\n```\n@robertmaynard Thanks for reporting. PR to fix this would be most welcome.\n@robertmaynard Any chance you send PR for this before next release (few days)?", "created_at": "2023-08-07T14:36:44Z"}
{"repo": "gabime/spdlog", "pull_number": 2736, "instance_id": "gabime__spdlog-2736", "issue_numbers": ["2735"], "base_commit": "57a9fd0841f00e92b478a07fef62636d7be612a8", "patch": "diff --git a/include/spdlog/sinks/daily_file_sink.h b/include/spdlog/sinks/daily_file_sink.h\n--- a/include/spdlog/sinks/daily_file_sink.h\n+++ b/include/spdlog/sinks/daily_file_sink.h\n@@ -13,6 +13,9 @@\n #include <spdlog/details/circular_q.h>\n #include <spdlog/details/synchronous_factory.h>\n \n+#include <iostream>\n+#include <sstream>\n+#include <iomanip>\n #include <chrono>\n #include <cstdio>\n #include <ctime>\n@@ -46,46 +49,15 @@ struct daily_filename_calculator\n  */\n struct daily_filename_format_calculator\n {\n-    static filename_t calc_filename(const filename_t &filename, const tm &now_tm)\n+    static filename_t calc_filename(const filename_t &file_path, const tm &now_tm)\n     {\n-#ifdef SPDLOG_USE_STD_FORMAT\n-        // adapted from fmtlib: https://github.com/fmtlib/fmt/blob/8.0.1/include/fmt/chrono.h#L522-L546\n-\n-        filename_t tm_format;\n-        tm_format.append(filename);\n-        // By appending an extra space we can distinguish an empty result that\n-        // indicates insufficient buffer size from a guaranteed non-empty result\n-        // https://github.com/fmtlib/fmt/issues/2238\n-        tm_format.push_back(' ');\n-\n-        const size_t MIN_SIZE = 10;\n-        filename_t buf;\n-        buf.resize(MIN_SIZE);\n-        for (;;)\n-        {\n-            size_t count = strftime(buf.data(), buf.size(), tm_format.c_str(), &now_tm);\n-            if (count != 0)\n-            {\n-                // Remove the extra space.\n-                buf.resize(count - 1);\n-                break;\n-            }\n-            buf.resize(buf.size() * 2);\n-        }\n-\n-        return buf;\n+#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)\n+      std::wstringstream stream;  \n #else\n-        // generate fmt datetime format string, e.g. {:%Y-%m-%d}.\n-        filename_t fmt_filename = fmt::format(SPDLOG_FMT_STRING(SPDLOG_FILENAME_T(\"{{:{}}}\")), filename);\n-\n-        // MSVC doesn't allow fmt::runtime(..) with wchar, with fmtlib versions < 9.1.x\n-#    if defined(_MSC_VER) && defined(SPDLOG_WCHAR_FILENAMES) && FMT_VERSION < 90101\n-        return fmt::format(fmt_filename, now_tm);\n-#    else\n-        return fmt::format(SPDLOG_FMT_RUNTIME(fmt_filename), now_tm);\n-#    endif\n-\n+      std::stringstream stream;\n #endif\n+      stream << std::put_time(&now_tm, file_path.c_str()); \n+      return stream.str();\n     }\n \n private:\n", "test_patch": "", "problem_statement": "spdlog 1.11.0 with fmt 1.10.0 has test_daily_logger:126 failing\nI am using stable spdlog 1.11.0 with stable fmt 10.0.0. To make it work I've added patch 0ca574ae168820da0268b3ec7607ca7b33024d05. The compilation now works, but the test unit [test_daily_logger](https://github.com/gabime/spdlog/blob/v1.x/tests/test_daily_logger.cpp#L126) now fails on me.\r\n\r\n```\r\n[   23s] daily_file_sink::daily_filename_format_calculator\r\n[   23s] -------------------------------------------------------------------------------\r\n[   23s] /home/abuild/rpmbuild/BUILD/spdlog-1.11.0/tests/test_daily_logger.cpp:126\r\n[   23s] ...............................................................................\r\n[   23s] \r\n[   23s] /home/abuild/rpmbuild/BUILD/spdlog-1.11.0/tests/test_daily_logger.cpp:126: FAILED:\r\n[   23s] due to unexpected exception with message:\r\n[   23s]   invalid format\r\n```\r\n\r\nHas anyone any insight, what might have changed here due to the patch? If I build spdlog with the bundled fmt it works.\r\n\n", "hints_text": "I've patched the double brackets out now, for example the test_daily_logger:\r\n\r\nhttps://github.com/gabime/spdlog/blob/ad0e89cbfb4d0c1ce4d097e134eb7be67baebb36/tests/test_daily_logger.cpp#L126 \r\n\r\nvs \r\n\r\nhttps://github.com/gabime/spdlog/blob/57a9fd0841f00e92b478a07fef62636d7be612a8/tests/test_daily_logger.cpp#L126\r\n\r\nbut the test still fails. Has anyone a hint on what could be the problem here?\r\n\n> [   23s] /home/abuild/rpmbuild/BUILD/spdlog-1.11.0/tests/test_daily_logger.cpp:126: FAILED:\r\n> [   23s] due to unexpected exception with message:\r\n> [   23s]   invalid format\r\n\r\nIt appears that the following line failed to format.\r\n\r\nhttps://github.com/gabime/spdlog/blob/57a9fd0841f00e92b478a07fef62636d7be612a8/tests/test_daily_logger.cpp#L132-L133\r\n\r\nHowever, I could not figure out why this formatting started to fail in fmt 10.\nAre we sure this exception comes from fmt ?\n@tt4g does it fail for you as well? or is the problem \"only\" in the opensuse-factory builds?\r\n\r\n@gabime When I switch to embedded fmt (9.x) it works. Also the build worked before the fmt 1.10 release.\r\n\nTried to reproduce with Godbolt, but the same problem did not occur.\nMay be related fmtlib/fmt#3440.\nI could reproduce it outside of openSUSE factory with spdlog 1.11.0 and fmt 1.10.0. The offending line is:\r\n\r\nhttps://github.com/gabime/spdlog/blob/ad0e89cbfb4d0c1ce4d097e134eb7be67baebb36/tests/test_daily_logger.cpp#L130\r\n\r\nif i exchange it with a otherwise defined filename, the test is executed.\r\n\nFrom that line, I examined the likely source of the error and found that the following source code violates the fmt format specification.\r\n\r\nhttps://github.com/gabime/spdlog/blob/57a9fd0841f00e92b478a07fef62636d7be612a8/include/spdlog/sinks/daily_file_sink.h#L78-L86\r\n\r\nI expect the behavior of fmt version 9.1.0 and earlier was unintended. I have opened an issue (fmtlib/fmt#3445) in the fmt library for confirmation.\r\n\r\n@commel If you make the following modifications, all should be well. Could you try it?\r\n\r\n```diff\r\n struct daily_filename_format_calculator\r\n {\r\n     static filename_t calc_filename(const filename_t &filename, const tm &now_tm)\r\n     {\r\n-#ifdef SPDLOG_USE_STD_FORMAT\r\n         // adapted from fmtlib: https://github.com/fmtlib/fmt/blob/8.0.1/include/fmt/chrono.h#L522-L546\r\n \r\n         filename_t tm_format;\r\n         tm_format.append(filename);\r\n         // By appending an extra space we can distinguish an empty result that\r\n         // indicates insufficient buffer size from a guaranteed non-empty result\r\n         // https://github.com/fmtlib/fmt/issues/2238\r\n         tm_format.push_back(' ');\r\n \r\n         const size_t MIN_SIZE = 10;\r\n         filename_t buf;\r\n         buf.resize(MIN_SIZE);\r\n         for (;;)\r\n         {\r\n             size_t count = strftime(buf.data(), buf.size(), tm_format.c_str(), &now_tm);\r\n             if (count != 0)\r\n             {\r\n                 // Remove the extra space.\r\n                 buf.resize(count - 1);\r\n                 break;\r\n             }\r\n             buf.resize(buf.size() * 2);\r\n         }\r\n \r\n         return buf;\r\n-#else\r\n-        // generate fmt datetime format string, e.g. {:%Y-%m-%d}.\r\n-        filename_t fmt_filename = fmt::format(SPDLOG_FMT_STRING(SPDLOG_FILENAME_T(\"{{:{}}}\")), filename);\r\n-\r\n-        // MSVC doesn't allow fmt::runtime(..) with wchar, with fmtlib versions < 9.1.x\r\n-#    if defined(_MSC_VER) && defined(SPDLOG_WCHAR_FILENAMES) && FMT_VERSION < 90101\r\n-        return fmt::format(fmt_filename, now_tm);\r\n-#    else\r\n-        return fmt::format(SPDLOG_FMT_RUNTIME(fmt_filename), now_tm);\r\n-#    endif\r\n-\r\n-#endif\r\n     }\r\n```\n@tt4g Thanks for the investigation. \r\nSo the fix would be replacing\r\n\u201cexample-%Y-%m-%d.log\u201d\r\nwith:\r\n\u201cexample_%Y-%m-%d.log\" ? or shoiuld it be \u201c%Y-%m-%d.log\u201d ?\nJust had the chance to look at it. At the moment the strftime is not working because the string.data() is const.\nWith the applied patch 0ca574ae168820da0268b3ec7607ca7b33024d05.patch, the removed double brackets ``]]`` from some tests from 7f09c88817dac6142202b7f2c56193c8e90381f6 and the applied change from above the tests now work :-)\r\n\r\nThe adapted diffed version of daily_file_sink.h now looks like this:\r\n\r\n```diff\r\nindex f6f1bb1d..31516ee2 100644\r\n--- a/include/spdlog/sinks/daily_file_sink.h\r\n+++ b/include/spdlog/sinks/daily_file_sink.h\r\n@@ -18,6 +18,7 @@\r\n #include <ctime>\r\n #include <mutex>\r\n #include <string>\r\n+#include <vector>\r\n \r\n namespace spdlog {\r\n namespace sinks {\r\n@@ -48,7 +49,6 @@ struct daily_filename_format_calculator\r\n {\r\n     static filename_t calc_filename(const filename_t &filename, const tm &now_tm)\r\n     {\r\n-#ifdef SPDLOG_USE_STD_FORMAT\r\n         // adapted from fmtlib: https://github.com/fmtlib/fmt/blob/8.0.1/include/fmt/chrono.h#L522-L546\r\n \r\n         filename_t tm_format;\r\n@@ -59,7 +59,7 @@ struct daily_filename_format_calculator\r\n         tm_format.push_back(' ');\r\n \r\n         const size_t MIN_SIZE = 10;\r\n-        filename_t buf;\r\n+        std::vector<char> buf;\r\n         buf.resize(MIN_SIZE);\r\n         for (;;)\r\n         {\r\n@@ -73,19 +73,7 @@ struct daily_filename_format_calculator\r\n             buf.resize(buf.size() * 2);\r\n         }\r\n \r\n-        return buf;\r\n-#else\r\n-        // generate fmt datetime format string, e.g. {:%Y-%m-%d}.\r\n-        filename_t fmt_filename = fmt::format(SPDLOG_FMT_STRING(SPDLOG_FILENAME_T(\"{{:{}}}\")), filename);\r\n-\r\n-        // MSVC doesn't allow fmt::runtime(..) with wchar, with fmtlib versions < 9.1.x\r\n-#    if defined(_MSC_VER) && defined(SPDLOG_WCHAR_FILENAMES) && FMT_VERSION < 90101\r\n-        return fmt::format(fmt_filename, now_tm);\r\n-#    else\r\n-        return fmt::format(SPDLOG_FMT_RUNTIME(fmt_filename), now_tm);\r\n-#    endif\r\n-\r\n-#endif\r\n+        return std::string(buf.cbegin(), buf.cend());\r\n     }\r\n \r\n private:\r\n```\r\n\r\nstd::string.data() and std::string.c_str() are both const char*, so I improvised for a std::vector.\nTrailing literals are allowed, so `%Y-%m-%d.log` works.\r\nHowever, @commel patch is required for compatibility.", "created_at": "2023-05-17T21:09:13Z"}
{"repo": "gabime/spdlog", "pull_number": 2694, "instance_id": "gabime__spdlog-2694", "issue_numbers": ["2693"], "base_commit": "069a2e8fc947f63855d770fdc3c3eb427f19988f", "patch": "diff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -173,12 +173,19 @@ using format_string_t = fmt::format_string<Args...>;\n template<class T>\n using remove_cvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n \n+template <typename Char>\n+#if FMT_VERSION >= 90101\n+using fmt_runtime_string = fmt::runtime_format_string<Char>;\n+#else\n+using fmt_runtime_string = fmt::basic_runtime<Char>;\n+#endif\n+\n // clang doesn't like SFINAE disabled constructor in std::is_convertible<> so have to repeat the condition from basic_format_string here,\n // in addition, fmt::basic_runtime<Char> is only convertible to basic_format_string<Char> but not basic_string_view<Char>\n template<class T, class Char = char>\n struct is_convertible_to_basic_format_string\n     : std::integral_constant<bool,\n-          std::is_convertible<T, fmt::basic_string_view<Char>>::value || std::is_same<remove_cvref_t<T>, fmt::basic_runtime<Char>>::value>\n+          std::is_convertible<T, fmt::basic_string_view<Char>>::value || std::is_same<remove_cvref_t<T>, fmt_runtime_string<Char>>::value>\n {};\n \n #    if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)\n", "test_patch": "", "problem_statement": "spdlog fails to build with latest fmt\nUsing latest fmt, the spdlog will fail to build.\r\n\r\nYou must change the **basic_runtime** to **runtime_format_string** to fix the issue, however bundled spdlog uses **basic_runtime.** Line: https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/common.h#L181\n", "hints_text": "PR is welcome.", "created_at": "2023-03-31T15:36:42Z"}
{"repo": "gabime/spdlog", "pull_number": 2588, "instance_id": "gabime__spdlog-2588", "issue_numbers": ["2587"], "base_commit": "edc51df1bdad8667b628999394a1e7c4dc6f3658", "patch": "diff --git a/include/spdlog/details/mpmc_blocking_q.h b/include/spdlog/details/mpmc_blocking_q.h\n--- a/include/spdlog/details/mpmc_blocking_q.h\n+++ b/include/spdlog/details/mpmc_blocking_q.h\n@@ -49,7 +49,7 @@ class mpmc_blocking_queue\n         push_cv_.notify_one();\n     }\n \n-    // try to dequeue item. if no item found. wait up to timeout and try again\n+    // dequeue with a timeout.\n     // Return true, if succeeded dequeue item, false otherwise\n     bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)\n     {\n@@ -66,6 +66,18 @@ class mpmc_blocking_queue\n         return true;\n     }\n \n+    // blocking dequeue without a timeout.\n+    void dequeue(T &popped_item)\n+    {\n+        {\n+            std::unique_lock<std::mutex> lock(queue_mutex_);\n+            push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n+            popped_item = std::move(q_.front());\n+            q_.pop_front();\n+        }\n+        pop_cv_.notify_one();\n+    }\n+\n #else\n     // apparently mingw deadlocks if the mutex is released before cv.notify_one(),\n     // so release the mutex at the very end each function.\n@@ -87,7 +99,7 @@ class mpmc_blocking_queue\n         push_cv_.notify_one();\n     }\n \n-    // try to dequeue item. if no item found. wait up to timeout and try again\n+    // dequeue with a timeout.\n     // Return true, if succeeded dequeue item, false otherwise\n     bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)\n     {\n@@ -102,6 +114,16 @@ class mpmc_blocking_queue\n         return true;\n     }\n \n+    // blocking dequeue without a timeout.\n+    void dequeue(T &popped_item)\n+    {\n+        std::unique_lock<std::mutex> lock(queue_mutex_);\n+        push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n+        popped_item = std::move(q_.front());\n+        q_.pop_front();\n+        pop_cv_.notify_one();\n+    }\n+\n #endif\n \n     size_t overrun_counter()\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -108,11 +108,7 @@ void SPDLOG_INLINE thread_pool::worker_loop_()\n bool SPDLOG_INLINE thread_pool::process_next_msg_()\n {\n     async_msg incoming_async_msg;\n-    bool dequeued = q_.dequeue_for(incoming_async_msg, std::chrono::seconds(10));\n-    if (!dequeued)\n-    {\n-        return true;\n-    }\n+    q_.dequeue(incoming_async_msg);\n \n     switch (incoming_async_msg.msg_type)\n     {\n", "test_patch": "diff --git a/tests/test_mpmc_q.cpp b/tests/test_mpmc_q.cpp\n--- a/tests/test_mpmc_q.cpp\n+++ b/tests/test_mpmc_q.cpp\n@@ -43,6 +43,26 @@ TEST_CASE(\"dequeue-empty-wait\", \"[mpmc_blocking_q]\")\n     REQUIRE(delta_ms <= wait_ms + tolerance_wait);\n }\n \n+TEST_CASE(\"dequeue-full-nowait\", \"[mpmc_blocking_q]\")\n+{\n+    spdlog::details::mpmc_blocking_queue<int> q(1);\n+    q.enqueue(42);\n+\n+    int item = 0;\n+    q.dequeue_for(item, milliseconds::zero());\n+    REQUIRE(item == 42);\n+}\n+\n+TEST_CASE(\"dequeue-full-wait\", \"[mpmc_blocking_q]\")\n+{\n+    spdlog::details::mpmc_blocking_queue<int> q(1);\n+    q.enqueue(42);\n+\n+    int item = 0;\n+    q.dequeue(item);\n+    REQUIRE(item == 42);\n+}\n+\n TEST_CASE(\"enqueue_nowait\", \"[mpmc_blocking_q]\")\n {\n \n@@ -95,12 +115,12 @@ TEST_CASE(\"full_queue\", \"[mpmc_blocking_q]\")\n     for (int i = 1; i < static_cast<int>(q_size); i++)\n     {\n         int item = -1;\n-        q.dequeue_for(item, milliseconds(0));\n+        q.dequeue(item);\n         REQUIRE(item == i);\n     }\n \n     // last item pushed has overridden the oldest.\n     int item = -1;\n-    q.dequeue_for(item, milliseconds(0));\n+    q.dequeue(item);\n     REQUIRE(item == 123456);\n }\n", "problem_statement": "tsan false warnings for mpmc_blocking_queue::dequeue_for\ngcc 11.3.0 on Ubuntu 22.04 reports \"data race\" and \"double lock of a mutex\" for `mpmc_blocking_queue::dequeue_for`\r\n\r\nThis is most probably due to this gcc bug - https://gcc.gnu.org/bugzilla//show_bug.cgi?id=101978\r\n\r\nReplacing timed [wait_for](https://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/mpmc_blocking_q.h#L58) with `std::condition_variable::wait` avoids the tsan warnings.\r\n\r\nThis of course should be fixed in gcc, but I am curious what is the reason for wait_for in the first place? Do you see any issues with replacing `wait_for` with `wait`?\n", "hints_text": "This is because `mpmc_blocking_queue` is designed as a queue for the Producer-Consumer pattern (as described at the top of the header file).\r\n\r\nhttps://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/mpmc_blocking_q.h#L6-L11\r\n\r\nMany developers may want to allow the Consumer thread to perform other tasks while there are no messages in the queue.\r\nIt is a commonplace idea to implement a dequeue (pop) API with a timeout on the queue for this purpose.\nThe `mpmc_blocking_queue` is only used in `thread_pool` though, where the consumer thread does not perform any idle task. It unnecessarily wakes up the thread every 10s only to go back to waiting for the next message - https://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/thread_pool-inl.h#L114\r\n\r\nIf there is a desire for `mpmc_blocking_queue` to be a generic producer-consumer queue, may be we could add another blocking non-timed `dequeue` and use that in `thread_pool`? Unless I am missing some other reason for the timeout?\nI did not develop `thread_pool` so I don't know why it uses `dequeue_for()`.\r\n\r\nIf you think wakeup every 10 seconds is useless, you can create a PR, but I personally don't see the need to change the current implementation for the purpose of avoiding the compiler sanitizer bug.", "created_at": "2022-12-29T22:59:33Z"}
{"repo": "gabime/spdlog", "pull_number": 2383, "instance_id": "gabime__spdlog-2383", "issue_numbers": ["2380"], "base_commit": "0d8197cc9d935e0c5116de551bec63cd35f3c0ef", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -298,6 +298,16 @@ if(SPDLOG_INSTALL)\n     # ---------------------------------------------------------------------------------------\n     # Install pkg-config file\n     # ---------------------------------------------------------------------------------------\n+    if (IS_ABSOLUTE \"${CMAKE_INSTALL_INCLUDEDIR}\")\n+        set(PKG_CONFIG_INCLUDEDIR \"${CMAKE_INSTALL_INCLUDEDIR}\")\n+    else()\n+        set(PKG_CONFIG_INCLUDEDIR \"\\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}\")\n+    endif()\n+    if (IS_ABSOLUTE \"${CMAKE_INSTALL_LIBDIR}\")\n+        set(PKG_CONFIG_LIBDIR \"${CMAKE_INSTALL_LIBDIR}\")\n+    else()\n+        set(PKG_CONFIG_LIBDIR \"\\${exec_prefix}/${CMAKE_INSTALL_LIBDIR}\")\n+    endif()\n     get_target_property(PKG_CONFIG_DEFINES spdlog INTERFACE_COMPILE_DEFINITIONS)\n     string(REPLACE \";\" \" -D\" PKG_CONFIG_DEFINES \"${PKG_CONFIG_DEFINES}\")\n     string(CONCAT PKG_CONFIG_DEFINES \"-D\" \"${PKG_CONFIG_DEFINES}\")\n", "test_patch": "", "problem_statement": "pkg-config file is broken when CMAKE_INSTALL_LIBDIR is absolute\nAs per title: `cmake/spdlog.pc.in` has (since https://github.com/gabime/spdlog/pull/1238)\r\n```\r\nprefix=@CMAKE_INSTALL_PREFIX@\r\nexec_prefix=${prefix}\r\nincludedir=${prefix}/include\r\nlibdir=${exec_prefix}/@CMAKE_INSTALL_LIBDIR@\r\n```\r\nand so can\u2019t handle absolute paths in `CMAKE_INSTALL_LIBDIR`. This leads to broken .pc files on NixOS in particular.\r\n\r\nSee \u201c[Concatenating paths when building pkg-config files](https://github.com/jtojnar/cmake-snips#concatenating-paths-when-building-pkg-config-files)\u201d for a thorough discussion of the problem and a suggested fix, or [KDE\u2019s extra-cmake-modules](https://invent.kde.org/frameworks/extra-cmake-modules/-/blob/master/modules/ECMGeneratePkgConfigFile.cmake#L166) for a simpler approach.\n", "hints_text": "Can you submit a PR to be fixed?", "created_at": "2022-05-19T14:59:48Z"}
{"repo": "gabime/spdlog", "pull_number": 2376, "instance_id": "gabime__spdlog-2376", "issue_numbers": ["2369"], "base_commit": "128cbe5a06051e0bc43d90c2434f7f68a2900587", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -169,7 +169,7 @@ target_include_directories(spdlog PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST\n target_link_libraries(spdlog PUBLIC Threads::Threads)\n spdlog_enable_warnings(spdlog)\n \n-set_target_properties(spdlog PROPERTIES VERSION ${SPDLOG_VERSION} SOVERSION ${SPDLOG_VERSION_MAJOR})\n+set_target_properties(spdlog PROPERTIES VERSION ${SPDLOG_VERSION} SOVERSION ${SPDLOG_VERSION_MAJOR}.${SPDLOG_VERSION_MINOR})\n set_target_properties(spdlog PROPERTIES DEBUG_POSTFIX d)\n \n if(COMMAND target_precompile_headers AND SPDLOG_ENABLE_PCH)\n", "test_patch": "", "problem_statement": "Unresolved symbols when moving to spdlog 1.10 without recompile - maybe full symbol\nThe cryfs package uses spdlog 1.8.x. openSUSE moved to spdlog 1.10. This resulted in unresolved symbols, because of a ABI break in one of the later commits: c47ae3b15dedc35cc62cc34ec1e411b040373776\r\n\r\nWould it be possible to include version symbols in the releases? Or somehow maintain backward compatibility?\r\n\r\nSee our bugreport: https://bugzilla.opensuse.org/show_bug.cgi?id=1199306#c0\n", "hints_text": "`SPDLOG_VERSION` macro is here:\r\n\r\nhttps://github.com/gabime/spdlog/blob/76fb40d95455f249bd70824ecfcae7a8f0930fa3/include/spdlog/version.h#L6-L10\nWhat's needed is to either increase the sover on each ABI incompatible release or introduce use of symbol versioning.\nThere is no documentation on ABI compatibility for spdlog, but I think spdlog has a policy of not guaranteeing ABI compatibility with minor version upgrades.\r\n@gabime Is this understanding correct?\nWe try not to break the ABI however it is certainly not guaranteed nor a top priority.", "created_at": "2022-05-13T07:51:03Z"}
{"repo": "gabime/spdlog", "pull_number": 2328, "instance_id": "gabime__spdlog-2328", "issue_numbers": ["2323"], "base_commit": "083ea59fbd06add6f973636acca93ae0dfc0b73f", "patch": "diff --git a/include/spdlog/sinks/systemd_sink.h b/include/spdlog/sinks/systemd_sink.h\n--- a/include/spdlog/sinks/systemd_sink.h\n+++ b/include/spdlog/sinks/systemd_sink.h\n@@ -23,8 +23,9 @@ template<typename Mutex>\n class systemd_sink : public base_sink<Mutex>\n {\n public:\n-    explicit systemd_sink(bool enable_formatting = false)\n-        : enable_formatting_{enable_formatting}\n+    systemd_sink(std::string ident = \"\", bool enable_formatting = false)\n+        : ident_{std::move(ident)}\n+        , enable_formatting_{enable_formatting}\n         , syslog_levels_{{/* spdlog::level::trace      */ LOG_DEBUG,\n               /* spdlog::level::debug      */ LOG_DEBUG,\n               /* spdlog::level::info       */ LOG_INFO,\n@@ -40,6 +41,7 @@ class systemd_sink : public base_sink<Mutex>\n     systemd_sink &operator=(const systemd_sink &) = delete;\n \n protected:\n+    const std::string ident_;\n     bool enable_formatting_ = false;\n     using levels_array = std::array<int, 7>;\n     levels_array syslog_levels_;\n@@ -66,17 +68,19 @@ class systemd_sink : public base_sink<Mutex>\n             length = static_cast<size_t>(std::numeric_limits<int>::max());\n         }\n \n+        const string_view_t syslog_identifier = ident_.empty() ? msg.logger_name : ident_;\n+\n         // Do not send source location if not available\n         if (msg.source.empty())\n         {\n             // Note: function call inside '()' to avoid macro expansion\n             err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n-                \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(msg.logger_name.size()), msg.logger_name.data(), nullptr);\n+                \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(syslog_identifier.size()), syslog_identifier.data(), nullptr);\n         }\n         else\n         {\n             err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n-                \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(msg.logger_name.size()), msg.logger_name.data(), \"CODE_FILE=%s\",\n+                \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(syslog_identifier.size()), syslog_identifier.data(), \"CODE_FILE=%s\",\n                 msg.source.filename, \"CODE_LINE=%d\", msg.source.line, \"CODE_FUNC=%s\", msg.source.funcname, nullptr);\n         }\n \n@@ -100,14 +104,16 @@ using systemd_sink_st = systemd_sink<details::null_mutex>;\n \n // Create and register a syslog logger\n template<typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> systemd_logger_mt(const std::string &logger_name, bool enable_formatting = false)\n+inline std::shared_ptr<logger> systemd_logger_mt(\n+    const std::string &logger_name, const std::string &ident = \"\", bool enable_formatting = false)\n {\n-    return Factory::template create<sinks::systemd_sink_mt>(logger_name, enable_formatting);\n+    return Factory::template create<sinks::systemd_sink_mt>(logger_name, ident, enable_formatting);\n }\n \n template<typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> systemd_logger_st(const std::string &logger_name, bool enable_formatting = false)\n+inline std::shared_ptr<logger> systemd_logger_st(\n+    const std::string &logger_name, const std::string &ident = \"\", bool enable_formatting = false)\n {\n-    return Factory::template create<sinks::systemd_sink_st>(logger_name, enable_formatting);\n+    return Factory::template create<sinks::systemd_sink_st>(logger_name, ident, enable_formatting);\n }\n } // namespace spdlog\n", "test_patch": "", "problem_statement": " Add option to customize/disable \"SYSLOG_IDENTIFIER\" in systemd sink?\nHi again. :)\r\n\r\nI'm still exploring the `systemd_sink` and I'm a little bothered by the use of `logger_name` to complete the `SYSLOG_IDENTIFIER` field.\r\nIt was introduced by #1289 to ensure logger's name isn't lost. This is absolutely fine, but this isn't useful when `enable_formatter` (#2320) is enabled.\r\nBy default, `SYSLOG_IDENTIFIER` contains the application name which seems more natural. Using the logger's name as `SYSLOG_IDENTIFIER` makes it kind if harder to identify the application logs within `journalctl`.\r\nMy main \"problem\" is that by overriding  `SYSLOG_IDENTIFIER` we can no longer filter logs with `journalctl -t appname`, we have to use `journalctl -f _COMM=appname`. It's a little annoyance, but that makes me feel `SYSLOG_IDENTIFIER` isn't used properly.\r\n\r\nFor reference, here is a message running `./my_app` without `SYSLOG_IDENTIFIER` being overridden:\r\n\r\n```json\r\n{\r\n\t\"CODE_FILE\": \"main.cpp\",\r\n\t\"CODE_FUNC\": \"main\",\r\n\t\"CODE_LINE\": \"6\",\r\n\t\"MESSAGE\": \"Hello World!\",\r\n\t\"PRIORITY\": \"6\",\r\n\t\"SYSLOG_IDENTIFIER\": \"my_app\",\r\n\t\"_BOOT_ID\": \"5a72020658b14867a5f011f283647138\",\r\n\t\"_GID\": \"1000\",\r\n\t\"_HOSTNAME\": \"delgan-laptop\",\r\n\t\"_MACHINE_ID\": \"3fcc29c834cf4bdeb22dfd1340a789f6\",\r\n\t\"_PID\": \"393259\",\r\n\t\"_SOURCE_REALTIME_TIMESTAMP\": \"1648374364807251\",\r\n\t\"_TRANSPORT\": \"journal\",\r\n\t\"_UID\": \"1000\",\r\n\t\"__CURSOR\": \"s=cf394ceea1a04b3bbff567538c6a8070;i=3c72a;b=5a72020658b14867a5f011f283647138;m=1038984c36;t=5db301078a0a5;x=c9adb40b0832588b\",\r\n\t\"__MONOTONIC_TIMESTAMP\": \"69668981814\",\r\n\t\"__REALTIME_TIMESTAMP\": \"1648374364807333\"\r\n}\r\n```\r\n\r\nAnd here is the same message with `SYSLOG_IDENTIFIER=my_logger`:\r\n\r\n\r\n```json\r\n{\r\n\t\"CODE_FILE\": \"main.cpp\",\r\n\t\"CODE_FUNC\": \"main\",\r\n\t\"CODE_LINE\": \"6\",\r\n\t\"MESSAGE\": \"Hello World!\",\r\n\t\"PRIORITY\": \"6\",\r\n\t\"SYSLOG_IDENTIFIER\": \"my_logger\",\r\n\t\"_BOOT_ID\": \"5a72020658b14867a5f011f283647138\",\r\n\t\"_COMM\": \"my_app\",\r\n\t\"_GID\": \"1000\",\r\n\t\"_HOSTNAME\": \"delgan-laptop\",\r\n\t\"_MACHINE_ID\": \"3fcc29c834cf4bdeb22dfd1340a789f6\",\r\n\t\"_PID\": \"393265\",\r\n\t\"_SOURCE_REALTIME_TIMESTAMP\": \"1648374366820985\",\r\n\t\"_TRANSPORT\": \"journal\",\r\n\t\"_UID\": \"1000\",\r\n\t\"__CURSOR\": \"s=cf394ceea1a04b3bbff567538c6a8070;i=3c72c;b=5a72020658b14867a5f011f283647138;m=1038b7065a;t=5db3010975aca;x=9e960f3f99fad8a6\",\r\n\t\"__MONOTONIC_TIMESTAMP\": \"69670995546\",\r\n\t\"__REALTIME_TIMESTAMP\": \"1648374366821066\"\r\n}\r\n```\r\n\r\nI have been thinking of the following possibilities:\r\n- Add a new `bool` argument to `systemd_sink` to disable `SYSLOG_IDENTIFIER` overriding. The implementation may require adding nested `if` and repeating `sd_journal_send` calls which isn't very elegant.\r\n- Add a new `std:string ident` argument similar to `syslog_sink`. If it's not empty, use it to override `SYSLOG_IDENTIFIER` otherwise use logger's name.\r\n- Do nothing and keep it as it is. I'm still in an exploratory phase and I'm not sure I'll use `systemd_sink` in the end, so if you want to avoid adding complexity, that's perfectly acceptable and I'll find another solution anyway.\r\n\r\nLet me know what's your opinion on this, and if you think it's worth implementing something, I'll open a PR. :+1: \n", "hints_text": "> Add a new bool argument to systemd_sink to disable SYSLOG_IDENTIFIER overriding\r\n\r\nWhat happens if SYSLOG_IDENTIFIER not overridden? The. process name is automatically used somehow?\r\n\r\n> Add a new std:string ident argument similar to syslog_sink. If it's not empty, use it to override SYSLOG_IDENTIFIER otherwise use logger's name.\r\n\r\nSeems to me reasonable option. Could be added if important to you.\r\n\n@Delgan. Closing. please open a pr if still needed.\n> What happens if SYSLOG_IDENTIFIER not overridden? The. process name is automatically used somehow?\r\n\r\nYes, indeed. It seems the process name is used for `SYSLOG_IDENTIFIER` by default, and if it's overridden then the process name appears in `_COMM` (which doesn't exist by default).\r\n\r\n> Seems to me reasonable option. Could be added if important to you.\r\n> Closing. please open a pr if still needed.\r\n\r\nThanks for the feedback. I'll probably open a PR in the coming days.", "created_at": "2022-04-01T21:24:34Z"}
{"repo": "gabime/spdlog", "pull_number": 2324, "instance_id": "gabime__spdlog-2324", "issue_numbers": ["2320"], "base_commit": "a49456f7f21fb802c1000fd79ef05911aa2101b7", "patch": "diff --git a/include/spdlog/sinks/systemd_sink.h b/include/spdlog/sinks/systemd_sink.h\n--- a/include/spdlog/sinks/systemd_sink.h\n+++ b/include/spdlog/sinks/systemd_sink.h\n@@ -18,16 +18,14 @@ namespace sinks {\n \n /**\n  * Sink that write to systemd journal using the `sd_journal_send()` library call.\n- *\n- * Locking is not needed, as `sd_journal_send()` itself is thread-safe.\n  */\n template<typename Mutex>\n class systemd_sink : public base_sink<Mutex>\n {\n public:\n-    //\n-    systemd_sink()\n-        : syslog_levels_{{/* spdlog::level::trace      */ LOG_DEBUG,\n+    explicit systemd_sink(bool enable_formatting = false)\n+        : enable_formatting_{enable_formatting}\n+        , syslog_levels_{{/* spdlog::level::trace      */ LOG_DEBUG,\n               /* spdlog::level::debug      */ LOG_DEBUG,\n               /* spdlog::level::info       */ LOG_INFO,\n               /* spdlog::level::warn       */ LOG_WARNING,\n@@ -42,14 +40,26 @@ class systemd_sink : public base_sink<Mutex>\n     systemd_sink &operator=(const systemd_sink &) = delete;\n \n protected:\n+    bool enable_formatting_ = false;\n     using levels_array = std::array<int, 7>;\n     levels_array syslog_levels_;\n \n     void sink_it_(const details::log_msg &msg) override\n     {\n         int err;\n+        string_view_t payload;\n+        memory_buf_t formatted;\n+        if (enable_formatting_)\n+        {\n+            base_sink<Mutex>::formatter_->format(msg, formatted);\n+            payload = string_view_t(formatted.data(), formatted.size());\n+        }\n+        else\n+        {\n+            payload = msg.payload;\n+        }\n \n-        size_t length = msg.payload.size();\n+        size_t length = payload.size();\n         // limit to max int\n         if (length > static_cast<size_t>(std::numeric_limits<int>::max()))\n         {\n@@ -60,12 +70,12 @@ class systemd_sink : public base_sink<Mutex>\n         if (msg.source.empty())\n         {\n             // Note: function call inside '()' to avoid macro expansion\n-            err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), msg.payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n+            err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n                 \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(msg.logger_name.size()), msg.logger_name.data(), nullptr);\n         }\n         else\n         {\n-            err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), msg.payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n+            err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n                 \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(msg.logger_name.size()), msg.logger_name.data(), \"CODE_FILE=%s\",\n                 msg.source.filename, \"CODE_LINE=%d\", msg.source.line, \"CODE_FUNC=%s\", msg.source.funcname, nullptr);\n         }\n@@ -90,14 +100,14 @@ using systemd_sink_st = systemd_sink<details::null_mutex>;\n \n // Create and register a syslog logger\n template<typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> systemd_logger_mt(const std::string &logger_name)\n+inline std::shared_ptr<logger> systemd_logger_mt(const std::string &logger_name, bool enable_formatting = false)\n {\n-    return Factory::template create<sinks::systemd_sink_mt>(logger_name);\n+    return Factory::template create<sinks::systemd_sink_mt>(logger_name, enable_formatting);\n }\n \n template<typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> systemd_logger_st(const std::string &logger_name)\n+inline std::shared_ptr<logger> systemd_logger_st(const std::string &logger_name, bool enable_formatting = false)\n {\n-    return Factory::template create<sinks::systemd_sink_st>(logger_name);\n+    return Factory::template create<sinks::systemd_sink_st>(logger_name, enable_formatting);\n }\n } // namespace spdlog\n", "test_patch": "", "problem_statement": "Add option to use formatter inside systemd sink\nHi.\r\n\r\nWe are migrating from `file_sink` to `systemd_sink` and we would like to preserve the `spdlog` format. It's dropped (by design, I understand) during conversion because `journald` implements its own structured logging. That makes sense, but we're losing some important fields in the process.\r\n\r\nBasically, I'm looking #1289 but using the alternative approach proposed.\r\nThat is, adding a boolean to constructor and re-implement #1107 for `systemd_sink`.\r\n\r\nI understand that I can create my own sink to implement it this way, but I having this feature upstream is of course preferable (avoid duplication and guarantees further updates).\r\n\r\nI can definitely open a Pull Request if you think this is an acceptable addition.\r\n\r\nI have also just one question: `sd_journal_send()` being thread safe, does that mean I can safely use `systemd_sink_st` in a multi-threaded environment with multiple loggers? Is there any reason to prefer `systemd_sink_mt`?\n", "hints_text": "> I can definitely open a Pull Request if you think this is an acceptable addition.\r\n\r\nSure, please open a pr.\r\n\r\n> does that mean I can safely use systemd_sink_st in a multi-threaded environment with multiple loggers? Is there any reason to prefer systemd_sink_mt?\r\n\r\nI guess so, unless you will use the future version with the formatter in which case it must be mutex protected since the formatter is not thread safe.\r\n\r\n\r\n\r\n", "created_at": "2022-03-27T10:38:14Z"}
{"repo": "gabime/spdlog", "pull_number": 2269, "instance_id": "gabime__spdlog-2269", "issue_numbers": ["2201"], "base_commit": "0b48976be49a69d8ee30b9b153b261704bbc02a0", "patch": "diff --git a/include/spdlog/pattern_formatter-inl.h b/include/spdlog/pattern_formatter-inl.h\n--- a/include/spdlog/pattern_formatter-inl.h\n+++ b/include/spdlog/pattern_formatter-inl.h\n@@ -766,6 +766,7 @@ class source_location_formatter final : public flag_formatter\n     {\n         if (msg.source.empty())\n         {\n+            ScopedPadder p(0, padinfo_, dest);\n             return;\n         }\n \n@@ -800,6 +801,7 @@ class source_filename_formatter final : public flag_formatter\n     {\n         if (msg.source.empty())\n         {\n+            ScopedPadder p(0, padinfo_, dest);\n             return;\n         }\n         size_t text_size = padinfo_.enabled() ? std::char_traits<char>::length(msg.source.filename) : 0;\n@@ -846,6 +848,7 @@ class short_filename_formatter final : public flag_formatter\n     {\n         if (msg.source.empty())\n         {\n+            ScopedPadder p(0, padinfo_, dest);\n             return;\n         }\n         auto filename = basename(msg.source.filename);\n@@ -867,6 +870,7 @@ class source_linenum_formatter final : public flag_formatter\n     {\n         if (msg.source.empty())\n         {\n+            ScopedPadder p(0, padinfo_, dest);\n             return;\n         }\n \n@@ -889,6 +893,7 @@ class source_funcname_formatter final : public flag_formatter\n     {\n         if (msg.source.empty())\n         {\n+            ScopedPadder p(0, padinfo_, dest);\n             return;\n         }\n         size_t text_size = padinfo_.enabled() ? std::char_traits<char>::length(msg.source.funcname) : 0;\n@@ -1051,7 +1056,7 @@ SPDLOG_INLINE std::unique_ptr<formatter> pattern_formatter::clone() const\n \n SPDLOG_INLINE void pattern_formatter::format(const details::log_msg &msg, memory_buf_t &dest)\n {\n-    if (need_localtime_) \n+    if (need_localtime_)\n     {\n         const auto secs = std::chrono::duration_cast<std::chrono::seconds>(msg.time.time_since_epoch());\n         if (secs != last_log_secs_)\n", "test_patch": "", "problem_statement": "Pattern width is not applied for missing source information\nIf the width is set in the format pattern for one of the source information fields (for example `%10s`), this width is only applied for messages which contain the source information. For example, this code\r\n```cpp\r\n#include <spdlog/spdlog.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  spdlog::set_pattern(\"(%10s:%10#:%10!) %v\");\r\n\r\n  spdlog::info(\"Hello World\");\r\n  SPDLOG_INFO(\"Hello World\");\r\n}\r\n```\r\nwill produce the output\r\n```\r\n$ ./a.out\r\n(::) Hello World\r\n(  main.cpp:         7:      main) Hello World\r\n```\r\nwhile I would expect it to produce output similar to this, to respect the alignment specified, even if the fields are not available.\r\n```\r\n$ ./a.out\r\n(          :          :          ) Hello World\r\n(  main.cpp:         7:      main) Hello World\r\n```\n", "hints_text": "", "created_at": "2022-02-08T11:37:12Z"}
{"repo": "gabime/spdlog", "pull_number": 2194, "instance_id": "gabime__spdlog-2194", "issue_numbers": ["2193"], "base_commit": "e1a4b28039a9097b970e0e9a500c31f9838b034b", "patch": "diff --git a/example/example.cpp b/example/example.cpp\n--- a/example/example.cpp\n+++ b/example/example.cpp\n@@ -23,6 +23,7 @@ void syslog_example();\n void udp_example();\n void custom_flags_example();\n void file_events_example();\n+void replace_default_logger_example();\n \n #include \"spdlog/spdlog.h\"\n #include \"spdlog/cfg/env.h\"  // support for loading levels from the environment variable\n@@ -80,6 +81,7 @@ int main(int, char *[])\n         udp_example();\n         custom_flags_example();\n         file_events_example();\n+        replace_default_logger_example();\n \n         // Flush all *registered* loggers using a worker thread every 3 seconds.\n         // note: registered loggers *must* be thread safe for this to work correctly!\n@@ -326,3 +328,19 @@ void file_events_example()\n     spdlog::logger my_logger(\"some_logger\", file_sink);\n     my_logger.info(\"Some log line\");\n }\n+\n+void replace_default_logger_example()\n+{\n+    // store the old logger so we don't break other examples.\n+    auto old_logger = spdlog::default_logger();\n+\n+    auto new_logger = spdlog::basic_logger_mt(\"new_default_logger\", \"logs/new-default-log.txt\", true);\n+    spdlog::set_default_logger(new_logger);\n+    spdlog::set_level(spdlog::level::info); \n+    spdlog::debug(\"This message should not be displayed!\");\n+    spdlog::set_level(spdlog::level::trace); \n+    spdlog::debug(\"This message should be displayed..\");\n+\n+    spdlog::set_default_logger(old_logger);\n+}\n+\n", "test_patch": "", "problem_statement": "Improve documentation on how to replace default logger.\nAlthough searching in the sources to find the piece of code to replace the default logger is not to hard, it would be nice if this would be mentioned in the README.md, the wiki or the examples. \n", "hints_text": "", "created_at": "2021-11-28T12:55:57Z"}
{"repo": "gabime/spdlog", "pull_number": 2037, "instance_id": "gabime__spdlog-2037", "issue_numbers": ["2034", "2034"], "base_commit": "ba29e1d75d43fe60616ca1e175871a5057b0fe34", "patch": "diff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -116,29 +116,26 @@ using wstring_view_t = fmt::basic_string_view<wchar_t>;\n using memory_buf_t = fmt::basic_memory_buffer<char, 250>;\n using wmemory_buf_t = fmt::basic_memory_buffer<wchar_t, 250>;\n \n+template<class T>\n+using remove_cvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;\n+\n+// clang doesn't like SFINAE disabled constructor in std::is_convertible<> so have to repeat the condition from basic_format_string here,\n+// in addition, fmt::basic_runtime<Char> is only convertible to basic_format_string<Char> but not basic_string_view<Char>\n+template<class T, class Char = char>\n+struct is_convertible_to_basic_format_string\n+    : std::integral_constant<bool,\n+          std::is_convertible<T, fmt::basic_string_view<Char>>::value || std::is_same<remove_cvref_t<T>, fmt::basic_runtime<Char>>::value>\n+{};\n+\n #ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT\n #    ifndef _WIN32\n #        error SPDLOG_WCHAR_TO_UTF8_SUPPORT only supported on windows\n-#    else\n-template<typename T>\n-struct is_convertible_to_wstring_view : std::is_convertible<T, wstring_view_t>\n-{};\n-template<class T>\n-struct is_convertible_to_wformat_string : std::is_convertible<T, fmt::wformat_string<>>\n-{};\n #    endif // _WIN32\n-#else\n-template<typename>\n-struct is_convertible_to_wstring_view : std::false_type\n-{};\n-template<class>\n-struct is_convertible_to_wformat_string : std::false_type\n-{};\n-#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT\n+#endif     // SPDLOG_WCHAR_TO_UTF8_SUPPORT\n \n template<class T>\n-struct is_convertible_to_basic_format_string\n-    : std::integral_constant<bool, std::is_convertible<const T &, fmt::format_string<>>::value || is_convertible_to_wformat_string<T>::value>\n+struct is_convertible_to_any_format_string : std::integral_constant<bool, is_convertible_to_basic_format_string<T, char>::value ||\n+                                                                              is_convertible_to_basic_format_string<T, wchar_t>::value>\n {};\n \n #if defined(SPDLOG_NO_ATOMIC_LEVELS)\ndiff --git a/include/spdlog/logger.h b/include/spdlog/logger.h\n--- a/include/spdlog/logger.h\n+++ b/include/spdlog/logger.h\n@@ -102,10 +102,8 @@ class SPDLOG_API logger\n         log(loc, lvl, string_view_t{msg});\n     }\n \n-    // T cannot be statically converted to neither string_view, nor wstring_view and nor format string\n-    template<class T, typename std::enable_if<!std::is_convertible<const T &, spdlog::string_view_t>::value &&\n-                                                  !is_convertible_to_basic_format_string<const T &>::value,\n-                          int>::type = 0>\n+    // T cannot be statically converted to format string (including string_view)\n+    template<class T, typename std::enable_if<!is_convertible_to_any_format_string<const T &>::value, int>::type = 0>\n     void log(source_loc loc, level::level_enum lvl, const T &msg)\n     {\n         log(loc, lvl, \"{}\", msg);\n", "test_patch": "", "problem_statement": "spdlog v1.9.1 and clang 12.0.1 (libc++) compilation failure\nI cannot seem to compile any code that includes spdlog with clang 12.0.1.\r\n\r\n```\r\n#include <spdlog/spdlog.h>\r\n\r\nint\r\nmain(int /*argc*/, char** /*argv*/)\r\n{\r\n    spdlog::info(\"Welcome to spdlog!\");\r\n    return 0;\r\n}\r\n```\r\n\r\n```\r\n/usr/bin/clang++ -std=c++20 -stdlib=libc++ -ggdb3 -pedantic-errors -Wall -Werror -Wextra -O0 -DSPDLOG_COMPILED_LIB -isystem/tmp/spdlog/1.9.1/include -c main.cpp\r\n-o main.o\r\nIn file included from main.cpp:1:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/spdlog.h:12:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/common.h:7:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/details/null_mutex.h:6:\r\nIn file included from /usr/bin/../include/c++/v1/atomic:579:\r\nIn file included from /usr/bin/../include/c++/v1/__threading_support:15:\r\nIn file included from /usr/bin/../include/c++/v1/chrono:829:\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: error: call to consteval function 'fmt::basic_format_string<char>::basic_format_string<fmt::basic_string_view<char>, 0>' is no\r\nt a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/common.h:141:41: note: in instantiation of template class 'std::is_convertible<const fmt::basic_string_view<char> &, fmt::basic_format_string\r\n<char>>' requested here\r\n    : std::integral_constant<bool, std::is_convertible<const T &, fmt::format_string<>>::value || is_convertible_to_wformat_string<T>::value>\r\n                                        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:107:52: note: in instantiation of template class 'spdlog::is_convertible_to_basic_format_string<const fmt::basic_string_view<char> &\r\n>' requested here\r\n                                                  !is_convertible_to_basic_format_string<const T &>::value,\r\n                                                   ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:109:10: note: while substituting prior template arguments into non-type template parameter [with T = fmt::basic_string_view<char>]\r\n    void log(source_loc loc, level::level_enum lvl, const T &msg)\r\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:102:9: note: while substituting deduced template arguments into function template 'log' [with T = fmt::basic_string_view<char>, $1 =\r\n (no value)]\r\n        log(loc, lvl, string_view_t{msg});\r\n        ^\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: note: undefined constructor 'basic_format_string<fmt::basic_string_view<char>, 0>' cannot be used in a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/fmt/bundled/core.h:2835:17: note: declared here\r\n  FMT_CONSTEVAL basic_format_string(const S& s) : str_(s) {\r\nIn file included from main.cpp:1:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/spdlog.h:12:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/common.h:7:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/details/null_mutex.h:6:\r\nIn file included from /usr/bin/../include/c++/v1/atomic:579:\r\nIn file included from /usr/bin/../include/c++/v1/__threading_support:15:\r\nIn file included from /usr/bin/../include/c++/v1/chrono:829:\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: error: call to consteval function 'fmt::basic_format_string<char>::basic_format_string<char [19], 0>' is not a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/common.h:141:41: note: in instantiation of template class 'std::is_convertible<char const (&)[19], fmt::basic_format_string<char>>' requested here\r\n    : std::integral_constant<bool, std::is_convertible<const T &, fmt::format_string<>>::value || is_convertible_to_wformat_string<T>::value>\r\n                                        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:107:52: note: in instantiation of template class 'spdlog::is_convertible_to_basic_format_string<char const (&)[19]>' requested here\r\n                                                  !is_convertible_to_basic_format_string<const T &>::value,\r\n                                                   ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:109:10: note: while substituting prior template arguments into non-type template parameter [with T = char [19]]\r\n    void log(source_loc loc, level::level_enum lvl, const T &msg)\r\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:95:9: note: while substituting deduced template arguments into function template 'log' [with T = char [19], $1 = (no value)]\r\n        log(source_loc{}, lvl, msg);\r\n        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:246:9: note: in instantiation of function template specialization 'spdlog::logger::log<char [19]>' requested here\r\n        log(level::info, msg);\r\n        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/spdlog.h:255:27: note: in instantiation of function template specialization 'spdlog::logger::info<char [19]>' requested here\r\n    default_logger_raw()->info(msg);\r\n                          ^\r\nmain.cpp:7:13: note: in instantiation of function template specialization 'spdlog::info<char [19]>' requested here\r\n    spdlog::info(\"Welcome to spdlog!\");\r\n            ^\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: note: undefined constructor 'basic_format_string<char [19], 0>' cannot be used in a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/fmt/bundled/core.h:2835:17: note: declared here\r\n  FMT_CONSTEVAL basic_format_string(const S& s) : str_(s) {\r\n                ^\r\n2 errors generated.\r\n```\r\n\r\n\r\nspdlog was built using the following cmake command\r\n```\r\ncmake \\\r\n        -DCMAKE_BUILD_TYPE:STRING=Release \\\r\n        -DCMAKE_CXX_COMPILER:STRING=/usr/bin/clang++ \\\r\n        -DCMAKE_CXX_FLAGS:STRING=\"-stdlib=libc++ -rtlib=compiler-rt -fuse-ld=lld -lgcc_s\" \\\r\n        -DCMAKE_INSTALL_PREFIX:PATH=/tmp/spdlog/1.9.1 \\\r\n        -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON \\\r\n        -DSPDLOG_BUILD_SHARED:BOOL=OFF \\\r\n        -S . -B _build\r\n```\r\n\r\nAny help would be appreciated. Thanks!\r\n\nspdlog v1.9.1 and clang 12.0.1 (libc++) compilation failure\nI cannot seem to compile any code that includes spdlog with clang 12.0.1.\r\n\r\n```\r\n#include <spdlog/spdlog.h>\r\n\r\nint\r\nmain(int /*argc*/, char** /*argv*/)\r\n{\r\n    spdlog::info(\"Welcome to spdlog!\");\r\n    return 0;\r\n}\r\n```\r\n\r\n```\r\n/usr/bin/clang++ -std=c++20 -stdlib=libc++ -ggdb3 -pedantic-errors -Wall -Werror -Wextra -O0 -DSPDLOG_COMPILED_LIB -isystem/tmp/spdlog/1.9.1/include -c main.cpp\r\n-o main.o\r\nIn file included from main.cpp:1:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/spdlog.h:12:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/common.h:7:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/details/null_mutex.h:6:\r\nIn file included from /usr/bin/../include/c++/v1/atomic:579:\r\nIn file included from /usr/bin/../include/c++/v1/__threading_support:15:\r\nIn file included from /usr/bin/../include/c++/v1/chrono:829:\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: error: call to consteval function 'fmt::basic_format_string<char>::basic_format_string<fmt::basic_string_view<char>, 0>' is no\r\nt a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/common.h:141:41: note: in instantiation of template class 'std::is_convertible<const fmt::basic_string_view<char> &, fmt::basic_format_string\r\n<char>>' requested here\r\n    : std::integral_constant<bool, std::is_convertible<const T &, fmt::format_string<>>::value || is_convertible_to_wformat_string<T>::value>\r\n                                        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:107:52: note: in instantiation of template class 'spdlog::is_convertible_to_basic_format_string<const fmt::basic_string_view<char> &\r\n>' requested here\r\n                                                  !is_convertible_to_basic_format_string<const T &>::value,\r\n                                                   ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:109:10: note: while substituting prior template arguments into non-type template parameter [with T = fmt::basic_string_view<char>]\r\n    void log(source_loc loc, level::level_enum lvl, const T &msg)\r\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:102:9: note: while substituting deduced template arguments into function template 'log' [with T = fmt::basic_string_view<char>, $1 =\r\n (no value)]\r\n        log(loc, lvl, string_view_t{msg});\r\n        ^\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: note: undefined constructor 'basic_format_string<fmt::basic_string_view<char>, 0>' cannot be used in a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/fmt/bundled/core.h:2835:17: note: declared here\r\n  FMT_CONSTEVAL basic_format_string(const S& s) : str_(s) {\r\nIn file included from main.cpp:1:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/spdlog.h:12:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/common.h:7:\r\nIn file included from /tmp/spdlog/1.9.1/include/spdlog/details/null_mutex.h:6:\r\nIn file included from /usr/bin/../include/c++/v1/atomic:579:\r\nIn file included from /usr/bin/../include/c++/v1/__threading_support:15:\r\nIn file included from /usr/bin/../include/c++/v1/chrono:829:\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: error: call to consteval function 'fmt::basic_format_string<char>::basic_format_string<char [19], 0>' is not a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/common.h:141:41: note: in instantiation of template class 'std::is_convertible<char const (&)[19], fmt::basic_format_string<char>>' requested here\r\n    : std::integral_constant<bool, std::is_convertible<const T &, fmt::format_string<>>::value || is_convertible_to_wformat_string<T>::value>\r\n                                        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:107:52: note: in instantiation of template class 'spdlog::is_convertible_to_basic_format_string<char const (&)[19]>' requested here\r\n                                                  !is_convertible_to_basic_format_string<const T &>::value,\r\n                                                   ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:109:10: note: while substituting prior template arguments into non-type template parameter [with T = char [19]]\r\n    void log(source_loc loc, level::level_enum lvl, const T &msg)\r\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:95:9: note: while substituting deduced template arguments into function template 'log' [with T = char [19], $1 = (no value)]\r\n        log(source_loc{}, lvl, msg);\r\n        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/logger.h:246:9: note: in instantiation of function template specialization 'spdlog::logger::log<char [19]>' requested here\r\n        log(level::info, msg);\r\n        ^\r\n/tmp/spdlog/1.9.1/include/spdlog/spdlog.h:255:27: note: in instantiation of function template specialization 'spdlog::logger::info<char [19]>' requested here\r\n    default_logger_raw()->info(msg);\r\n                          ^\r\nmain.cpp:7:13: note: in instantiation of function template specialization 'spdlog::info<char [19]>' requested here\r\n    spdlog::info(\"Welcome to spdlog!\");\r\n            ^\r\n/usr/bin/../include/c++/v1/type_traits:1688:66: note: undefined constructor 'basic_format_string<char [19], 0>' cannot be used in a constant expression\r\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};\r\n                                                                 ^\r\n/tmp/spdlog/1.9.1/include/spdlog/fmt/bundled/core.h:2835:17: note: declared here\r\n  FMT_CONSTEVAL basic_format_string(const S& s) : str_(s) {\r\n                ^\r\n2 errors generated.\r\n```\r\n\r\n\r\nspdlog was built using the following cmake command\r\n```\r\ncmake \\\r\n        -DCMAKE_BUILD_TYPE:STRING=Release \\\r\n        -DCMAKE_CXX_COMPILER:STRING=/usr/bin/clang++ \\\r\n        -DCMAKE_CXX_FLAGS:STRING=\"-stdlib=libc++ -rtlib=compiler-rt -fuse-ld=lld -lgcc_s\" \\\r\n        -DCMAKE_INSTALL_PREFIX:PATH=/tmp/spdlog/1.9.1 \\\r\n        -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON \\\r\n        -DSPDLOG_BUILD_SHARED:BOOL=OFF \\\r\n        -S . -B _build\r\n```\r\n\r\nAny help would be appreciated. Thanks!\r\n\n", "hints_text": "seems like duplicate of #2023 \nseems like duplicate of #2023 ", "created_at": "2021-08-09T09:01:12Z"}
{"repo": "gabime/spdlog", "pull_number": 1946, "instance_id": "gabime__spdlog-1946", "issue_numbers": ["1945"], "base_commit": "87133ef6b7e36913abfaaddf89af309f5f142650", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -15,6 +15,13 @@ message(STATUS \"Build spdlog: ${SPDLOG_VERSION}\")\n \n include(GNUInstallDirs)\n \n+# ---------------------------------------------------------------------------------------\n+# Set CMake policies to support later version behaviour\n+# ---------------------------------------------------------------------------------------\n+if(POLICY CMP0077)\n+    cmake_policy(SET CMP0077 NEW) # option() honors variables already set\n+endif()\n+\n # ---------------------------------------------------------------------------------------\n # Set default build to release\n # ---------------------------------------------------------------------------------------\n", "test_patch": "", "problem_statement": "Update cmake_minimum_requrired to 3.13\nI am using spdlog as CMake subdirectory (through ```add_subdirectory```), and am unable to set configuration options (such as ```SPDLOG_FMT_EXTERNAL```) in my parent CMakeLists.txt file. This is because ```cmake_minimum_required(VERSION 3.10)``` unsets CMake policy ```CMP0077```.\r\n\r\n```CMP0077``` unsets normal variables (i.e. a parent-project required setting for ```SPDLOG_FMT_EXTERNAL``` etc), and forces the default option. I can not force the policy to be set as the current ```cmake_minimum_required(VERSION 3.10)``` overrides my own policy / version settings.\r\n\r\nThe new (more intuitive) behaviour was introduced in cmake 3.13: https://cmake.org/cmake/help/latest/policy/CMP0077.html#policy:CMP0077\n", "hints_text": "An alternative, which is what Google's Abseil library does in order to maintain compatability with earlier cmake versions, is to add the following in their CMake file:\r\n\r\n```\r\nif (POLICY CMP0077)\r\n  cmake_policy(SET CMP0077 NEW)\r\nendif (POLICY CMP0077)\r\n```\n> if (POLICY CMP0077)\r\n  cmake_policy(SET CMP0077 NEW)\r\nendif (POLICY CMP0077)\r\n\r\nAgreed. PR is welcome", "created_at": "2021-05-16T21:53:30Z"}
{"repo": "gabime/spdlog", "pull_number": 1846, "instance_id": "gabime__spdlog-1846", "issue_numbers": ["1062"], "base_commit": "de89c4fd016cf7d81562c4fbba9bfee4c3fceb35", "patch": "diff --git a/bench/formatter-bench.cpp b/bench/formatter-bench.cpp\n--- a/bench/formatter-bench.cpp\n+++ b/bench/formatter-bench.cpp\n@@ -34,14 +34,14 @@ void bench_formatters()\n     for (auto &flag : all_flags)\n     {\n         auto pattern = std::string(\"%\") + flag;\n-        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\n+        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern);\n \n         //        pattern = std::string(\"%16\") + flag;\n-        //        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\n+        //        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern);\n         //\n         //        // bench center padding\n         //        pattern = std::string(\"%=16\") + flag;\n-        //        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\n+        //        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern);\n     }\n \n     // complex patterns\n@@ -52,7 +52,7 @@ void bench_formatters()\n     };\n     for (auto &pattern : patterns)\n     {\n-        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern)->Iterations(2500000);\n+        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern)->Iterations(2500000);\n     }\n }\n \n@@ -73,7 +73,7 @@ int main(int argc, char *argv[])\n     }\n     else\n     {\n-        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\n+        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern);\n     }\n     benchmark::Initialize(&argc, argv);\n     benchmark::RunSpecifiedBenchmarks();\n", "test_patch": "", "problem_statement": "Facing benchmark.h:1050:41: error: variable 'fn' has function type. Even with v1.3.1\n```\r\nmake\r\nScanning dependencies of target example\r\n[  4%] Building CXX object example/CMakeFiles/example.dir/example.cpp.o\r\n[  8%] Linking CXX executable example\r\n[  8%] Built target example\r\nScanning dependencies of target multisink\r\n[ 12%] Building CXX object example/CMakeFiles/multisink.dir/multisink.cpp.o\r\n[ 16%] Linking CXX executable multisink\r\n[ 16%] Built target multisink\r\nScanning dependencies of target spdlog-utests\r\n[ 20%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_errors.cpp.o\r\n[ 24%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_file_helper.cpp.o\r\n[ 28%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_file_logging.cpp.o\r\n[ 32%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_misc.cpp.o\r\n[ 36%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_pattern_formatter.cpp.o\r\n[ 40%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_async.cpp.o\r\n[ 44%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_registry.cpp.o\r\n[ 48%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_macros.cpp.o\r\n[ 52%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/utils.cpp.o\r\n[ 56%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/main.cpp.o\r\n[ 60%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_mpmc_q.cpp.o\r\n[ 64%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_fmt_helper.cpp.o\r\n[ 68%] Linking CXX executable spdlog-utests\r\n[ 68%] Built target spdlog-utests\r\nScanning dependencies of target formatter-bench\r\n[ 72%] Building CXX object bench/CMakeFiles/formatter-bench.dir/formatter-bench.cpp.o\r\nIn file included from /tmp/tmp.CP8z4tf0ew/vendor/spdlog/bench/formatter-bench.cpp:6:0:\r\n/usr/local/include/benchmark/benchmark.h: In instantiation of 'benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...)::<lambda(benchmark::State&)> [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]':\r\n/usr/local/include/benchmark/benchmark.h:1050:48:   required from 'struct benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...) [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]::<lambda(class benchmark::State&)>'\r\n/usr/local/include/benchmark/benchmark.h:1049:38:   required from 'benchmark::internal::Benchmark* benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...) [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]'\r\n/tmp/tmp.CP8z4tf0ew/vendor/spdlog/bench/formatter-bench.cpp:49:79:   required from here\r\n/usr/local/include/benchmark/benchmark.h:1050:41: error: variable 'fn' has function type\r\n       name, [=](benchmark::State& st) { fn(st, args...); });\r\n                                         ^\r\ncompilation terminated due to -Wfatal-errors.\r\nbench/CMakeFiles/formatter-bench.dir/build.make:62: recipe for target 'bench/CMakeFiles/formatter-bench.dir/formatter-bench.cpp.o' failed\r\nmake[2]: *** [bench/CMakeFiles/formatter-bench.dir/formatter-bench.cpp.o] Error 1\r\nCMakeFiles/Makefile2:1168: recipe for target 'bench/CMakeFiles/formatter-bench.dir/all' failed\r\nmake[1]: *** [bench/CMakeFiles/formatter-bench.dir/all] Error 2\r\nMakefile:138: recipe for target 'all' failed\r\nmake: *** [all] Error 2\r\n```\n", "hints_text": "```\r\ncmake --build _builds --target install\r\nScanning dependencies of target example\r\n[  4%] Building CXX object example/CMakeFiles/example.dir/example.cpp.o\r\n[  8%] Linking CXX executable example\r\n[  8%] Built target example\r\nScanning dependencies of target multisink\r\n[ 12%] Building CXX object example/CMakeFiles/multisink.dir/multisink.cpp.o\r\n[ 16%] Linking CXX executable multisink\r\n[ 16%] Built target multisink\r\nScanning dependencies of target spdlog-utests\r\n[ 20%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_errors.cpp.o\r\n[ 24%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_file_helper.cpp.o\r\n[ 28%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_file_logging.cpp.o\r\n[ 32%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_misc.cpp.o\r\n[ 36%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_pattern_formatter.cpp.o\r\n[ 40%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_async.cpp.o\r\n[ 44%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_registry.cpp.o\r\n[ 48%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_macros.cpp.o\r\n[ 52%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/utils.cpp.o\r\n[ 56%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/main.cpp.o\r\n[ 60%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_mpmc_q.cpp.o\r\n[ 64%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_fmt_helper.cpp.o\r\n[ 68%] Linking CXX executable spdlog-utests\r\n[ 68%] Built target spdlog-utests\r\nScanning dependencies of target formatter-bench\r\n[ 72%] Building CXX object bench/CMakeFiles/formatter-bench.dir/formatter-bench.cpp.o\r\nIn file included from /tmp/tmp.CP8z4tf0ew/vendor/spdlog/bench/formatter-bench.cpp:6:0:\r\n/usr/local/include/benchmark/benchmark.h: In instantiation of 'benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...)::<lambda(benchmark::State&)> [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]':\r\n/usr/local/include/benchmark/benchmark.h:1050:48:   required from 'struct benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...) [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]::<lambda(class benchmark::State&)>'\r\n/usr/local/include/benchmark/benchmark.h:1049:38:   required from 'benchmark::internal::Benchmark* benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...) [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]'\r\n/tmp/tmp.CP8z4tf0ew/vendor/spdlog/bench/formatter-bench.cpp:49:79:   required from here\r\n/usr/local/include/benchmark/benchmark.h:1050:41: error: variable 'fn' has function type\r\n       name, [=](benchmark::State& st) { fn(st, args...); });\r\n                                         ^\r\ncompilation terminated due to -Wfatal-errors.\r\nbench/CMakeFiles/formatter-bench.dir/build.make:62: recipe for target 'bench/CMakeFiles/formatter-bench.dir/formatter-bench.cpp.o' failed\r\nmake[2]: *** [bench/CMakeFiles/formatter-bench.dir/formatter-bench.cpp.o] Error 1\r\nCMakeFiles/Makefile2:1168: recipe for target 'bench/CMakeFiles/formatter-bench.dir/all' failed\r\nmake[1]: *** [bench/CMakeFiles/formatter-bench.dir/all] Error 2\r\nMakefile:138: recipe for target 'all' failed\r\nmake: *** [all] Error 2\r\n```\r\n\r\nFollowed the documentation and got this.\ncant reproduce. probably wrong version of google benchmarks is used\nI'm facing this same issue with google benchmark v1.4.1. Also, this issue has been reported twice in the last year, see also #931 . I can find a reference of a similar error in https://stackoverflow.com/questions/34815698/c11-passing-function-as-lambda-parameter\r\n\r\nI think it may be worthwhile to re-open this issue and check of wrapping in a function pointer helps?\nI also see this issue with google benchmark 1.5.0.\r\n\r\nCould this be re-opened, or should I create a new issue?\nOpened. @emmenlau  If you have an idea how to fix, a PR would be much appreciated as I don't have time to get to it.\nThanks @gabime . Currently I have no clue what may go wrong. The only related link is the stackoverflow discussion I linked above. It seems to say that the method should be encapsulated in a function pointer. However it partially contradicts itself later, so that I'm also at a loss here.\r\nAny help would be appreciated!\n@gabime I have the same problem. which version of google benchamrks have you tested with no errors?\nlatest commit always worked for me\nI have the same issue. I'm using the latest google benchmark at https://github.com/google/benchmark.\nFor those stumbling upon this error, it's a bug likely caused by compilers not properly decaying the supplied benchmarked function name into its pointer. Detailed answer [here](https://stackoverflow.com/a/34816317/1476661). Putting the address-of operator in front of the supplied function name (or in the context of GBench, the project could help by not simply capturing `fn`, but invoking `std::decay` on it as outlined in the linked answer) should solve the issue (at least it did for us, where it popped up while compiling the code using nvcc).\n@gabime The solution is to provide benchmark cases not through a naked function name, but through their pointer. Put an ampersand in front if all supplied function names, for eg. [here](https://github.com/gabime/spdlog/blob/v1.x/bench/formatter-bench.cpp#L37). (Function names aren't strictly speaking part of the language (they don't have a type). Language rules dictate in what contexts the names of functions (and other stuff) \"decay\" into things with types. I'm not a language lawyer, so I can't tell where some compiler is buggy or in which case it's actually correct _not_ to decay, but the fix is simple nontheless: don't rely on decay mechanics.\n@MathiasMagnus Thanks. Can you confirm if this actually solves it for spdlog?  I cant reproduce so I cant confirm myself.\n@gabime Yes, I verified and it works. Built in WSL using Ubuntu 18.04, installed the oldest GCC in the repo (g++-5) and tried building, get the same error. Add 3 `&`s on lines 37,55,76 and it compiles.\n```\r\ncmake -D CMAKE_CXX_COMPILER=g++-5 -D SPDLOG_BUILD_BENCH=ON -D CMAKE_PREFIX_PATH=/home/mate/benchmark/install ..\r\n-- The CXX compiler identification is GNU 5.5.0\r\n-- Check for working CXX compiler: /usr/bin/g++-5\r\n-- Check for working CXX compiler: /usr/bin/g++-5 -- works\r\n-- Detecting CXX compiler ABI info\r\n-- Detecting CXX compiler ABI info - done\r\n-- Detecting CXX compile features\r\n-- Detecting CXX compile features - done\r\n-- Build spdlog: 1.8.2\r\n-- Looking for C++ include pthread.h\r\n-- Looking for C++ include pthread.h - found\r\n-- Looking for pthread_create\r\n-- Looking for pthread_create - not found\r\n-- Looking for pthread_create in pthreads\r\n-- Looking for pthread_create in pthreads - not found\r\n-- Looking for pthread_create in pthread\r\n-- Looking for pthread_create in pthread - found\r\n-- Found Threads: TRUE\r\n-- Build type: Release\r\n-- Generating example(s)\r\n-- Generating benchmarks\r\n-- Generating install\r\n-- Configuring done\r\n-- Generating done\r\n-- Build files have been written to: /home/mate/spdlog/build\r\nmate@MATTY-GL702ZC:~/spdlog/build$ grep RegisterBenchmark ../bench/formatter-bench.cpp\r\n        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\r\n        //        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\r\n        //        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\r\n        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern)->Iterations(2500000);\r\n        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\r\nmate@MATTY-GL702ZC:~/spdlog/build$ cmake --build . --target formatter-bench | grep error\r\nIn file included from /home/mate/spdlog/bench/formatter-bench.cpp:6:0:\r\n/home/mate/benchmark/install/include/benchmark/benchmark.h: In instantiation of \u2018benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...)::<lambda(benchmark::State&)> [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]\u2019:\r\n/home/mate/benchmark/install/include/benchmark/benchmark.h:1062:48:   required from \u2018struct benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...) [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]::<lambda(class benchmark::State&)>\u2019\r\n/home/mate/benchmark/install/include/benchmark/benchmark.h:1061:38:   required from \u2018benchmark::internal::Benchmark* benchmark::RegisterBenchmark(const char*, Lambda&&, Args&& ...) [with Lambda = void (&)(benchmark::State&, std::__cxx11::basic_string<char>); Args = {std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]\u2019\r\n/home/mate/spdlog/bench/formatter-bench.cpp:37:79:   required from here\r\n/home/mate/benchmark/install/include/benchmark/benchmark.h:1062:41: error: variable \u2018fn\u2019 has function type\r\n       name, [=](benchmark::State& st) { fn(st, args...); });\r\nmate@MATTY-GL702ZC:~/spdlog/build$ grep RegisterBenchmark ../bench/formatter-bench.cpp\r\n        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern);\r\n        //        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\r\n        //        benchmark::RegisterBenchmark(pattern.c_str(), bench_formatter, pattern);\r\n        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern)->Iterations(2500000);\r\n        benchmark::RegisterBenchmark(pattern.c_str(), &bench_formatter, pattern);\r\nmate@MATTY-GL702ZC:~/spdlog/build$ cmake --build . --target formatter-bench\r\n[ 80%] Built target spdlog\r\nScanning dependencies of target formatter-bench\r\n[ 90%] Building CXX object bench/CMakeFiles/formatter-bench.dir/formatter-bench.cpp.o\r\n[100%] Linking CXX executable formatter-bench\r\n[100%] Built target formatter-bench\r\n```", "created_at": "2021-02-24T08:46:29Z"}
{"repo": "gabime/spdlog", "pull_number": 1798, "instance_id": "gabime__spdlog-1798", "issue_numbers": ["1791"], "base_commit": "710a0e3a4599e9a758a00d3a6eb606a1070e38f2", "patch": "diff --git a/include/spdlog/common-inl.h b/include/spdlog/common-inl.h\n--- a/include/spdlog/common-inl.h\n+++ b/include/spdlog/common-inl.h\n@@ -9,11 +9,15 @@\n \n namespace spdlog {\n namespace level {\n+\n+#if __cplusplus >= 201402L\n+constexpr\n+#endif\n static string_view_t level_string_views[] SPDLOG_LEVEL_NAMES;\n \n static const char *short_level_names[] SPDLOG_SHORT_LEVEL_NAMES;\n \n-SPDLOG_INLINE string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT\n+SPDLOG_INLINE const string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT\n {\n     return level_string_views[l];\n }\ndiff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -163,7 +163,7 @@ enum level_enum\n     }\n #endif\n \n-SPDLOG_API string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT;\n+SPDLOG_API const string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT;\n SPDLOG_API const char *to_short_c_str(spdlog::level::level_enum l) SPDLOG_NOEXCEPT;\n SPDLOG_API spdlog::level::level_enum from_str(const std::string &name) SPDLOG_NOEXCEPT;\n \ndiff --git a/include/spdlog/pattern_formatter-inl.h b/include/spdlog/pattern_formatter-inl.h\n--- a/include/spdlog/pattern_formatter-inl.h\n+++ b/include/spdlog/pattern_formatter-inl.h\n@@ -127,7 +127,7 @@ class level_formatter final : public flag_formatter\n \n     void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override\n     {\n-        string_view_t &level_name = level::to_string_view(msg.level);\n+        const string_view_t &level_name = level::to_string_view(msg.level);\n         ScopedPadder p(level_name.size(), padinfo_, dest);\n         fmt_helper::append_string_view(level_name, dest);\n     }\n", "test_patch": "", "problem_statement": "static initialization order for level_string_views\nIn file common-inl.h level names are defined as `string_view`s. The declarations can be made `constexpr` so they are always initialized at start of the program.\r\n\r\nCurrently, any logs created before entering `main()` or even any operations dealing with level names like loading levels from env variables cannot be performed reliably before entering `main()` function of the program. Depending on the static initialization order, sometimes level names might not be present at the time.\r\n\r\nFor `constexpr` declaration of `level_string_views` only minor changes are needed. I can submit a PR if that is preferred.\n", "hints_text": "Sounds good. Thanks. \r\n\r\nKeep in mind this should still compile in c++11", "created_at": "2021-01-11T10:17:59Z"}
{"repo": "gabime/spdlog", "pull_number": 1771, "instance_id": "gabime__spdlog-1771", "issue_numbers": ["1770"], "base_commit": "adcfb7fb558cb2d3435f5d20edec2a61a5340361", "patch": "diff --git a/include/spdlog/sinks/wincolor_sink-inl.h b/include/spdlog/sinks/wincolor_sink-inl.h\n--- a/include/spdlog/sinks/wincolor_sink-inl.h\n+++ b/include/spdlog/sinks/wincolor_sink-inl.h\n@@ -7,22 +7,30 @@\n #include <spdlog/sinks/wincolor_sink.h>\n #endif\n \n+#include <spdlog/details/windows_include.h>\n+#include <wincon.h>\n+\n #include <spdlog/common.h>\n #include <spdlog/pattern_formatter.h>\n \n namespace spdlog {\n namespace sinks {\n-\n template<typename ConsoleMutex>\n-SPDLOG_INLINE wincolor_sink<ConsoleMutex>::wincolor_sink(HANDLE out_handle, color_mode mode)\n-    : out_handle_(out_handle)\n+SPDLOG_INLINE wincolor_sink<ConsoleMutex>::wincolor_sink(void *out_handle, color_mode mode)\n+    : BOLD(FOREGROUND_INTENSITY)\n+    , RED(FOREGROUND_RED)\n+    , GREEN(FOREGROUND_GREEN)\n+    , CYAN(FOREGROUND_GREEN | FOREGROUND_BLUE)\n+    , WHITE(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)\n+    , YELLOW(FOREGROUND_RED | FOREGROUND_GREEN)\n+    , out_handle_(out_handle)\n     , mutex_(ConsoleMutex::mutex())\n     , formatter_(details::make_unique<spdlog::pattern_formatter>())\n {\n     // check if out_handle is points to the actual console.\n     // ::GetConsoleMode() should return 0 if it is redirected or not valid console handle.\n     DWORD console_mode;\n-    in_console_ = ::GetConsoleMode(out_handle, &console_mode) != 0;\n+    in_console_ = ::GetConsoleMode(static_cast<HANDLE>(out_handle_), &console_mode) != 0;\n \n     set_color_mode(mode);\n     colors_[level::trace] = WHITE;\n@@ -42,7 +50,7 @@ SPDLOG_INLINE wincolor_sink<ConsoleMutex>::~wincolor_sink()\n \n // change the color for the given level\n template<typename ConsoleMutex>\n-void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color(level::level_enum level, WORD color)\n+void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color(level::level_enum level, std::uint16_t color)\n {\n     std::lock_guard<mutex_t> lock(mutex_);\n     colors_[level] = color;\n@@ -67,10 +75,10 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::log(const details::log_msg &msg)\n         print_range_(formatted, 0, msg.color_range_start);\n \n         // in color range\n-        auto orig_attribs = set_foreground_color_(colors_[msg.level]);\n+        auto orig_attribs = static_cast<WORD>(set_foreground_color_(colors_[msg.level]));\n         print_range_(formatted, msg.color_range_start, msg.color_range_end);\n         // reset to orig colors\n-        ::SetConsoleTextAttribute(out_handle_, orig_attribs);\n+        ::SetConsoleTextAttribute(static_cast<HANDLE>(out_handle_), orig_attribs);\n         print_range_(formatted, msg.color_range_end, formatted.size());\n     }\n     else // print without colors if color range is invalid (or color is disabled)\n@@ -118,16 +126,16 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color_mode(color_mode mode)\n \n // set foreground color and return the orig console attributes (for resetting later)\n template<typename ConsoleMutex>\n-WORD SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_foreground_color_(WORD attribs)\n+std::uint16_t SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_foreground_color_(std::uint16_t attribs)\n {\n     CONSOLE_SCREEN_BUFFER_INFO orig_buffer_info;\n-    ::GetConsoleScreenBufferInfo(out_handle_, &orig_buffer_info);\n+    ::GetConsoleScreenBufferInfo(static_cast<HANDLE>(out_handle_), &orig_buffer_info);\n     WORD back_color = orig_buffer_info.wAttributes;\n     // retrieve the current background color\n     back_color &= static_cast<WORD>(~(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY));\n     // keep the background color unchanged\n-    ::SetConsoleTextAttribute(out_handle_, attribs | back_color);\n-    return orig_buffer_info.wAttributes; // return orig attribs\n+    ::SetConsoleTextAttribute(static_cast<HANDLE>(out_handle_), static_cast<WORD>(attribs) | back_color);\n+    return static_cast<std::uint16_t>(orig_buffer_info.wAttributes); // return orig attribs\n }\n \n // print a range of formatted message to console\n@@ -135,7 +143,7 @@ template<typename ConsoleMutex>\n void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::print_range_(const memory_buf_t &formatted, size_t start, size_t end)\n {\n     auto size = static_cast<DWORD>(end - start);\n-    ::WriteConsoleA(out_handle_, formatted.data() + start, size, nullptr, nullptr);\n+    ::WriteConsoleA(static_cast<HANDLE>(out_handle_), formatted.data() + start, size, nullptr, nullptr);\n }\n \n template<typename ConsoleMutex>\n@@ -147,7 +155,7 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::write_to_file_(const memory_buf_\n     }\n     auto size = static_cast<DWORD>(formatted.size());\n     DWORD bytes_written = 0;\n-    bool ok = ::WriteFile(out_handle_, formatted.data(), size, &bytes_written, nullptr) != 0;\n+    bool ok = ::WriteFile(static_cast<HANDLE>(out_handle_), formatted.data(), size, &bytes_written, nullptr) != 0;\n     if (!ok)\n     {\n         throw_spdlog_ex(\"wincolor_sink: ::WriteFile() failed. GetLastError(): \" + std::to_string(::GetLastError()));\n@@ -165,6 +173,5 @@ template<typename ConsoleMutex>\n SPDLOG_INLINE wincolor_stderr_sink<ConsoleMutex>::wincolor_stderr_sink(color_mode mode)\n     : wincolor_sink<ConsoleMutex>(::GetStdHandle(STD_ERROR_HANDLE), mode)\n {}\n-\n } // namespace sinks\n } // namespace spdlog\ndiff --git a/include/spdlog/sinks/wincolor_sink.h b/include/spdlog/sinks/wincolor_sink.h\n--- a/include/spdlog/sinks/wincolor_sink.h\n+++ b/include/spdlog/sinks/wincolor_sink.h\n@@ -12,9 +12,7 @@\n #include <mutex>\n #include <string>\n #include <array>\n-\n-#include <spdlog/details/windows_include.h>\n-#include <wincon.h>\n+#include <cstdint>\n \n namespace spdlog {\n namespace sinks {\n@@ -26,21 +24,21 @@ template<typename ConsoleMutex>\n class wincolor_sink : public sink\n {\n public:\n-    const WORD BOLD = FOREGROUND_INTENSITY;\n-    const WORD RED = FOREGROUND_RED;\n-    const WORD GREEN = FOREGROUND_GREEN;\n-    const WORD CYAN = FOREGROUND_GREEN | FOREGROUND_BLUE;\n-    const WORD WHITE = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;\n-    const WORD YELLOW = FOREGROUND_RED | FOREGROUND_GREEN;\n-\n-    wincolor_sink(HANDLE out_handle, color_mode mode);\n+    const std::uint16_t BOLD;\n+    const std::uint16_t RED;\n+    const std::uint16_t GREEN;\n+    const std::uint16_t CYAN;\n+    const std::uint16_t WHITE;\n+    const std::uint16_t YELLOW;\n+\n+    wincolor_sink(void *out_handle, color_mode mode);\n     ~wincolor_sink() override;\n \n     wincolor_sink(const wincolor_sink &other) = delete;\n     wincolor_sink &operator=(const wincolor_sink &other) = delete;\n \n     // change the color for the given level\n-    void set_color(level::level_enum level, WORD color);\n+    void set_color(level::level_enum level, std::uint16_t color);\n     void log(const details::log_msg &msg) final override;\n     void flush() final override;\n     void set_pattern(const std::string &pattern) override final;\n@@ -49,15 +47,15 @@ class wincolor_sink : public sink\n \n protected:\n     using mutex_t = typename ConsoleMutex::mutex_t;\n-    HANDLE out_handle_;\n+    void *out_handle_;\n     mutex_t &mutex_;\n     bool in_console_;\n     bool should_do_colors_;\n     std::unique_ptr<spdlog::formatter> formatter_;\n-    std::array<WORD, level::n_levels> colors_;\n+    std::array<std::uint16_t, level::n_levels> colors_;\n \n     // set foreground color and return the orig console attributes (for resetting later)\n-    WORD set_foreground_color_(WORD attribs);\n+    std::uint16_t set_foreground_color_(std::uint16_t attribs);\n \n     // print a range of formatted message to console\n     void print_range_(const memory_buf_t &formatted, size_t start, size_t end);\n@@ -85,7 +83,6 @@ using wincolor_stdout_sink_st = wincolor_stdout_sink<details::console_nullmutex>\n \n using wincolor_stderr_sink_mt = wincolor_stderr_sink<details::console_mutex>;\n using wincolor_stderr_sink_st = wincolor_stderr_sink<details::console_nullmutex>;\n-\n } // namespace sinks\n } // namespace spdlog\n \n", "test_patch": "diff --git a/tests/utils.cpp b/tests/utils.cpp\n--- a/tests/utils.cpp\n+++ b/tests/utils.cpp\n@@ -1,6 +1,8 @@\n #include \"includes.h\"\n \n-#ifndef _WIN32\n+#ifdef _WIN32\n+#include <Windows.h>\n+#else\n #include <sys/types.h>\n #include <dirent.h>\n #endif\n", "problem_statement": "wincolor_sink pulls in windows.h even with SPDLOG_COMPILED_LIB defined\nI don't think it would be too hard to split the dependencies into the inline file. I could make a pr for it if you're okay with that.\n", "hints_text": "Sure, pr would be welcome.", "created_at": "2020-12-26T11:48:09Z"}
{"repo": "gabime/spdlog", "pull_number": 1766, "instance_id": "gabime__spdlog-1766", "issue_numbers": ["1765"], "base_commit": "17c6e6ee3fe720f78bafb5c0d5ce03155cb903cf", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -100,6 +100,7 @@ option(\n     SPDLOG_NO_ATOMIC_LEVELS\n     \"prevent spdlog from using of std::atomic log levels (use only if your code never modifies log levels concurrently\"\n     OFF)\n+option(SPDLOG_DISABLE_DEFAULT_LOGGER \"Disable default logger creation\" OFF)\n \n # clang-tidy\n if(${CMAKE_VERSION} VERSION_GREATER \"3.5\")\n@@ -201,7 +202,8 @@ foreach(\n     SPDLOG_PREVENT_CHILD_FD\n     SPDLOG_NO_THREAD_ID\n     SPDLOG_NO_TLS\n-    SPDLOG_NO_ATOMIC_LEVELS)\n+    SPDLOG_NO_ATOMIC_LEVELS\n+    SPDLOG_DISABLE_DEFAULT_LOGGER)\n     if(${SPDLOG_OPTION})\n         target_compile_definitions(spdlog PUBLIC ${SPDLOG_OPTION})\n         target_compile_definitions(spdlog_header_only INTERFACE ${SPDLOG_OPTION})\n", "test_patch": "", "problem_statement": "SPDLOG_DISABLE_DEFAULT_LOGGER is not a cmake option\nIs there a reason that SPDLOG_DISABLE_DEFAULT_LOGGER is omitted from cmake options?  The other tweakme variables have cmake options as well, which makes things slightly nicer, or at least more uniform, when using spdlog as a dependency.\r\n\r\nWithout it being a proper option, you instead have to do something like this:\r\n```\r\noption(SPDLOG_NO_ATOMIC_LEVELS \"\" ON)\r\nadd_subdirectory(vendor/spdlog)\r\n# no cmake option for this for some reason\r\ntarget_compile_definitions(spdlog PRIVATE\r\n    SPDLOG_DISABLE_DEFAULT_LOGGER\r\n)\r\n``` \r\n\r\nor, when building from the command line, it's perhaps even more annoying:\r\n`CXXFLAGS=\"-DSPDLOG_DISABLE_DEFAULT_LOGGER\" cmake -S. -Bbuild -G \"Unix Makefiles\" -DSPDLOG_NO_ATOMIC_LEVELS -DCMAKE_BUILD_TYPE=Release`\r\n\r\n(CXXFLAGS here must be specified as an env var, rather than using the CMAKE_ version, or it will overwrite and not append.  This is sort of unintuitive and messy)\r\n\r\nIt seems like this could just be added to the existing compiler flag foreach in CMakeLists.txt (as well as adding the option itself, of course) https://github.com/gabime/spdlog/blob/17c6e6ee3fe720f78bafb5c0d5ce03155cb903cf/CMakeLists.txt#L195-L209\r\n\r\nWas there a reason for this to be omitted?\n", "hints_text": "You are right. This should be a cmake option. PR is welcome.", "created_at": "2020-12-18T22:33:18Z"}
{"repo": "gabime/spdlog", "pull_number": 1726, "instance_id": "gabime__spdlog-1726", "issue_numbers": ["1725"], "base_commit": "01b350de96483cf00b267c6db4c25f3b739b3fee", "patch": "diff --git a/include/spdlog/logger.h b/include/spdlog/logger.h\n--- a/include/spdlog/logger.h\n+++ b/include/spdlog/logger.h\n@@ -75,58 +75,58 @@ class SPDLOG_API logger\n \n     // FormatString is a type derived from fmt::compile_string\n     template<typename FormatString, typename std::enable_if<fmt::is_compile_string<FormatString>::value, int>::type = 0, typename... Args>\n-    void log(source_loc loc, level::level_enum lvl, const FormatString &fmt, const Args &...args)\n+    void log(source_loc loc, level::level_enum lvl, const FormatString &fmt, Args&&...args)\n     {\n-        log_(loc, lvl, fmt, args...);\n+        log_(loc, lvl, fmt, std::forward<Args>(args)...);\n     }\n \n     // FormatString is NOT a type derived from fmt::compile_string but is a string_view_t or can be implicitly converted to one\n     template<typename... Args>\n-    void log(source_loc loc, level::level_enum lvl, string_view_t fmt, const Args &...args)\n+    void log(source_loc loc, level::level_enum lvl, string_view_t fmt, Args&&...args)\n     {\n-        log_(loc, lvl, fmt, args...);\n+        log_(loc, lvl, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename FormatString, typename... Args>\n-    void log(level::level_enum lvl, const FormatString &fmt, const Args &...args)\n+    void log(level::level_enum lvl, const FormatString &fmt, Args&&...args)\n     {\n-        log(source_loc{}, lvl, fmt, args...);\n+        log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename FormatString, typename... Args>\n-    void trace(const FormatString &fmt, const Args &...args)\n+    void trace(const FormatString &fmt, Args&&...args)\n     {\n-        log(level::trace, fmt, args...);\n+        log(level::trace, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename FormatString, typename... Args>\n-    void debug(const FormatString &fmt, const Args &...args)\n+    void debug(const FormatString &fmt, Args&&...args)\n     {\n-        log(level::debug, fmt, args...);\n+        log(level::debug, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename FormatString, typename... Args>\n-    void info(const FormatString &fmt, const Args &...args)\n+    void info(const FormatString &fmt, Args&&...args)\n     {\n-        log(level::info, fmt, args...);\n+        log(level::info, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename FormatString, typename... Args>\n-    void warn(const FormatString &fmt, const Args &...args)\n+    void warn(const FormatString &fmt, Args&&...args)\n     {\n-        log(level::warn, fmt, args...);\n+        log(level::warn, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename FormatString, typename... Args>\n-    void error(const FormatString &fmt, const Args &...args)\n+    void error(const FormatString &fmt, Args&&...args)\n     {\n-        log(level::err, fmt, args...);\n+        log(level::err, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename FormatString, typename... Args>\n-    void critical(const FormatString &fmt, const Args &...args)\n+    void critical(const FormatString &fmt, Args&&...args)\n     {\n-        log(level::critical, fmt, args...);\n+        log(level::critical, fmt, std::forward<Args>(args)...);\n     }\n \n     template<typename T>\n@@ -225,7 +225,7 @@ class SPDLOG_API logger\n #else\n \n     template<typename... Args>\n-    void log(source_loc loc, level::level_enum lvl, wstring_view_t fmt, const Args &...args)\n+    void log(source_loc loc, level::level_enum lvl, wstring_view_t fmt, Args&&...args)\n     {\n         bool log_enabled = should_log(lvl);\n         bool traceback_enabled = tracer_.enabled();\n@@ -237,7 +237,7 @@ class SPDLOG_API logger\n         {\n             // format to wmemory_buffer and convert to utf8\n             fmt::wmemory_buffer wbuf;\n-            fmt::format_to(wbuf, fmt, args...);\n+            fmt::format_to(wbuf, fmt, std::forward<Args>(args)...);\n \n             memory_buf_t buf;\n             details::os::wstr_to_utf8buf(wstring_view_t(wbuf.data(), wbuf.size()), buf);\n@@ -326,7 +326,7 @@ class SPDLOG_API logger\n \n     // common implementation for after templated public api has been resolved\n     template<typename FormatString, typename... Args>\n-    void log_(source_loc loc, level::level_enum lvl, const FormatString &fmt, const Args &...args)\n+    void log_(source_loc loc, level::level_enum lvl, const FormatString &fmt, Args&&...args)\n     {\n         bool log_enabled = should_log(lvl);\n         bool traceback_enabled = tracer_.enabled();\n@@ -337,7 +337,7 @@ class SPDLOG_API logger\n         SPDLOG_TRY\n         {\n             memory_buf_t buf;\n-            fmt::format_to(buf, fmt, args...);\n+            fmt::format_to(buf, fmt, std::forward<Args>(args)...);\n             details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));\n             log_it_(log_msg, log_enabled, traceback_enabled);\n         }\ndiff --git a/include/spdlog/pattern_formatter.h b/include/spdlog/pattern_formatter.h\n--- a/include/spdlog/pattern_formatter.h\n+++ b/include/spdlog/pattern_formatter.h\n@@ -92,9 +92,9 @@ class SPDLOG_API pattern_formatter final : public formatter\n     void format(const details::log_msg &msg, memory_buf_t &dest) override;\n \n     template<typename T, typename... Args>\n-    pattern_formatter &add_flag(char flag, const Args &...args)\n+    pattern_formatter &add_flag(char flag, Args&&...args)\n     {\n-        custom_handlers_[flag] = details::make_unique<T>(args...);\n+        custom_handlers_[flag] = details::make_unique<T>(std::forward<Args>(args)...);\n         return *this;\n     }\n     void set_pattern(std::string pattern);\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -128,51 +128,51 @@ SPDLOG_API spdlog::logger *default_logger_raw();\n SPDLOG_API void set_default_logger(std::shared_ptr<spdlog::logger> default_logger);\n \n template<typename FormatString, typename... Args>\n-inline void log(source_loc source, level::level_enum lvl, const FormatString &fmt, const Args &...args)\n+inline void log(source_loc source, level::level_enum lvl, const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->log(source, lvl, fmt, args...);\n+    default_logger_raw()->log(source, lvl, fmt, std::forward<Args>(args)...);\n }\n \n template<typename FormatString, typename... Args>\n-inline void log(level::level_enum lvl, const FormatString &fmt, const Args &...args)\n+inline void log(level::level_enum lvl, const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->log(source_loc{}, lvl, fmt, args...);\n+    default_logger_raw()->log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);\n }\n \n template<typename FormatString, typename... Args>\n-inline void trace(const FormatString &fmt, const Args &...args)\n+inline void trace(const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->trace(fmt, args...);\n+    default_logger_raw()->trace(fmt, std::forward<Args>(args)...);\n }\n \n template<typename FormatString, typename... Args>\n-inline void debug(const FormatString &fmt, const Args &...args)\n+inline void debug(const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->debug(fmt, args...);\n+    default_logger_raw()->debug(fmt, std::forward<Args>(args)...);\n }\n \n template<typename FormatString, typename... Args>\n-inline void info(const FormatString &fmt, const Args &...args)\n+inline void info(const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->info(fmt, args...);\n+    default_logger_raw()->info(fmt, std::forward<Args>(args)...);\n }\n \n template<typename FormatString, typename... Args>\n-inline void warn(const FormatString &fmt, const Args &...args)\n+inline void warn(const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->warn(fmt, args...);\n+    default_logger_raw()->warn(fmt, std::forward<Args>(args)...);\n }\n \n template<typename FormatString, typename... Args>\n-inline void error(const FormatString &fmt, const Args &...args)\n+inline void error(const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->error(fmt, args...);\n+    default_logger_raw()->error(fmt, std::forward<Args>(args)...);\n }\n \n template<typename FormatString, typename... Args>\n-inline void critical(const FormatString &fmt, const Args &...args)\n+inline void critical(const FormatString &fmt, Args&&...args)\n {\n-    default_logger_raw()->critical(fmt, args...);\n+    default_logger_raw()->critical(fmt, std::forward<Args>(args)...);\n }\n \n template<typename T>\n", "test_patch": "", "problem_statement": "Lack of perfect forwarding triggers compile time check in fmt \nIt seems that fmt added some extra checks to prevent lifetime errors when passing views as lvalue references. But spdlog doesn't perfect forward arguments, causing unexpected compile time errors when formatting rvalues.\r\n\r\nspdlog version: 1.8.0\r\nfmt version: 7.1.0\r\n\r\nI'm using the latest version of fmt and speedlog available in vcpkg at this time.\r\n\r\nMinimal example:\r\n\r\n```\r\n#include <fmt/format.h>\r\n#include <spdlog/spdlog.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n\t// This works fine\r\n\tfmt::print(\"Arguments: {0}\", fmt::join(argv, argv + argc, \", \"));\r\n\r\n\t// I would expect this line to work as well\r\n\tspdlog::default_logger()->info(\"Arguments: {0}\", fmt::join(argv, argv + argc, \", \"));\r\n}\r\n```\r\n\r\n```\r\ncmake_minimum_required(VERSION 3.15)\r\nproject(spdlog-error VERSION 1.0.0)\r\n\r\nadd_executable(spdlog-error \"main.cpp\")\r\ntarget_compile_features(spdlog-error INTERFACE cxx_std_20)\r\n\r\nfind_package(fmt CONFIG REQUIRED)\r\nfind_package(spdlog CONFIG REQUIRED)\r\ntarget_link_libraries(spdlog-error PRIVATE fmt::fmt-header-only\r\n                                           spdlog::spdlog_header_only)\r\n```\r\n\r\nOutput with MSVC 16.7.7: \r\n```\r\n[main] Building folder: spdlog-err \r\n[build] Starting build\r\n[proc] Executing command: D:\\Tools\\CMake\\bin\\cmake.EXE --build \"d:/src/spdlog-err/build/Visual Studio Community 2019 Release - amd64/Debug\" --config Debug --target all --parallel -- -j 10\r\n[build] [1/2  50% :: 2.323] Building CXX object CMakeFiles\\spdlog-error.dir\\main.cpp.obj\r\n[build] FAILED: CMakeFiles/spdlog-error.dir/main.cpp.obj \r\n[build] C:\\PROGRA~2\\MICROS~1\\2019\\COMMUN~1\\VC\\Tools\\MSVC\\1427~1.291\\bin\\Hostx64\\x64\\cl.exe  /nologo /TP -DFMT_HEADER_ONLY=1 -DFMT_LOCALE -DFMT_SHARED -DSPDLOG_FMT_EXTERNAL -ID:\\Tools\\vcpkg\\installed\\x64-windows\\include /DWIN32 /D_WINDOWS /GR /EHsc /Zi /Ob0 /Od /RTC1 -MDd /showIncludes /FoCMakeFiles\\spdlog-error.dir\\main.cpp.obj /FdCMakeFiles\\spdlog-error.dir\\ /FS -c ..\\..\\..\\main.cpp\r\n[build] D:\\Tools\\vcpkg\\installed\\x64-windows\\include\\fmt\\core.h(1623): error C2338: passing views as lvalues is disallowed\r\n[build] D:\\Tools\\vcpkg\\installed\\x64-windows\\include\\fmt\\format.h(3825): note: see reference to function template instantiation 'fmt::v7::format_arg_store<fmt::v7::basic_format_context<fmt::v7::detail::buffer_appender<char>,char>,const fmt::v7::arg_join<It,Sentinel,char>> fmt::v7::make_args_checked<const fmt::v7::arg_join<It,Sentinel,char>&,S,char>(const S &,const fmt::v7::arg_join<It,Sentinel,char> &)' being compiled\r\n[build]         with\r\n[build]         [\r\n[build]             It=char *[],\r\n[build]             Sentinel=char *[],\r\n[build]             S=spdlog::string_view_t\r\n[build]         ]\r\n[build] D:\\Tools\\vcpkg\\installed\\x64-windows\\include\\spdlog/logger.h(340): note: see reference to function template instantiation 'fmt::v7::detail::buffer_appender<char> fmt::v7::format_to<FormatString,const fmt::v7::arg_join<It,Sentinel,char>&,250,char>(fmt::v7::basic_memory_buffer<char,250,std::allocator<char>> &,const S &,const fmt::v7::arg_join<It,Sentinel,char> &)' being compiled\r\n[build]         with\r\n[build]         [\r\n[build]             FormatString=spdlog::string_view_t,\r\n[build]             It=char *[],\r\n[build]             Sentinel=char *[],\r\n[build]             S=spdlog::string_view_t\r\n[build]         ]\r\n[build] D:\\Tools\\vcpkg\\installed\\x64-windows\\include\\spdlog/logger.h(87): note: see reference to function template instantiation 'void spdlog::logger::log_<spdlog::string_view_t,fmt::v7::arg_join<It,Sentinel,char>>(spdlog::source_loc,spdlog::level::level_enum,const FormatString &,const fmt::v7::arg_join<It,Sentinel,char> &)' being compiled\r\n[build]         with\r\n[build]         [\r\n[build]             It=char *[],\r\n[build]             Sentinel=char *[],\r\n[build]             FormatString=spdlog::string_view_t\r\n[build]         ]\r\n[build] D:\\Tools\\vcpkg\\installed\\x64-windows\\include\\spdlog/logger.h(93): note: see reference to function template instantiation 'void spdlog::logger::log<fmt::v7::arg_join<It,Sentinel,char>>(spdlog::source_loc,spdlog::level::level_enum,spdlog::string_view_t,const fmt::v7::arg_join<It,Sentinel,char> &)' being compiled\r\n[build]         with\r\n[build]         [\r\n[build]             It=char *[],\r\n[build]             Sentinel=char *[]\r\n[build]         ]\r\n[build] D:\\Tools\\vcpkg\\installed\\x64-windows\\include\\spdlog/logger.h(111): note: see reference to function template instantiation 'void spdlog::logger::log<char[10],fmt::v7::arg_join<It,Sentinel,char>>(spdlog::level::level_enum,const FormatString (&),const fmt::v7::arg_join<It,Sentinel,char> &)' being compiled\r\n[build]         with\r\n[build]         [\r\n[build]             It=char *[],\r\n[build]             Sentinel=char *[],\r\n[build]             FormatString=char [10]\r\n[build]         ]\r\n[build] ..\\..\\..\\main.cpp(6): note: see reference to function template instantiation 'void spdlog::logger::info<char[10],fmt::v7::arg_join<It,Sentinel,char>>(const FormatString (&),const fmt::v7::arg_join<It,Sentinel,char> &)' being compiled\r\n[build]         with\r\n[build]         [\r\n[build]             It=char *[],\r\n[build]             Sentinel=char *[],\r\n[build]             FormatString=char [10]\r\n[build]         ]\r\n[build] ninja: build stopped: subcommand failed.\r\n[cmakefileapi-parser] Code model version (2.1) of cmake-file-api is unexpected. Expecting (2.0). IntelliSense configuration may be incorrect.\r\n[cmakefileapi-parser] Code model version (2.1) of cmake-file-api is unexpected. Expecting (2.0). IntelliSense configuration may be incorrect.\r\n[build] Build finished with exit code 1\r\n```\r\n\r\nOutput with gcc 9.3.0 in WSL\r\n```\r\n[1/2] Building CXX object CMakeFiles/spdlog-error.dir/main.cpp.o\r\nFAILED: CMakeFiles/spdlog-error.dir/main.cpp.o\r\n/usr/bin/c++  -DFMT_HEADER_ONLY=1 -DFMT_LOCALE -DSPDLOG_FMT_EXTERNAL -isystem /home/oot/tools/vcpkg/installed/x64-linux/include -O3 -DNDEBUG -MD -MT CMakeFiles/spdlog-error.dir/main.cpp.o -MF CMakeFiles/spdlog-error.dir/main.cpp.o.d -o CMakeFiles/spdlog-error.dir/main.cpp.o -c ../../main.cpp\r\nIn file included from /home/oot/tools/vcpkg/installed/x64-linux/include/fmt/format.h:45,\r\n                 from ../../main.cpp:1:\r\n/home/oot/tools/vcpkg/installed/x64-linux/include/fmt/core.h: In instantiation of \u2018fmt::v7::format_arg_store<fmt::v7::basic_format_context<fmt::v7::detail::buffer_appender<Char>, Char>, fmt::v7::remove_reference_t<Args>...> fmt::v7::make_args_checked(const S&, fmt::v7::remove_reference_t<Args>& ...) [with Args = {const fmt::v7::arg_join<char**, char**, char>&}; S = fmt::v7::basic_string_view<char>; Char = char]\u2019:\r\n/home/oot/tools/vcpkg/installed/x64-linux/include/fmt/format.h:3825:54:   required from \u2018typename fmt::v7::buffer_context<Char>::iterator fmt::v7::format_to(fmt::v7::basic_memory_buffer<Char, SIZE>&, const S&, Args&& ...) [with S = fmt::v7::basic_string_view<char>; Args = {const fmt::v7::arg_join<char**, char**, char>&}; long unsigned int SIZE = 250; Char = char; typename fmt::v7::buffer_context<Char>::iterator = fmt::v7::detail::buffer_appender<char>]\u2019\r\n/home/oot/tools/vcpkg/installed/x64-linux/include/spdlog/logger.h:340:27:   required from \u2018void spdlog::logger::log_(spdlog::source_loc, spdlog::level::level_enum, const FormatString&, const Args& ...) [with FormatString = fmt::v7::basic_string_view<char>; Args = {fmt::v7::arg_join<char**, char**, char>}]\u2019\r\n/home/oot/tools/vcpkg/installed/x64-linux/include/spdlog/logger.h:87:9:   required from \u2018void spdlog::logger::log(spdlog::source_loc, spdlog::level::level_enum, spdlog::string_view_t, const Args& ...) [with Args = {fmt::v7::arg_join<char**, char**, char>}; spdlog::string_view_t = fmt::v7::basic_string_view<char>]\u2019\r\n/home/oot/tools/vcpkg/installed/x64-linux/include/spdlog/logger.h:93:9:   required from \u2018void spdlog::logger::log(spdlog::level::level_enum, const FormatString&, const Args& ...) [with FormatString = char [15]; Args = {fmt::v7::arg_join<char**, char**, char>}]\u2019\r\n/home/oot/tools/vcpkg/installed/x64-linux/include/spdlog/logger.h:111:9:   required from \u2018void spdlog::logger::info(const FormatString&, const Args& ...) [with FormatString = char [15]; Args = {fmt::v7::arg_join<char**, char**, char>}]\u2019\r\n../../main.cpp:7:85:   required from here\r\n/home/oot/tools/vcpkg/installed/x64-linux/include/fmt/core.h:1623:53: error: static assertion failed: passing views as lvalues is disallowed\r\n 1621 |       detail::count<(\r\n      |       ~~~~~~~~~~~~~~~\r\n 1622 |               std::is_base_of<detail::view, remove_reference_t<Args>>::value &&\r\n      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n 1623 |               std::is_reference<Args>::value)...>() == 0,\r\n      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\r\nninja: build stopped: subcommand failed.\r\n```\r\n\r\nHacking in forwarding allows the program to compile and run as expected.\n", "hints_text": "could you provide a code example to reproduce?\nErr, do you need something in addition to the code I already provided?\nNo, I misread it :)\r\n", "created_at": "2020-11-02T00:38:01Z"}
{"repo": "gabime/spdlog", "pull_number": 1571, "instance_id": "gabime__spdlog-1571", "issue_numbers": ["1570"], "base_commit": "0317731dc91c951a075ff48e2939144a2a1a634b", "patch": "diff --git a/include/spdlog/sinks/daily_file_sink.h b/include/spdlog/sinks/daily_file_sink.h\n--- a/include/spdlog/sinks/daily_file_sink.h\n+++ b/include/spdlog/sinks/daily_file_sink.h\n@@ -155,7 +155,7 @@ class daily_file_sink final : public base_sink<Mutex>\n         using details::os::filename_to_str;\n         using details::os::remove_if_exists;\n \n-        filename_t current_file = filename();\n+        filename_t current_file = file_helper_.filename();\n         if (filenames_q_.full())\n         {\n             auto old_filename = std::move(filenames_q_.front());\n", "test_patch": "", "problem_statement": "daily_file_sink has deadlock bug\nThe `sink_it` function of `daily_file_sink` runs under a lock, however it can call `delete_old_`, which internally calls `filename()`. `filename()` tries to acquire the lock, which is already held open. This leads to deadlock.\r\n\r\nHappy to fix.\n", "hints_text": "Right. Good catch. Strange that nobody encountered this so far..\r\nFix is welcome\nI think some exception handling is swallowing the issue.\nI dont exception would happen. just a deadlock after few days when its time to clean old.\nWhat I meant is that when the deadlock occurs, an exception occurs and gets swallowed. This is the behaviour I'm seeing when delete_old_ gets called. Could just be undefined behaviour.\nThis is a critical bug actually. I will release new version 1.6.1 as soon as you do the fix (and maybe upgrade the bundled  fmt as well)", "created_at": "2020-05-26T20:37:01Z"}
{"repo": "gabime/spdlog", "pull_number": 1444, "instance_id": "gabime__spdlog-1444", "issue_numbers": ["1432"], "base_commit": "c9e094d9fc3053e9c1f83e12215ba3b6c519dbef", "patch": "diff --git a/include/spdlog/sinks/win_eventlog_sink.h b/include/spdlog/sinks/win_eventlog_sink.h\n--- a/include/spdlog/sinks/win_eventlog_sink.h\n+++ b/include/spdlog/sinks/win_eventlog_sink.h\n@@ -219,7 +219,7 @@ class win_eventlog_sink : public base_sink<Mutex>\n         using namespace internal;\n \n         memory_buf_t formatted;\n-        formatter_->format(msg, formatted);\n+        base_sink<Mutex>::formatter_->format(msg, formatted);\n         formatted.push_back('\\0');\n         LPCSTR lp_str = static_cast<LPCSTR>(formatted.data());\n \n", "test_patch": "", "problem_statement": "Failed to build tests on Windows with MSYS2/MinGW-w64\nFailed to build target `spdlog-utests` on Windows with MSYS2/MinGW64.\r\n\r\nError below was reported:\r\n```\r\n[ 30%] Building CXX object tests/CMakeFiles/spdlog-utests.dir/test_eventlog.cpp.obj\r\nIn file included from X:\\path\\to\\spdlog\\tests\\test_eventlog.cpp:6:\r\nX:/path/to/spdlog/include/spdlog/sinks/win_eventlog_sink.h: In member function 'void spdlog::sinks::win_eventlog::win_eventlog_sink<Mutex>::sink_it_(const spdlog::details::log_msg&)':\r\nX:/path/to/spdlog/include/spdlog/sinks/win_eventlog_sink.h:222:9: error: 'formatter_' was not declared in this scope; did you mean 'formatter'?\r\n  222 |         formatter_->format(msg, formatted);\r\n      |         ^~~~~~~~~~\r\n      |         formatter\r\ncompilation terminated due to -Wfatal-errors.\r\nmingw32-make.exe[3]: *** [tests\\CMakeFiles\\spdlog-utests.dir\\build.make:119: tests/CMakeFiles/spdlog-utests.dir/test_eventlog.cpp.obj] Error 1\r\nmingw32-make.exe[2]: *** [CMakeFiles\\Makefile2:170: tests/CMakeFiles/spdlog-utests.dir/all] Error 2\r\nmingw32-make.exe[1]: *** [CMakeFiles\\Makefile2:177: tests/CMakeFiles/spdlog-utests.dir/rule] Error 2\r\nmingw32-make.exe: *** [Makefile:222: spdlog-utests] Error 2\r\n```\r\n\r\nBy adding `this->` before `formatter_`, the error could be fixed:\r\n```C++\r\nthis->formatter_->format(msg, formatted);\r\n```\r\n\r\nI thought it should be ok to reference a `protected` attribute without `this->`. Maybe another MinGW bug?\n", "hints_text": "", "created_at": "2020-02-17T17:22:57Z"}
{"repo": "gabime/spdlog", "pull_number": 1422, "instance_id": "gabime__spdlog-1422", "issue_numbers": ["1247"], "base_commit": "4e643fa42c4c502993e79010eff72c5ed3c1319f", "patch": "diff --git a/example/CMakeLists.txt b/example/CMakeLists.txt\n--- a/example/CMakeLists.txt\n+++ b/example/CMakeLists.txt\n@@ -4,6 +4,8 @@\n cmake_minimum_required(VERSION 3.1)\n project(spdlog_examples CXX)\n \n+include(../cmake/utils.cmake)\n+\n if(NOT TARGET spdlog)\n     # Stand-alone build\n     find_package(spdlog REQUIRED)\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -1,5 +1,12 @@\n+cmake_minimum_required(VERSION 3.2)\n+\n project(spdlog_utests CXX)\n \n+if(NOT TARGET spdlog)\n+    # Stand-alone build\n+    find_package(spdlog REQUIRED)\n+endif()\n+\n include(../cmake/utils.cmake)\n \n find_package(PkgConfig)\n", "problem_statement": "Request: post installation runnable tests\nHello,\r\n\r\nI'm updating the spdlog package for Debian and I'm no longer easily able to run the tests against the installed headers due to the removal of the standalone `tests/Makefile`.\r\n\r\nHere is the current setup\r\n```\r\n# this is after copying the contents of the tests directory from the libspdlog-dev package to the # temporary working directory\r\ncmake -DSPDLOG_BUILD_TESTS=ON -DSPDLOG_BUILD_TESTS_HO=ON .\r\nmake CFLAGS=-DSPDLOG_FMT_EXTERNAL\r\nmake test\r\n```\r\n\r\nAnd the current result\r\n\r\n```\r\n-- The CXX compiler identification is GNU 9.2.1\r\n-- Check for working CXX compiler: /usr/bin/c++\r\n-- Check for working CXX compiler: /usr/bin/c++ -- works\r\n-- Detecting CXX compiler ABI info\r\n-- Detecting CXX compiler ABI info - done\r\n-- Detecting CXX compile features\r\n-- Detecting CXX compile features - done\r\n-- Found PkgConfig: /usr/bin/pkg-config (found version \"0.29\") \r\n-- Checking for module 'libsystemd'\r\n--   Found libsystemd, version 242\r\nCMake Warning (dev) in CMakeLists.txt:\r\n  No cmake_minimum_required command is present.  A line of code such as\r\n\r\n    cmake_minimum_required(VERSION 3.13)\r\n\r\n  should be added at the top of the file.  The version specified may be lower\r\n  if you wish to support older CMake versions for this project.  For more\r\n  information run \"cmake --help-policy CMP0000\".\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Configuring done\r\nCMake Warning (dev) at CMakeLists.txt:58 (add_executable):\r\n  Policy CMP0028 is not set: Double colon in target name means ALIAS or\r\n  IMPORTED target.  Run \"cmake --help-policy CMP0028\" for policy details.\r\n  Use the cmake_policy command to set the policy and suppress this warning.\r\n\r\n  Target \"spdlog-utests-ho\" links to target \"spdlog::spdlog_header_only\" but\r\n  the target was not found.  Perhaps a find_package() call is missing for an\r\n  IMPORTED target, or an ALIAS target is missing?\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Generating done\r\n-- Build files have been written to: /tmp/autopkgtest.u6TQBq/autopkgtest_tmp/tests\r\nScanning dependencies of target spdlog-utests\r\n[  2%] Building CXX object CMakeFiles/spdlog-utests.dir/test_file_helper.o\r\nIn file included from /usr/include/spdlog/common.h:38,\r\n                 from /usr/include/spdlog/spdlog.h:12,\r\n                 from /tmp/autopkgtest.u6TQBq/autopkgtest_tmp/tests/includes.h:17,\r\n                 from /tmp/autopkgtest.u6TQBq/autopkgtest_tmp/tests/test_file_helper.cpp:4:\r\n/usr/include/spdlog/fmt/fmt.h:22:10: fatal error: bundled/core.h: No such file or directory\r\n   22 | #include \"bundled/core.h\"\r\n      |          ^~~~~~~~~~~~~~~~\r\ncompilation terminated.\r\n```\r\n\r\n```\r\n\n", "hints_text": "Not sure I understand whats going on here,  but you probably need to pass the \u201c-DSPDLOG_FMT_EXTERNAL\u201d to the CMake command as well.\n`SPDLOG_FMT_EXTERNAL` is not an option for `tests/CMakeLists.txt`\r\n\r\n```\r\n$ cmake -DSPDLOG_BUILD_TESTS=ON -DSPDLOG_BUILD_TESTS_HO=ON -DSPDLOG_FMT_EXTERNAL=ON .\r\n-- The CXX compiler identification is GNU 9.2.1\r\n-- Check for working CXX compiler: /usr/bin/c++\r\n-- Check for working CXX compiler: /usr/bin/c++ -- works\r\n-- Detecting CXX compiler ABI info\r\n-- Detecting CXX compiler ABI info - done\r\n-- Detecting CXX compile features\r\n-- Detecting CXX compile features - done\r\n-- Found PkgConfig: /usr/bin/pkg-config (found version \"0.29\") \r\n-- Checking for module 'libsystemd'\r\n--   Found libsystemd, version 242\r\nCMake Warning (dev) in CMakeLists.txt:\r\n  No cmake_minimum_required command is present.  A line of code such as\r\n\r\n    cmake_minimum_required(VERSION 3.13)\r\n\r\n  should be added at the top of the file.  The version specified may be lower\r\n  if you wish to support older CMake versions for this project.  For more\r\n  information run \"cmake --help-policy CMP0000\".\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Configuring done\r\nCMake Warning (dev) at CMakeLists.txt:58 (add_executable):\r\n  Policy CMP0028 is not set: Double colon in target name means ALIAS or\r\n  IMPORTED target.  Run \"cmake --help-policy CMP0028\" for policy details.\r\n  Use the cmake_policy command to set the policy and suppress this warning.\r\n\r\n  Target \"spdlog-utests-ho\" links to target \"spdlog::spdlog_header_only\" but\r\n  the target was not found.  Perhaps a find_package() call is missing for an\r\n  IMPORTED target, or an ALIAS target is missing?\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Generating done\r\nCMake Warning:\r\n  Manually-specified variables were not used by the project:\r\n\r\n    SPDLOG_FMT_EXTERNAL\r\n\r\n\r\n-- Build files have been written to: /tmp/autopkgtest.uxh3Fa/autopkgtest_tmp/tests\r\n$ make CFLAGS=-DSPDLOG_FMT_EXTERNAL spdlog-utests-ho spdlog-utests\r\nScanning dependencies of target spdlog-utests-ho\r\n[  5%] Building CXX object CMakeFiles/spdlog-utests-ho.dir/test_file_helper.o\r\nIn file included from /usr/include/spdlog/common.h:38,\r\n                 from /usr/include/spdlog/spdlog.h:12,\r\n                 from /tmp/autopkgtest.uxh3Fa/autopkgtest_tmp/tests/includes.h:17,\r\n                 from /tmp/autopkgtest.uxh3Fa/autopkgtest_tmp/tests/test_file_helper.cpp:4:\r\n/usr/include/spdlog/fmt/fmt.h:22:10: fatal error: bundled/core.h: No such file or directory\r\n   22 | #include \"bundled/core.h\"\r\n      |          ^~~~~~~~~~~~~~~~\r\ncompilation terminated.\r\n\r\n```\n> Target \"spdlog-utests-ho\" links to target \"spdlog::spdlog_header_only\" but\r\n  the target was not found.\r\n\r\nPerhaps the has something to do with this? To not setting right define(SPDLOG_FMT_EXTERNAL).\n> Perhaps the has something to do with this? To not setting right define(SPDLOG_FMT_EXTERNAL).\r\n\r\nI'm not clear as to what you are suggesting here\r\n\r\nAlso, can this issue be re-opened?\n@mr-c Where can I download and try the package for Debian ? Seems very old \n@gabime https://packages.debian.org/search?keywords=spdlog has the released packages The latest package is for 1.3.1, the January release\r\n\r\nThe current packaging source is at https://salsa.debian.org/med-team/spdlog", "created_at": "2020-02-07T14:41:08Z"}
{"repo": "gabime/spdlog", "pull_number": 1292, "instance_id": "gabime__spdlog-1292", "issue_numbers": ["1289"], "base_commit": "2b8afb38b73a457f2e160e25bad795c8b0d98613", "patch": "diff --git a/include/spdlog/sinks/systemd_sink.h b/include/spdlog/sinks/systemd_sink.h\n--- a/include/spdlog/sinks/systemd_sink.h\n+++ b/include/spdlog/sinks/systemd_sink.h\n@@ -8,6 +8,9 @@\n #include \"spdlog/details/synchronous_factory.h\"\n \n #include <array>\n+#ifndef SD_JOURNAL_SUPPRESS_LOCATION\n+#define SD_JOURNAL_SUPPRESS_LOCATION\n+#endif\n #include <systemd/sd-journal.h>\n \n namespace spdlog {\n@@ -58,12 +61,14 @@ class systemd_sink : public base_sink<Mutex>\n         {\n             // Note: function call inside '()' to avoid macro expansion\n             err = (sd_journal_send)(\n-                \"MESSAGE=%.*s\", static_cast<int>(length), msg.payload.data(), \"PRIORITY=%d\", syslog_level(msg.level), nullptr);\n+                \"MESSAGE=%.*s\", static_cast<int>(length), msg.payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n+                \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(msg.logger_name.size()), msg.logger_name.data(), nullptr);\n         }\n         else\n         {\n             err = (sd_journal_send)(\"MESSAGE=%.*s\", static_cast<int>(length), msg.payload.data(), \"PRIORITY=%d\", syslog_level(msg.level),\n-                \"SOURCE_FILE=%s\", msg.source.filename, \"SOURCE_LINE=%d\", msg.source.line, \"SOURCE_FUNC=%s\", msg.source.funcname, nullptr);\n+                \"SYSLOG_IDENTIFIER=%.*s\", static_cast<int>(msg.logger_name.size()), msg.logger_name.data(),\n+                \"CODE_FILE=%s\", msg.source.filename, \"CODE_LINE=%d\", msg.source.line, \"CODE_FUNC=%s\", msg.source.funcname, nullptr);\n         }\n \n         if (err)\n", "test_patch": "", "problem_statement": "systemd-journald sink does not log logger name\nMy application uses several loggers. When I use an `spdlog::sinks::ansicolor_stderr_sink_mt`, the output contains (among other things) the logger's name. When I switch to using `spdlog::sinks::systemd_sink_mt`, the logger name is not available anymore.\r\n\r\nI think that this is because the systemd/journald sink does not use `spdlog::base_sink::formatter_` at all even though it inherits from `base_sink`. I suspect that this might have been due to the fact that the default formatter outputs stuff such as date/time/priority which is available via other means with journald. The logger name, however, is effectively lost this way.\n", "hints_text": "", "created_at": "2019-10-30T13:09:14Z"}
{"repo": "gabime/spdlog", "pull_number": 1240, "instance_id": "gabime__spdlog-1240", "issue_numbers": ["1239"], "base_commit": "e42867f0a81a7bbe5f8b3c9dbfd2acca5e4b5f32", "patch": "diff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -107,7 +107,7 @@ using memory_buf_t = fmt::basic_memory_buffer<char, 250>;\n #ifndef _WIN32\n #error SPDLOG_WCHAR_TO_UTF8_SUPPORT only supported on windows\n #else\n-using wstring_view_t = basic_string_view_t<wchar_t>;\n+using wstring_view_t = fmt::basic_string_view<wchar_t>;\n \n template<typename T>\n struct is_convertible_to_wstring_view : std::is_convertible<T, wstring_view_t>\ndiff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -424,7 +424,7 @@ SPDLOG_INLINE bool in_terminal(FILE *file) SPDLOG_NOEXCEPT\n }\n \n #if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n-SPDLOG_INLINE void wstr_to_utf8buf(basic_string_view_t<wchar_t> wstr, memory_buf_t &target)\n+SPDLOG_INLINE void wstr_to_utf8buf(wstring_view_t wstr, memory_buf_t &target)\n {\n     if (wstr.size() > static_cast<size_t>(std::numeric_limits<int>::max()))\n     {\ndiff --git a/include/spdlog/details/os.h b/include/spdlog/details/os.h\n--- a/include/spdlog/details/os.h\n+++ b/include/spdlog/details/os.h\n@@ -86,7 +86,7 @@ bool is_color_terminal() SPDLOG_NOEXCEPT;\n bool in_terminal(FILE *file) SPDLOG_NOEXCEPT;\n \n #if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n-void wstr_to_utf8buf(basic_string_view_t<wchar_t> wstr, memory_buf_t &target);\n+void wstr_to_utf8buf(wstring_view_t wstr, memory_buf_t &target);\n #endif\n \n } // namespace os\n", "test_patch": "", "problem_statement": "Can't build with SPDLOG_WCHAR_TO_UTF8_SUPPORT since commit 5496491\nSince commit 5496491aa487fded09059a70c91547549e67118e, `basic_string_view_t` is gone.\r\n\r\nBut still in the definition of `wstring_view_t` need `basic_string_view_t`.\n", "hints_text": "", "created_at": "2019-09-23T05:53:28Z"}
{"repo": "gabime/spdlog", "pull_number": 1228, "instance_id": "gabime__spdlog-1228", "issue_numbers": ["722"], "base_commit": "e771f4e75e0275c436bfad2ef03910347918e7c0", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -1,7 +1,7 @@\n # Copyright(c) 2019 spdlog authors\n # Distributed under the MIT License (http://opensource.org/licenses/MIT)\n \n-cmake_minimum_required(VERSION 3.2)\n+cmake_minimum_required(VERSION 3.14)\n \n #---------------------------------------------------------------------------------------\n # Start spdlog project\n@@ -197,7 +197,11 @@ if (SPDLOG_INSTALL)\n \n     include(CMakePackageConfigHelpers)\n     configure_file(\"${project_config_in}\" \"${project_config_out}\" @ONLY)\n-    write_basic_package_version_file(\"${version_config_file}\" COMPATIBILITY SameMajorVersion)\n+    if(${CMAKE_VERSION} VERSION_GREATER 3.13)\n+        write_basic_package_version_file(\"${version_config_file}\" COMPATIBILITY SameMajorVersion ARCH_INDEPENDENT)\n+    else()\n+        write_basic_package_version_file(\"${version_config_file}\" COMPATIBILITY SameMajorVersion)\n+    endif()\n     install(FILES\n             \"${project_config_out}\"\n             \"${version_config_file}\" DESTINATION \"${export_dest_dir}\")\n", "test_patch": "", "problem_statement": "CMake config enforces 32/64 bitness\nspdlog is enforcing 32 or 64 bit mode in the CMake config, which I don't think makes sense for a header-only library.\r\n\r\nPackage spdlog 0.17.0 using [the instructions](https://github.com/gabime/spdlog/wiki/9.-CMake):\r\n\r\n```\r\n[spdlog]> cmake -H. -B_builds -DCMAKE_INSTALL_PREFIX=/path/to/install -DCMAKE_BUILD_TYPE=Release\r\n[spdlog]> cmake --build _builds --target install\r\n```\r\n\r\nOn Windows 7 with the Visual Studio 2015 generator, but I believe the principle is generic, if you use the 32-bit compiler then `spdlogConfigVersion.cmake` enforces that:\r\n\r\n```cmake\r\n# if the installed or the using project don't have CMAKE_SIZEOF_VOID_P set, ignore it:\r\nif(\"${CMAKE_SIZEOF_VOID_P}\" STREQUAL \"\" OR \"4\" STREQUAL \"\")\r\n   return()\r\nendif()\r\n\r\n# check that the installed version has the same 32/64bit-ness as the one which is currently searching:\r\nif(NOT CMAKE_SIZEOF_VOID_P STREQUAL \"4\")\r\n  math(EXPR installedBits \"4 * 8\")\r\n  set(PACKAGE_VERSION \"${PACKAGE_VERSION} (${installedBits}bit)\")\r\n  set(PACKAGE_VERSION_UNSUITABLE TRUE)\r\nendif()\r\n```\r\n\r\nAnd vice-versa if building for 64-bit.\r\n\r\nSo this can fail:\r\n\r\n```cmake\r\nfind_package(spdlog 0.17.0 CONFIG REQUIRED)\r\n```\r\n\r\nWith:\r\n\r\n```\r\nCMake Error at CMakeLists.txt:14 (find_package):\r\n  Could not find a configuration file for package \"spdlog\" that is compatible\r\n  with requested version \"0.17.0\".\r\n\r\n  The following configuration files were considered but not accepted:\r\n\r\n    C:/tools/spdlog-0.17.0/lib/cmake/spdlog/spdlogConfig.cmake, version: 0.17.0 (32bit)\r\n```\r\n\r\nEven though the right version is present.\n", "hints_text": "Agreed. PR would be welcome.\nRelated CMake issue:\r\n\r\nhttps://gitlab.kitware.com/cmake/cmake/issues/16184\r\n\r\nMight not be a clean fix while that is unresolved.  Certainly don't want to maintain a copy of those templates.\n@jakecobb Yes. Seems more like a cmake issue, so I will close this if no feasible solution exists.", "created_at": "2019-09-17T17:17:44Z"}
{"repo": "gabime/spdlog", "pull_number": 1213, "instance_id": "gabime__spdlog-1213", "issue_numbers": ["1077"], "base_commit": "65d02e495e25b6440195481c4e573e65ccf5c939", "patch": "diff --git a/include/spdlog/fmt/bundled/chrono.h b/include/spdlog/fmt/bundled/chrono.h\n--- a/include/spdlog/fmt/bundled/chrono.h\n+++ b/include/spdlog/fmt/bundled/chrono.h\n@@ -16,9 +16,181 @@\n #include <locale>\n #include <sstream>\n \n+// enable safe chrono durations, unless explicitly disabled\n+#ifndef FMT_SAFE_DURATION_CAST\n+#  define FMT_SAFE_DURATION_CAST 1\n+#endif\n+\n+#if FMT_SAFE_DURATION_CAST\n+#  include \"safe-duration-cast.h\"\n+#endif\n+\n FMT_BEGIN_NAMESPACE\n \n-namespace internal{\n+// Prevents expansion of a preceding token as a function-style macro.\n+// Usage: f FMT_NOMACRO()\n+#define FMT_NOMACRO\n+\n+namespace internal {\n+inline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }\n+inline null<> localtime_s(...) { return null<>(); }\n+inline null<> gmtime_r(...) { return null<>(); }\n+inline null<> gmtime_s(...) { return null<>(); }\n+}  // namespace internal\n+\n+// Thread-safe replacement for std::localtime\n+inline std::tm localtime(std::time_t time) {\n+  struct dispatcher {\n+    std::time_t time_;\n+    std::tm tm_;\n+\n+    dispatcher(std::time_t t) : time_(t) {}\n+\n+    bool run() {\n+      using namespace fmt::internal;\n+      return handle(localtime_r(&time_, &tm_));\n+    }\n+\n+    bool handle(std::tm* tm) { return tm != nullptr; }\n+\n+    bool handle(internal::null<>) {\n+      using namespace fmt::internal;\n+      return fallback(localtime_s(&tm_, &time_));\n+    }\n+\n+    bool fallback(int res) { return res == 0; }\n+\n+#if !FMT_MSC_VER\n+    bool fallback(internal::null<>) {\n+      using namespace fmt::internal;\n+      std::tm* tm = std::localtime(&time_);\n+      if (tm) tm_ = *tm;\n+      return tm != nullptr;\n+    }\n+#endif\n+  };\n+  dispatcher lt(time);\n+  // Too big time values may be unsupported.\n+  if (!lt.run()) FMT_THROW(format_error(\"time_t value out of range\"));\n+  return lt.tm_;\n+}\n+\n+// Thread-safe replacement for std::gmtime\n+inline std::tm gmtime(std::time_t time) {\n+  struct dispatcher {\n+    std::time_t time_;\n+    std::tm tm_;\n+\n+    dispatcher(std::time_t t) : time_(t) {}\n+\n+    bool run() {\n+      using namespace fmt::internal;\n+      return handle(gmtime_r(&time_, &tm_));\n+    }\n+\n+    bool handle(std::tm* tm) { return tm != nullptr; }\n+\n+    bool handle(internal::null<>) {\n+      using namespace fmt::internal;\n+      return fallback(gmtime_s(&tm_, &time_));\n+    }\n+\n+    bool fallback(int res) { return res == 0; }\n+\n+#if !FMT_MSC_VER\n+    bool fallback(internal::null<>) {\n+      std::tm* tm = std::gmtime(&time_);\n+      if (tm) tm_ = *tm;\n+      return tm != nullptr;\n+    }\n+#endif\n+  };\n+  dispatcher gt(time);\n+  // Too big time values may be unsupported.\n+  if (!gt.run()) FMT_THROW(format_error(\"time_t value out of range\"));\n+  return gt.tm_;\n+}\n+\n+namespace internal {\n+inline std::size_t strftime(char* str, std::size_t count, const char* format,\n+                            const std::tm* time) {\n+  return std::strftime(str, count, format, time);\n+}\n+\n+inline std::size_t strftime(wchar_t* str, std::size_t count,\n+                            const wchar_t* format, const std::tm* time) {\n+  return std::wcsftime(str, count, format, time);\n+}\n+}  // namespace internal\n+\n+template <typename Char> struct formatter<std::tm, Char> {\n+  template <typename ParseContext>\n+  auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n+    auto it = ctx.begin();\n+    if (it != ctx.end() && *it == ':') ++it;\n+    auto end = it;\n+    while (end != ctx.end() && *end != '}') ++end;\n+    tm_format.reserve(internal::to_unsigned(end - it + 1));\n+    tm_format.append(it, end);\n+    tm_format.push_back('\\0');\n+    return end;\n+  }\n+\n+  template <typename FormatContext>\n+  auto format(const std::tm& tm, FormatContext& ctx) -> decltype(ctx.out()) {\n+    basic_memory_buffer<Char> buf;\n+    std::size_t start = buf.size();\n+    for (;;) {\n+      std::size_t size = buf.capacity() - start;\n+      std::size_t count =\n+          internal::strftime(&buf[start], size, &tm_format[0], &tm);\n+      if (count != 0) {\n+        buf.resize(start + count);\n+        break;\n+      }\n+      if (size >= tm_format.size() * 256) {\n+        // If the buffer is 256 times larger than the format string, assume\n+        // that `strftime` gives an empty result. There doesn't seem to be a\n+        // better way to distinguish the two cases:\n+        // https://github.com/fmtlib/fmt/issues/367\n+        break;\n+      }\n+      const std::size_t MIN_GROWTH = 10;\n+      buf.reserve(buf.capacity() + (size > MIN_GROWTH ? size : MIN_GROWTH));\n+    }\n+    return std::copy(buf.begin(), buf.end(), ctx.out());\n+  }\n+\n+  basic_memory_buffer<Char> tm_format;\n+};\n+\n+namespace internal {\n+template <typename Period> FMT_CONSTEXPR const char* get_units() {\n+  return nullptr;\n+}\n+template <> FMT_CONSTEXPR const char* get_units<std::atto>() { return \"as\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::femto>() { return \"fs\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::pico>() { return \"ps\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::nano>() { return \"ns\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::micro>() { return \"\u00b5s\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::milli>() { return \"ms\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::centi>() { return \"cs\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::deci>() { return \"ds\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::ratio<1>>() { return \"s\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::deca>() { return \"das\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::hecto>() { return \"hs\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::kilo>() { return \"ks\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::mega>() { return \"Ms\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::giga>() { return \"Gs\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::tera>() { return \"Ts\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::peta>() { return \"Ps\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::exa>() { return \"Es\"; }\n+template <> FMT_CONSTEXPR const char* get_units<std::ratio<60>>() {\n+  return \"m\";\n+}\n+template <> FMT_CONSTEXPR const char* get_units<std::ratio<3600>>() {\n+  return \"h\";\n+}\n \n enum class numeric_system {\n   standard,\n@@ -28,8 +200,9 @@ enum class numeric_system {\n \n // Parses a put_time-like format string and invokes handler actions.\n template <typename Char, typename Handler>\n-FMT_CONSTEXPR const Char *parse_chrono_format(\n-    const Char *begin, const Char *end, Handler &&handler) {\n+FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,\n+                                              const Char* end,\n+                                              Handler&& handler) {\n   auto ptr = begin;\n   while (ptr != end) {\n     auto c = *ptr;\n@@ -38,11 +211,9 @@ FMT_CONSTEXPR const Char *parse_chrono_format(\n       ++ptr;\n       continue;\n     }\n-    if (begin != ptr)\n-      handler.on_text(begin, ptr);\n-    ++ptr; // consume '%'\n-    if (ptr == end)\n-      throw format_error(\"invalid format\");\n+    if (begin != ptr) handler.on_text(begin, ptr);\n+    ++ptr;  // consume '%'\n+    if (ptr == end) FMT_THROW(format_error(\"invalid format\"));\n     c = *ptr++;\n     switch (c) {\n     case '%':\n@@ -119,6 +290,12 @@ FMT_CONSTEXPR const Char *parse_chrono_format(\n     case 'p':\n       handler.on_am_pm();\n       break;\n+    case 'Q':\n+      handler.on_duration_value();\n+      break;\n+    case 'q':\n+      handler.on_duration_unit();\n+      break;\n     case 'z':\n       handler.on_utc_offset();\n       break;\n@@ -127,8 +304,7 @@ FMT_CONSTEXPR const Char *parse_chrono_format(\n       break;\n     // Alternative representation:\n     case 'E': {\n-      if (ptr == end)\n-        throw format_error(\"invalid format\");\n+      if (ptr == end) FMT_THROW(format_error(\"invalid format\"));\n       c = *ptr++;\n       switch (c) {\n       case 'c':\n@@ -141,13 +317,12 @@ FMT_CONSTEXPR const Char *parse_chrono_format(\n         handler.on_loc_time(numeric_system::alternative);\n         break;\n       default:\n-        throw format_error(\"invalid format\");\n+        FMT_THROW(format_error(\"invalid format\"));\n       }\n       break;\n     }\n     case 'O':\n-      if (ptr == end)\n-        throw format_error(\"invalid format\");\n+      if (ptr == end) FMT_THROW(format_error(\"invalid format\"));\n       c = *ptr++;\n       switch (c) {\n       case 'w':\n@@ -169,96 +344,259 @@ FMT_CONSTEXPR const Char *parse_chrono_format(\n         handler.on_second(numeric_system::alternative);\n         break;\n       default:\n-        throw format_error(\"invalid format\");\n+        FMT_THROW(format_error(\"invalid format\"));\n       }\n       break;\n     default:\n-      throw format_error(\"invalid format\");\n+      FMT_THROW(format_error(\"invalid format\"));\n     }\n     begin = ptr;\n   }\n-  if (begin != ptr)\n-    handler.on_text(begin, ptr);\n+  if (begin != ptr) handler.on_text(begin, ptr);\n   return ptr;\n }\n \n struct chrono_format_checker {\n-  void report_no_date() { throw format_error(\"no date\"); }\n-\n-  template <typename Char>\n-  void on_text(const Char *, const Char *) {}\n-  void on_abbr_weekday() { report_no_date(); }\n-  void on_full_weekday() { report_no_date(); }\n-  void on_dec0_weekday(numeric_system) { report_no_date(); }\n-  void on_dec1_weekday(numeric_system) { report_no_date(); }\n-  void on_abbr_month() { report_no_date(); }\n-  void on_full_month() { report_no_date(); }\n+  FMT_NORETURN void report_no_date() { FMT_THROW(format_error(\"no date\")); }\n+\n+  template <typename Char> void on_text(const Char*, const Char*) {}\n+  FMT_NORETURN void on_abbr_weekday() { report_no_date(); }\n+  FMT_NORETURN void on_full_weekday() { report_no_date(); }\n+  FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }\n+  FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }\n+  FMT_NORETURN void on_abbr_month() { report_no_date(); }\n+  FMT_NORETURN void on_full_month() { report_no_date(); }\n   void on_24_hour(numeric_system) {}\n   void on_12_hour(numeric_system) {}\n   void on_minute(numeric_system) {}\n   void on_second(numeric_system) {}\n-  void on_datetime(numeric_system) { report_no_date(); }\n-  void on_loc_date(numeric_system) { report_no_date(); }\n-  void on_loc_time(numeric_system) { report_no_date(); }\n-  void on_us_date() { report_no_date(); }\n-  void on_iso_date() { report_no_date(); }\n+  FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }\n+  FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }\n+  FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }\n+  FMT_NORETURN void on_us_date() { report_no_date(); }\n+  FMT_NORETURN void on_iso_date() { report_no_date(); }\n   void on_12_hour_time() {}\n   void on_24_hour_time() {}\n   void on_iso_time() {}\n   void on_am_pm() {}\n-  void on_utc_offset() { report_no_date(); }\n-  void on_tz_name() { report_no_date(); }\n+  void on_duration_value() {}\n+  void on_duration_unit() {}\n+  FMT_NORETURN void on_utc_offset() { report_no_date(); }\n+  FMT_NORETURN void on_tz_name() { report_no_date(); }\n };\n \n-template <typename Int>\n-inline int to_int(Int value) {\n-  FMT_ASSERT(value >= (std::numeric_limits<int>::min)() &&\n-             value <= (std::numeric_limits<int>::max)(), \"invalid value\");\n+template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+inline bool isnan(T) {\n+  return false;\n+}\n+template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n+inline bool isnan(T value) {\n+  return std::isnan(value);\n+}\n+\n+template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+inline bool isfinite(T) {\n+  return true;\n+}\n+template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n+inline bool isfinite(T value) {\n+  return std::isfinite(value);\n+}\n+\n+// Convers value to int and checks that it's in the range [0, upper).\n+template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+inline int to_nonnegative_int(T value, int upper) {\n+  FMT_ASSERT(value >= 0 && value <= upper, \"invalid value\");\n+  (void)upper;\n   return static_cast<int>(value);\n }\n+template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>\n+inline int to_nonnegative_int(T value, int upper) {\n+  FMT_ASSERT(\n+      std::isnan(value) || (value >= 0 && value <= static_cast<T>(upper)),\n+      \"invalid value\");\n+  (void)upper;\n+  return static_cast<int>(value);\n+}\n+\n+template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+inline T mod(T x, int y) {\n+  return x % y;\n+}\n+template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n+inline T mod(T x, int y) {\n+  return std::fmod(x, static_cast<T>(y));\n+}\n+\n+// If T is an integral type, maps T to its unsigned counterpart, otherwise\n+// leaves it unchanged (unlike std::make_unsigned).\n+template <typename T, bool INTEGRAL = std::is_integral<T>::value>\n+struct make_unsigned_or_unchanged {\n+  using type = T;\n+};\n+\n+template <typename T> struct make_unsigned_or_unchanged<T, true> {\n+  using type = typename std::make_unsigned<T>::type;\n+};\n+\n+#if FMT_SAFE_DURATION_CAST\n+// throwing version of safe_duration_cast\n+template <typename To, typename FromRep, typename FromPeriod>\n+To fmt_safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {\n+  int ec;\n+  To to = safe_duration_cast::safe_duration_cast<To>(from, ec);\n+  if (ec) FMT_THROW(format_error(\"cannot format duration\"));\n+  return to;\n+}\n+#endif\n+\n+template <typename Rep, typename Period,\n+          FMT_ENABLE_IF(std::is_integral<Rep>::value)>\n+inline std::chrono::duration<Rep, std::milli> get_milliseconds(\n+    std::chrono::duration<Rep, Period> d) {\n+  // this may overflow and/or the result may not fit in the\n+  // target type.\n+#if FMT_SAFE_DURATION_CAST\n+  using CommonSecondsType =\n+      typename std::common_type<decltype(d), std::chrono::seconds>::type;\n+  const auto d_as_common = fmt_safe_duration_cast<CommonSecondsType>(d);\n+  const auto d_as_whole_seconds =\n+      fmt_safe_duration_cast<std::chrono::seconds>(d_as_common);\n+  // this conversion should be nonproblematic\n+  const auto diff = d_as_common - d_as_whole_seconds;\n+  const auto ms =\n+      fmt_safe_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);\n+  return ms;\n+#else\n+  auto s = std::chrono::duration_cast<std::chrono::seconds>(d);\n+  return std::chrono::duration_cast<std::chrono::milliseconds>(d - s);\n+#endif\n+}\n+\n+template <typename Rep, typename Period,\n+          FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>\n+inline std::chrono::duration<Rep, std::milli> get_milliseconds(\n+    std::chrono::duration<Rep, Period> d) {\n+  using common_type = typename std::common_type<Rep, std::intmax_t>::type;\n+  auto ms = mod(d.count() * static_cast<common_type>(Period::num) /\n+                    static_cast<common_type>(Period::den) * 1000,\n+                1000);\n+  return std::chrono::duration<Rep, std::milli>(static_cast<Rep>(ms));\n+}\n+\n+template <typename Rep, typename OutputIt>\n+OutputIt format_chrono_duration_value(OutputIt out, Rep val, int precision) {\n+  if (precision >= 0) return format_to(out, \"{:.{}f}\", val, precision);\n+  return format_to(out, std::is_floating_point<Rep>::value ? \"{:g}\" : \"{}\",\n+                   val);\n+}\n+\n+template <typename Period, typename OutputIt>\n+static OutputIt format_chrono_duration_unit(OutputIt out) {\n+  if (const char* unit = get_units<Period>()) return format_to(out, \"{}\", unit);\n+  if (Period::den == 1) return format_to(out, \"[{}]s\", Period::num);\n+  return format_to(out, \"[{}/{}]s\", Period::num, Period::den);\n+}\n \n-template <typename FormatContext, typename OutputIt>\n+template <typename FormatContext, typename OutputIt, typename Rep,\n+          typename Period>\n struct chrono_formatter {\n-  FormatContext &context;\n+  FormatContext& context;\n   OutputIt out;\n-  std::chrono::seconds s;\n-  std::chrono::milliseconds ms;\n+  int precision;\n+  // rep is unsigned to avoid overflow.\n+  using rep =\n+      conditional_t<std::is_integral<Rep>::value && sizeof(Rep) < sizeof(int),\n+                    unsigned, typename make_unsigned_or_unchanged<Rep>::type>;\n+  rep val;\n+  using seconds = std::chrono::duration<rep>;\n+  seconds s;\n+  using milliseconds = std::chrono::duration<rep, std::milli>;\n+  bool negative;\n+\n+  using char_type = typename FormatContext::char_type;\n+\n+  explicit chrono_formatter(FormatContext& ctx, OutputIt o,\n+                            std::chrono::duration<Rep, Period> d)\n+      : context(ctx), out(o), val(d.count()), negative(false) {\n+    if (d.count() < 0) {\n+      val = 0 - val;\n+      negative = true;\n+    }\n \n-  typedef typename FormatContext::char_type char_type;\n+    // this may overflow and/or the result may not fit in the\n+    // target type.\n+#if FMT_SAFE_DURATION_CAST\n+    // might need checked conversion (rep!=Rep)\n+    auto tmpval = std::chrono::duration<rep, Period>(val);\n+    s = fmt_safe_duration_cast<seconds>(tmpval);\n+#else\n+    s = std::chrono::duration_cast<seconds>(\n+        std::chrono::duration<rep, Period>(val));\n+#endif\n+  }\n \n-  explicit chrono_formatter(FormatContext &ctx, OutputIt o)\n-    : context(ctx), out(o) {}\n+  // returns true if nan or inf, writes to out.\n+  bool handle_nan_inf() {\n+    if (isfinite(val)) {\n+      return false;\n+    }\n+    if (isnan(val)) {\n+      write_nan();\n+      return true;\n+    }\n+    // must be +-inf\n+    if (val > 0) {\n+      write_pinf();\n+    } else {\n+      write_ninf();\n+    }\n+    return true;\n+  }\n \n-  int hour() const { return to_int((s.count() / 3600) % 24); }\n+  Rep hour() const { return static_cast<Rep>(mod((s.count() / 3600), 24)); }\n \n-  int hour12() const {\n-    auto hour = to_int((s.count() / 3600) % 12);\n-    return hour > 0 ? hour : 12;\n+  Rep hour12() const {\n+    Rep hour = static_cast<Rep>(mod((s.count() / 3600), 12));\n+    return hour <= 0 ? 12 : hour;\n   }\n \n-  int minute() const { return to_int((s.count() / 60) % 60); }\n-  int second() const { return to_int(s.count() % 60); }\n+  Rep minute() const { return static_cast<Rep>(mod((s.count() / 60), 60)); }\n+  Rep second() const { return static_cast<Rep>(mod(s.count(), 60)); }\n \n   std::tm time() const {\n     auto time = std::tm();\n-    time.tm_hour = hour();\n-    time.tm_min = minute();\n-    time.tm_sec = second();\n+    time.tm_hour = to_nonnegative_int(hour(), 24);\n+    time.tm_min = to_nonnegative_int(minute(), 60);\n+    time.tm_sec = to_nonnegative_int(second(), 60);\n     return time;\n   }\n \n-  void write(int value, int width) {\n-    typedef typename int_traits<int>::main_type main_type;\n-    main_type n = to_unsigned(value);\n+  void write_sign() {\n+    if (negative) {\n+      *out++ = '-';\n+      negative = false;\n+    }\n+  }\n+\n+  void write(Rep value, int width) {\n+    write_sign();\n+    if (isnan(value)) return write_nan();\n+    uint32_or_64_t<int> n = to_unsigned(\n+        to_nonnegative_int(value, (std::numeric_limits<int>::max)()));\n     int num_digits = internal::count_digits(n);\n-    if (width > num_digits)\n-      out = std::fill_n(out, width - num_digits, '0');\n+    if (width > num_digits) out = std::fill_n(out, width - num_digits, '0');\n     out = format_decimal<char_type>(out, n, num_digits);\n   }\n \n-  void format_localized(const tm &time, const char *format) {\n+  void write_nan() { std::copy_n(\"nan\", 3, out); }\n+  void write_pinf() { std::copy_n(\"inf\", 3, out); }\n+  void write_ninf() { std::copy_n(\"-inf\", 4, out); }\n+\n+  void format_localized(const tm& time, const char* format) {\n+    if (isnan(val)) return write_nan();\n     auto locale = context.locale().template get<std::locale>();\n-    auto &facet = std::use_facet<std::time_put<char_type>>(locale);\n+    auto& facet = std::use_facet<std::time_put<char_type>>(locale);\n     std::basic_ostringstream<char_type> os;\n     os.imbue(locale);\n     facet.put(os, os, ' ', &time, format, format + std::strlen(format));\n@@ -266,7 +604,7 @@ struct chrono_formatter {\n     std::copy(str.begin(), str.end(), out);\n   }\n \n-  void on_text(const char_type *begin, const char_type *end) {\n+  void on_text(const char_type* begin, const char_type* end) {\n     std::copy(begin, end, out);\n   }\n \n@@ -286,46 +624,70 @@ struct chrono_formatter {\n   void on_tz_name() {}\n \n   void on_24_hour(numeric_system ns) {\n-    if (ns == numeric_system::standard)\n-      return write(hour(), 2);\n+    if (handle_nan_inf()) return;\n+\n+    if (ns == numeric_system::standard) return write(hour(), 2);\n     auto time = tm();\n-    time.tm_hour = hour();\n+    time.tm_hour = to_nonnegative_int(hour(), 24);\n     format_localized(time, \"%OH\");\n   }\n \n   void on_12_hour(numeric_system ns) {\n-    if (ns == numeric_system::standard)\n-      return write(hour12(), 2);\n+    if (handle_nan_inf()) return;\n+\n+    if (ns == numeric_system::standard) return write(hour12(), 2);\n     auto time = tm();\n-    time.tm_hour = hour();\n+    time.tm_hour = to_nonnegative_int(hour12(), 12);\n     format_localized(time, \"%OI\");\n   }\n \n   void on_minute(numeric_system ns) {\n-    if (ns == numeric_system::standard)\n-      return write(minute(), 2);\n+    if (handle_nan_inf()) return;\n+\n+    if (ns == numeric_system::standard) return write(minute(), 2);\n     auto time = tm();\n-    time.tm_min = minute();\n+    time.tm_min = to_nonnegative_int(minute(), 60);\n     format_localized(time, \"%OM\");\n   }\n \n   void on_second(numeric_system ns) {\n+    if (handle_nan_inf()) return;\n+\n     if (ns == numeric_system::standard) {\n       write(second(), 2);\n+#if FMT_SAFE_DURATION_CAST\n+      // convert rep->Rep\n+      using duration_rep = std::chrono::duration<rep, Period>;\n+      using duration_Rep = std::chrono::duration<Rep, Period>;\n+      auto tmpval = fmt_safe_duration_cast<duration_Rep>(duration_rep{val});\n+#else\n+      auto tmpval = std::chrono::duration<Rep, Period>(val);\n+#endif\n+      auto ms = get_milliseconds(tmpval);\n       if (ms != std::chrono::milliseconds(0)) {\n         *out++ = '.';\n-        write(to_int(ms.count()), 3);\n+        write(ms.count(), 3);\n       }\n       return;\n     }\n     auto time = tm();\n-    time.tm_sec = second();\n+    time.tm_sec = to_nonnegative_int(second(), 60);\n     format_localized(time, \"%OS\");\n   }\n \n-  void on_12_hour_time() { format_localized(time(), \"%r\"); }\n+  void on_12_hour_time() {\n+    if (handle_nan_inf()) return;\n+\n+    format_localized(time(), \"%r\");\n+  }\n \n   void on_24_hour_time() {\n+    if (handle_nan_inf()) {\n+      *out++ = ':';\n+      handle_nan_inf();\n+      return;\n+    }\n+\n     write(hour(), 2);\n     *out++ = ':';\n     write(minute(), 2);\n@@ -334,115 +696,130 @@ struct chrono_formatter {\n   void on_iso_time() {\n     on_24_hour_time();\n     *out++ = ':';\n+    if (handle_nan_inf()) return;\n     write(second(), 2);\n   }\n \n-  void on_am_pm() { format_localized(time(), \"%p\"); }\n+  void on_am_pm() {\n+    if (handle_nan_inf()) return;\n+    format_localized(time(), \"%p\");\n+  }\n+\n+  void on_duration_value() {\n+    if (handle_nan_inf()) return;\n+    write_sign();\n+    out = format_chrono_duration_value(out, val, precision);\n+  }\n+\n+  void on_duration_unit() { out = format_chrono_duration_unit<Period>(out); }\n };\n }  // namespace internal\n \n-template <typename Period> FMT_CONSTEXPR const char *get_units() {\n-  return FMT_NULL;\n-}\n-template <> FMT_CONSTEXPR const char *get_units<std::atto>() { return \"as\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::femto>() { return \"fs\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::pico>() { return \"ps\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::nano>() { return \"ns\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::micro>() { return \"\u00b5s\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::milli>() { return \"ms\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::centi>() { return \"cs\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::deci>() { return \"ds\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::ratio<1>>() { return \"s\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::deca>() { return \"das\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::hecto>() { return \"hs\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::kilo>() { return \"ks\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::mega>() { return \"Ms\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::giga>() { return \"Gs\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::tera>() { return \"Ts\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::peta>() { return \"Ps\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::exa>() { return \"Es\"; }\n-template <> FMT_CONSTEXPR const char *get_units<std::ratio<60>>() {\n-  return \"m\";\n-}\n-template <> FMT_CONSTEXPR const char *get_units<std::ratio<3600>>() {\n-  return \"h\";\n-}\n-\n template <typename Rep, typename Period, typename Char>\n struct formatter<std::chrono::duration<Rep, Period>, Char> {\n  private:\n-  align_spec spec;\n-  internal::arg_ref<Char> width_ref;\n+  basic_format_specs<Char> specs;\n+  int precision;\n+  using arg_ref_type = internal::arg_ref<Char>;\n+  arg_ref_type width_ref;\n+  arg_ref_type precision_ref;\n   mutable basic_string_view<Char> format_str;\n-  typedef std::chrono::duration<Rep, Period> duration;\n+  using duration = std::chrono::duration<Rep, Period>;\n \n   struct spec_handler {\n-    formatter &f;\n-    basic_parse_context<Char> &context;\n-\n-    typedef internal::arg_ref<Char> arg_ref_type;\n+    formatter& f;\n+    basic_parse_context<Char>& context;\n+    basic_string_view<Char> format_str;\n \n-    template <typename Id>\n-    FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {\n+    template <typename Id> FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {\n       context.check_arg_id(arg_id);\n       return arg_ref_type(arg_id);\n     }\n \n+    FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<Char> arg_id) {\n+      context.check_arg_id(arg_id);\n+      const auto str_val = internal::string_view_metadata(format_str, arg_id);\n+      return arg_ref_type(str_val);\n+    }\n+\n     FMT_CONSTEXPR arg_ref_type make_arg_ref(internal::auto_id) {\n       return arg_ref_type(context.next_arg_id());\n     }\n \n-    void on_error(const char *msg) { throw format_error(msg); }\n-    void on_fill(Char fill) { f.spec.fill_ = fill; }\n-    void on_align(alignment align) { f.spec.align_ = align; }\n-    void on_width(unsigned width) { f.spec.width_ = width; }\n+    void on_error(const char* msg) { FMT_THROW(format_error(msg)); }\n+    void on_fill(Char fill) { f.specs.fill[0] = fill; }\n+    void on_align(align_t align) { f.specs.align = align; }\n+    void on_width(unsigned width) { f.specs.width = width; }\n+    void on_precision(unsigned precision) { f.precision = precision; }\n+    void end_precision() {}\n \n-    template <typename Id>\n-    void on_dynamic_width(Id arg_id) {\n+    template <typename Id> void on_dynamic_width(Id arg_id) {\n       f.width_ref = make_arg_ref(arg_id);\n     }\n+\n+    template <typename Id> void on_dynamic_precision(Id arg_id) {\n+      f.precision_ref = make_arg_ref(arg_id);\n+    }\n   };\n \n- public:\n-  formatter() : spec() {}\n+  using iterator = typename basic_parse_context<Char>::iterator;\n+  struct parse_range {\n+    iterator begin;\n+    iterator end;\n+  };\n \n-  FMT_CONSTEXPR auto parse(basic_parse_context<Char> &ctx)\n-      -> decltype(ctx.begin()) {\n+  FMT_CONSTEXPR parse_range do_parse(basic_parse_context<Char>& ctx) {\n     auto begin = ctx.begin(), end = ctx.end();\n-    if (begin == end) return begin;\n-    spec_handler handler{*this, ctx};\n+    if (begin == end || *begin == '}') return {begin, begin};\n+    spec_handler handler{*this, ctx, format_str};\n     begin = internal::parse_align(begin, end, handler);\n-    if (begin == end) return begin;\n+    if (begin == end) return {begin, begin};\n     begin = internal::parse_width(begin, end, handler);\n+    if (begin == end) return {begin, begin};\n+    if (*begin == '.') {\n+      if (std::is_floating_point<Rep>::value)\n+        begin = internal::parse_precision(begin, end, handler);\n+      else\n+        handler.on_error(\"precision not allowed for this argument type\");\n+    }\n     end = parse_chrono_format(begin, end, internal::chrono_format_checker());\n-    format_str = basic_string_view<Char>(&*begin, internal::to_unsigned(end - begin));\n-    return end;\n+    return {begin, end};\n+  }\n+\n+ public:\n+  formatter() : precision(-1) {}\n+\n+  FMT_CONSTEXPR auto parse(basic_parse_context<Char>& ctx)\n+      -> decltype(ctx.begin()) {\n+    auto range = do_parse(ctx);\n+    format_str = basic_string_view<Char>(\n+        &*range.begin, internal::to_unsigned(range.end - range.begin));\n+    return range.end;\n   }\n \n   template <typename FormatContext>\n-  auto format(const duration &d, FormatContext &ctx)\n-      -> decltype(ctx.out()) {\n+  auto format(const duration& d, FormatContext& ctx) -> decltype(ctx.out()) {\n     auto begin = format_str.begin(), end = format_str.end();\n-    memory_buffer buf;\n-    typedef output_range<decltype(ctx.out()), Char> range;\n-    basic_writer<range> w(range(ctx.out()));\n+    // As a possible future optimization, we could avoid extra copying if width\n+    // is not specified.\n+    basic_memory_buffer<Char> buf;\n+    auto out = std::back_inserter(buf);\n+    using range = internal::output_range<decltype(ctx.out()), Char>;\n+    internal::basic_writer<range> w(range(ctx.out()));\n+    internal::handle_dynamic_spec<internal::width_checker>(\n+        specs.width, width_ref, ctx, format_str.begin());\n+    internal::handle_dynamic_spec<internal::precision_checker>(\n+        precision, precision_ref, ctx, format_str.begin());\n     if (begin == end || *begin == '}') {\n-      if (const char *unit = get_units<Period>())\n-        format_to(buf, \"{}{}\", d.count(), unit);\n-      else if (Period::den == 1)\n-        format_to(buf, \"{}[{}]s\", d.count(), Period::num);\n-      else\n-        format_to(buf, \"{}[{}/{}]s\", d.count(), Period::num, Period::den);\n-      internal::handle_dynamic_spec<internal::width_checker>(\n-        spec.width_, width_ref, ctx);\n+      out = internal::format_chrono_duration_value(out, d.count(), precision);\n+      internal::format_chrono_duration_unit<Period>(out);\n     } else {\n-      auto out = std::back_inserter(buf);\n-      internal::chrono_formatter<FormatContext, decltype(out)> f(ctx, out);\n-      f.s = std::chrono::duration_cast<std::chrono::seconds>(d);\n-      f.ms = std::chrono::duration_cast<std::chrono::milliseconds>(d - f.s);\n+      internal::chrono_formatter<FormatContext, decltype(out), Rep, Period> f(\n+          ctx, out, d);\n+      f.precision = precision;\n       parse_chrono_format(begin, end, f);\n     }\n-    w.write(buf.data(), buf.size(), spec);\n+    w.write(buf.data(), buf.size(), specs);\n     return w.out();\n   }\n };\ndiff --git a/include/spdlog/fmt/bundled/color.h b/include/spdlog/fmt/bundled/color.h\n--- a/include/spdlog/fmt/bundled/color.h\n+++ b/include/spdlog/fmt/bundled/color.h\n@@ -12,184 +12,149 @@\n \n FMT_BEGIN_NAMESPACE\n \n-#ifdef FMT_DEPRECATED_COLORS\n-\n-// color and (v)print_colored are deprecated.\n-enum color { black, red, green, yellow, blue, magenta, cyan, white };\n-FMT_API void vprint_colored(color c, string_view format, format_args args);\n-FMT_API void vprint_colored(color c, wstring_view format, wformat_args args);\n-template <typename... Args>\n-inline void print_colored(color c, string_view format_str,\n-                          const Args & ... args) {\n-  vprint_colored(c, format_str, make_format_args(args...));\n-}\n-template <typename... Args>\n-inline void print_colored(color c, wstring_view format_str,\n-                          const Args & ... args) {\n-  vprint_colored(c, format_str, make_format_args<wformat_context>(args...));\n-}\n-\n-inline void vprint_colored(color c, string_view format, format_args args) {\n-  char escape[] = \"\\x1b[30m\";\n-  escape[3] = static_cast<char>('0' + c);\n-  std::fputs(escape, stdout);\n-  vprint(format, args);\n-  std::fputs(internal::data::RESET_COLOR, stdout);\n-}\n-\n-inline void vprint_colored(color c, wstring_view format, wformat_args args) {\n-  wchar_t escape[] = L\"\\x1b[30m\";\n-  escape[3] = static_cast<wchar_t>('0' + c);\n-  std::fputws(escape, stdout);\n-  vprint(format, args);\n-  std::fputws(internal::data::WRESET_COLOR, stdout);\n-}\n-\n-#else\n-\n enum class color : uint32_t {\n-  alice_blue              = 0xF0F8FF, // rgb(240,248,255)\n-  antique_white           = 0xFAEBD7, // rgb(250,235,215)\n-  aqua                    = 0x00FFFF, // rgb(0,255,255)\n-  aquamarine              = 0x7FFFD4, // rgb(127,255,212)\n-  azure                   = 0xF0FFFF, // rgb(240,255,255)\n-  beige                   = 0xF5F5DC, // rgb(245,245,220)\n-  bisque                  = 0xFFE4C4, // rgb(255,228,196)\n-  black                   = 0x000000, // rgb(0,0,0)\n-  blanched_almond         = 0xFFEBCD, // rgb(255,235,205)\n-  blue                    = 0x0000FF, // rgb(0,0,255)\n-  blue_violet             = 0x8A2BE2, // rgb(138,43,226)\n-  brown                   = 0xA52A2A, // rgb(165,42,42)\n-  burly_wood              = 0xDEB887, // rgb(222,184,135)\n-  cadet_blue              = 0x5F9EA0, // rgb(95,158,160)\n-  chartreuse              = 0x7FFF00, // rgb(127,255,0)\n-  chocolate               = 0xD2691E, // rgb(210,105,30)\n-  coral                   = 0xFF7F50, // rgb(255,127,80)\n-  cornflower_blue         = 0x6495ED, // rgb(100,149,237)\n-  cornsilk                = 0xFFF8DC, // rgb(255,248,220)\n-  crimson                 = 0xDC143C, // rgb(220,20,60)\n-  cyan                    = 0x00FFFF, // rgb(0,255,255)\n-  dark_blue               = 0x00008B, // rgb(0,0,139)\n-  dark_cyan               = 0x008B8B, // rgb(0,139,139)\n-  dark_golden_rod         = 0xB8860B, // rgb(184,134,11)\n-  dark_gray               = 0xA9A9A9, // rgb(169,169,169)\n-  dark_green              = 0x006400, // rgb(0,100,0)\n-  dark_khaki              = 0xBDB76B, // rgb(189,183,107)\n-  dark_magenta            = 0x8B008B, // rgb(139,0,139)\n-  dark_olive_green        = 0x556B2F, // rgb(85,107,47)\n-  dark_orange             = 0xFF8C00, // rgb(255,140,0)\n-  dark_orchid             = 0x9932CC, // rgb(153,50,204)\n-  dark_red                = 0x8B0000, // rgb(139,0,0)\n-  dark_salmon             = 0xE9967A, // rgb(233,150,122)\n-  dark_sea_green          = 0x8FBC8F, // rgb(143,188,143)\n-  dark_slate_blue         = 0x483D8B, // rgb(72,61,139)\n-  dark_slate_gray         = 0x2F4F4F, // rgb(47,79,79)\n-  dark_turquoise          = 0x00CED1, // rgb(0,206,209)\n-  dark_violet             = 0x9400D3, // rgb(148,0,211)\n-  deep_pink               = 0xFF1493, // rgb(255,20,147)\n-  deep_sky_blue           = 0x00BFFF, // rgb(0,191,255)\n-  dim_gray                = 0x696969, // rgb(105,105,105)\n-  dodger_blue             = 0x1E90FF, // rgb(30,144,255)\n-  fire_brick              = 0xB22222, // rgb(178,34,34)\n-  floral_white            = 0xFFFAF0, // rgb(255,250,240)\n-  forest_green            = 0x228B22, // rgb(34,139,34)\n-  fuchsia                 = 0xFF00FF, // rgb(255,0,255)\n-  gainsboro               = 0xDCDCDC, // rgb(220,220,220)\n-  ghost_white             = 0xF8F8FF, // rgb(248,248,255)\n-  gold                    = 0xFFD700, // rgb(255,215,0)\n-  golden_rod              = 0xDAA520, // rgb(218,165,32)\n-  gray                    = 0x808080, // rgb(128,128,128)\n-  green                   = 0x008000, // rgb(0,128,0)\n-  green_yellow            = 0xADFF2F, // rgb(173,255,47)\n-  honey_dew               = 0xF0FFF0, // rgb(240,255,240)\n-  hot_pink                = 0xFF69B4, // rgb(255,105,180)\n-  indian_red              = 0xCD5C5C, // rgb(205,92,92)\n-  indigo                  = 0x4B0082, // rgb(75,0,130)\n-  ivory                   = 0xFFFFF0, // rgb(255,255,240)\n-  khaki                   = 0xF0E68C, // rgb(240,230,140)\n-  lavender                = 0xE6E6FA, // rgb(230,230,250)\n-  lavender_blush          = 0xFFF0F5, // rgb(255,240,245)\n-  lawn_green              = 0x7CFC00, // rgb(124,252,0)\n-  lemon_chiffon           = 0xFFFACD, // rgb(255,250,205)\n-  light_blue              = 0xADD8E6, // rgb(173,216,230)\n-  light_coral             = 0xF08080, // rgb(240,128,128)\n-  light_cyan              = 0xE0FFFF, // rgb(224,255,255)\n-  light_golden_rod_yellow = 0xFAFAD2, // rgb(250,250,210)\n-  light_gray              = 0xD3D3D3, // rgb(211,211,211)\n-  light_green             = 0x90EE90, // rgb(144,238,144)\n-  light_pink              = 0xFFB6C1, // rgb(255,182,193)\n-  light_salmon            = 0xFFA07A, // rgb(255,160,122)\n-  light_sea_green         = 0x20B2AA, // rgb(32,178,170)\n-  light_sky_blue          = 0x87CEFA, // rgb(135,206,250)\n-  light_slate_gray        = 0x778899, // rgb(119,136,153)\n-  light_steel_blue        = 0xB0C4DE, // rgb(176,196,222)\n-  light_yellow            = 0xFFFFE0, // rgb(255,255,224)\n-  lime                    = 0x00FF00, // rgb(0,255,0)\n-  lime_green              = 0x32CD32, // rgb(50,205,50)\n-  linen                   = 0xFAF0E6, // rgb(250,240,230)\n-  magenta                 = 0xFF00FF, // rgb(255,0,255)\n-  maroon                  = 0x800000, // rgb(128,0,0)\n-  medium_aquamarine       = 0x66CDAA, // rgb(102,205,170)\n-  medium_blue             = 0x0000CD, // rgb(0,0,205)\n-  medium_orchid           = 0xBA55D3, // rgb(186,85,211)\n-  medium_purple           = 0x9370DB, // rgb(147,112,219)\n-  medium_sea_green        = 0x3CB371, // rgb(60,179,113)\n-  medium_slate_blue       = 0x7B68EE, // rgb(123,104,238)\n-  medium_spring_green     = 0x00FA9A, // rgb(0,250,154)\n-  medium_turquoise        = 0x48D1CC, // rgb(72,209,204)\n-  medium_violet_red       = 0xC71585, // rgb(199,21,133)\n-  midnight_blue           = 0x191970, // rgb(25,25,112)\n-  mint_cream              = 0xF5FFFA, // rgb(245,255,250)\n-  misty_rose              = 0xFFE4E1, // rgb(255,228,225)\n-  moccasin                = 0xFFE4B5, // rgb(255,228,181)\n-  navajo_white            = 0xFFDEAD, // rgb(255,222,173)\n-  navy                    = 0x000080, // rgb(0,0,128)\n-  old_lace                = 0xFDF5E6, // rgb(253,245,230)\n-  olive                   = 0x808000, // rgb(128,128,0)\n-  olive_drab              = 0x6B8E23, // rgb(107,142,35)\n-  orange                  = 0xFFA500, // rgb(255,165,0)\n-  orange_red              = 0xFF4500, // rgb(255,69,0)\n-  orchid                  = 0xDA70D6, // rgb(218,112,214)\n-  pale_golden_rod         = 0xEEE8AA, // rgb(238,232,170)\n-  pale_green              = 0x98FB98, // rgb(152,251,152)\n-  pale_turquoise          = 0xAFEEEE, // rgb(175,238,238)\n-  pale_violet_red         = 0xDB7093, // rgb(219,112,147)\n-  papaya_whip             = 0xFFEFD5, // rgb(255,239,213)\n-  peach_puff              = 0xFFDAB9, // rgb(255,218,185)\n-  peru                    = 0xCD853F, // rgb(205,133,63)\n-  pink                    = 0xFFC0CB, // rgb(255,192,203)\n-  plum                    = 0xDDA0DD, // rgb(221,160,221)\n-  powder_blue             = 0xB0E0E6, // rgb(176,224,230)\n-  purple                  = 0x800080, // rgb(128,0,128)\n-  rebecca_purple          = 0x663399, // rgb(102,51,153)\n-  red                     = 0xFF0000, // rgb(255,0,0)\n-  rosy_brown              = 0xBC8F8F, // rgb(188,143,143)\n-  royal_blue              = 0x4169E1, // rgb(65,105,225)\n-  saddle_brown            = 0x8B4513, // rgb(139,69,19)\n-  salmon                  = 0xFA8072, // rgb(250,128,114)\n-  sandy_brown             = 0xF4A460, // rgb(244,164,96)\n-  sea_green               = 0x2E8B57, // rgb(46,139,87)\n-  sea_shell               = 0xFFF5EE, // rgb(255,245,238)\n-  sienna                  = 0xA0522D, // rgb(160,82,45)\n-  silver                  = 0xC0C0C0, // rgb(192,192,192)\n-  sky_blue                = 0x87CEEB, // rgb(135,206,235)\n-  slate_blue              = 0x6A5ACD, // rgb(106,90,205)\n-  slate_gray              = 0x708090, // rgb(112,128,144)\n-  snow                    = 0xFFFAFA, // rgb(255,250,250)\n-  spring_green            = 0x00FF7F, // rgb(0,255,127)\n-  steel_blue              = 0x4682B4, // rgb(70,130,180)\n-  tan                     = 0xD2B48C, // rgb(210,180,140)\n-  teal                    = 0x008080, // rgb(0,128,128)\n-  thistle                 = 0xD8BFD8, // rgb(216,191,216)\n-  tomato                  = 0xFF6347, // rgb(255,99,71)\n-  turquoise               = 0x40E0D0, // rgb(64,224,208)\n-  violet                  = 0xEE82EE, // rgb(238,130,238)\n-  wheat                   = 0xF5DEB3, // rgb(245,222,179)\n-  white                   = 0xFFFFFF, // rgb(255,255,255)\n-  white_smoke             = 0xF5F5F5, // rgb(245,245,245)\n-  yellow                  = 0xFFFF00, // rgb(255,255,0)\n-  yellow_green            = 0x9ACD32  // rgb(154,205,50)\n-};  // enum class color\n+  alice_blue = 0xF0F8FF,               // rgb(240,248,255)\n+  antique_white = 0xFAEBD7,            // rgb(250,235,215)\n+  aqua = 0x00FFFF,                     // rgb(0,255,255)\n+  aquamarine = 0x7FFFD4,               // rgb(127,255,212)\n+  azure = 0xF0FFFF,                    // rgb(240,255,255)\n+  beige = 0xF5F5DC,                    // rgb(245,245,220)\n+  bisque = 0xFFE4C4,                   // rgb(255,228,196)\n+  black = 0x000000,                    // rgb(0,0,0)\n+  blanched_almond = 0xFFEBCD,          // rgb(255,235,205)\n+  blue = 0x0000FF,                     // rgb(0,0,255)\n+  blue_violet = 0x8A2BE2,              // rgb(138,43,226)\n+  brown = 0xA52A2A,                    // rgb(165,42,42)\n+  burly_wood = 0xDEB887,               // rgb(222,184,135)\n+  cadet_blue = 0x5F9EA0,               // rgb(95,158,160)\n+  chartreuse = 0x7FFF00,               // rgb(127,255,0)\n+  chocolate = 0xD2691E,                // rgb(210,105,30)\n+  coral = 0xFF7F50,                    // rgb(255,127,80)\n+  cornflower_blue = 0x6495ED,          // rgb(100,149,237)\n+  cornsilk = 0xFFF8DC,                 // rgb(255,248,220)\n+  crimson = 0xDC143C,                  // rgb(220,20,60)\n+  cyan = 0x00FFFF,                     // rgb(0,255,255)\n+  dark_blue = 0x00008B,                // rgb(0,0,139)\n+  dark_cyan = 0x008B8B,                // rgb(0,139,139)\n+  dark_golden_rod = 0xB8860B,          // rgb(184,134,11)\n+  dark_gray = 0xA9A9A9,                // rgb(169,169,169)\n+  dark_green = 0x006400,               // rgb(0,100,0)\n+  dark_khaki = 0xBDB76B,               // rgb(189,183,107)\n+  dark_magenta = 0x8B008B,             // rgb(139,0,139)\n+  dark_olive_green = 0x556B2F,         // rgb(85,107,47)\n+  dark_orange = 0xFF8C00,              // rgb(255,140,0)\n+  dark_orchid = 0x9932CC,              // rgb(153,50,204)\n+  dark_red = 0x8B0000,                 // rgb(139,0,0)\n+  dark_salmon = 0xE9967A,              // rgb(233,150,122)\n+  dark_sea_green = 0x8FBC8F,           // rgb(143,188,143)\n+  dark_slate_blue = 0x483D8B,          // rgb(72,61,139)\n+  dark_slate_gray = 0x2F4F4F,          // rgb(47,79,79)\n+  dark_turquoise = 0x00CED1,           // rgb(0,206,209)\n+  dark_violet = 0x9400D3,              // rgb(148,0,211)\n+  deep_pink = 0xFF1493,                // rgb(255,20,147)\n+  deep_sky_blue = 0x00BFFF,            // rgb(0,191,255)\n+  dim_gray = 0x696969,                 // rgb(105,105,105)\n+  dodger_blue = 0x1E90FF,              // rgb(30,144,255)\n+  fire_brick = 0xB22222,               // rgb(178,34,34)\n+  floral_white = 0xFFFAF0,             // rgb(255,250,240)\n+  forest_green = 0x228B22,             // rgb(34,139,34)\n+  fuchsia = 0xFF00FF,                  // rgb(255,0,255)\n+  gainsboro = 0xDCDCDC,                // rgb(220,220,220)\n+  ghost_white = 0xF8F8FF,              // rgb(248,248,255)\n+  gold = 0xFFD700,                     // rgb(255,215,0)\n+  golden_rod = 0xDAA520,               // rgb(218,165,32)\n+  gray = 0x808080,                     // rgb(128,128,128)\n+  green = 0x008000,                    // rgb(0,128,0)\n+  green_yellow = 0xADFF2F,             // rgb(173,255,47)\n+  honey_dew = 0xF0FFF0,                // rgb(240,255,240)\n+  hot_pink = 0xFF69B4,                 // rgb(255,105,180)\n+  indian_red = 0xCD5C5C,               // rgb(205,92,92)\n+  indigo = 0x4B0082,                   // rgb(75,0,130)\n+  ivory = 0xFFFFF0,                    // rgb(255,255,240)\n+  khaki = 0xF0E68C,                    // rgb(240,230,140)\n+  lavender = 0xE6E6FA,                 // rgb(230,230,250)\n+  lavender_blush = 0xFFF0F5,           // rgb(255,240,245)\n+  lawn_green = 0x7CFC00,               // rgb(124,252,0)\n+  lemon_chiffon = 0xFFFACD,            // rgb(255,250,205)\n+  light_blue = 0xADD8E6,               // rgb(173,216,230)\n+  light_coral = 0xF08080,              // rgb(240,128,128)\n+  light_cyan = 0xE0FFFF,               // rgb(224,255,255)\n+  light_golden_rod_yellow = 0xFAFAD2,  // rgb(250,250,210)\n+  light_gray = 0xD3D3D3,               // rgb(211,211,211)\n+  light_green = 0x90EE90,              // rgb(144,238,144)\n+  light_pink = 0xFFB6C1,               // rgb(255,182,193)\n+  light_salmon = 0xFFA07A,             // rgb(255,160,122)\n+  light_sea_green = 0x20B2AA,          // rgb(32,178,170)\n+  light_sky_blue = 0x87CEFA,           // rgb(135,206,250)\n+  light_slate_gray = 0x778899,         // rgb(119,136,153)\n+  light_steel_blue = 0xB0C4DE,         // rgb(176,196,222)\n+  light_yellow = 0xFFFFE0,             // rgb(255,255,224)\n+  lime = 0x00FF00,                     // rgb(0,255,0)\n+  lime_green = 0x32CD32,               // rgb(50,205,50)\n+  linen = 0xFAF0E6,                    // rgb(250,240,230)\n+  magenta = 0xFF00FF,                  // rgb(255,0,255)\n+  maroon = 0x800000,                   // rgb(128,0,0)\n+  medium_aquamarine = 0x66CDAA,        // rgb(102,205,170)\n+  medium_blue = 0x0000CD,              // rgb(0,0,205)\n+  medium_orchid = 0xBA55D3,            // rgb(186,85,211)\n+  medium_purple = 0x9370DB,            // rgb(147,112,219)\n+  medium_sea_green = 0x3CB371,         // rgb(60,179,113)\n+  medium_slate_blue = 0x7B68EE,        // rgb(123,104,238)\n+  medium_spring_green = 0x00FA9A,      // rgb(0,250,154)\n+  medium_turquoise = 0x48D1CC,         // rgb(72,209,204)\n+  medium_violet_red = 0xC71585,        // rgb(199,21,133)\n+  midnight_blue = 0x191970,            // rgb(25,25,112)\n+  mint_cream = 0xF5FFFA,               // rgb(245,255,250)\n+  misty_rose = 0xFFE4E1,               // rgb(255,228,225)\n+  moccasin = 0xFFE4B5,                 // rgb(255,228,181)\n+  navajo_white = 0xFFDEAD,             // rgb(255,222,173)\n+  navy = 0x000080,                     // rgb(0,0,128)\n+  old_lace = 0xFDF5E6,                 // rgb(253,245,230)\n+  olive = 0x808000,                    // rgb(128,128,0)\n+  olive_drab = 0x6B8E23,               // rgb(107,142,35)\n+  orange = 0xFFA500,                   // rgb(255,165,0)\n+  orange_red = 0xFF4500,               // rgb(255,69,0)\n+  orchid = 0xDA70D6,                   // rgb(218,112,214)\n+  pale_golden_rod = 0xEEE8AA,          // rgb(238,232,170)\n+  pale_green = 0x98FB98,               // rgb(152,251,152)\n+  pale_turquoise = 0xAFEEEE,           // rgb(175,238,238)\n+  pale_violet_red = 0xDB7093,          // rgb(219,112,147)\n+  papaya_whip = 0xFFEFD5,              // rgb(255,239,213)\n+  peach_puff = 0xFFDAB9,               // rgb(255,218,185)\n+  peru = 0xCD853F,                     // rgb(205,133,63)\n+  pink = 0xFFC0CB,                     // rgb(255,192,203)\n+  plum = 0xDDA0DD,                     // rgb(221,160,221)\n+  powder_blue = 0xB0E0E6,              // rgb(176,224,230)\n+  purple = 0x800080,                   // rgb(128,0,128)\n+  rebecca_purple = 0x663399,           // rgb(102,51,153)\n+  red = 0xFF0000,                      // rgb(255,0,0)\n+  rosy_brown = 0xBC8F8F,               // rgb(188,143,143)\n+  royal_blue = 0x4169E1,               // rgb(65,105,225)\n+  saddle_brown = 0x8B4513,             // rgb(139,69,19)\n+  salmon = 0xFA8072,                   // rgb(250,128,114)\n+  sandy_brown = 0xF4A460,              // rgb(244,164,96)\n+  sea_green = 0x2E8B57,                // rgb(46,139,87)\n+  sea_shell = 0xFFF5EE,                // rgb(255,245,238)\n+  sienna = 0xA0522D,                   // rgb(160,82,45)\n+  silver = 0xC0C0C0,                   // rgb(192,192,192)\n+  sky_blue = 0x87CEEB,                 // rgb(135,206,235)\n+  slate_blue = 0x6A5ACD,               // rgb(106,90,205)\n+  slate_gray = 0x708090,               // rgb(112,128,144)\n+  snow = 0xFFFAFA,                     // rgb(255,250,250)\n+  spring_green = 0x00FF7F,             // rgb(0,255,127)\n+  steel_blue = 0x4682B4,               // rgb(70,130,180)\n+  tan = 0xD2B48C,                      // rgb(210,180,140)\n+  teal = 0x008080,                     // rgb(0,128,128)\n+  thistle = 0xD8BFD8,                  // rgb(216,191,216)\n+  tomato = 0xFF6347,                   // rgb(255,99,71)\n+  turquoise = 0x40E0D0,                // rgb(64,224,208)\n+  violet = 0xEE82EE,                   // rgb(238,130,238)\n+  wheat = 0xF5DEB3,                    // rgb(245,222,179)\n+  white = 0xFFFFFF,                    // rgb(255,255,255)\n+  white_smoke = 0xF5F5F5,              // rgb(245,245,245)\n+  yellow = 0xFFFF00,                   // rgb(255,255,0)\n+  yellow_green = 0x9ACD32              // rgb(154,205,50)\n+};                                     // enum class color\n \n enum class terminal_color : uint8_t {\n   black = 30,\n@@ -208,27 +173,26 @@ enum class terminal_color : uint8_t {\n   bright_magenta,\n   bright_cyan,\n   bright_white\n-};  // enum class terminal_color\n+};\n \n enum class emphasis : uint8_t {\n   bold = 1,\n   italic = 1 << 1,\n   underline = 1 << 2,\n   strikethrough = 1 << 3\n-};  // enum class emphasis\n+};\n \n // rgb is a struct for red, green and blue colors.\n-// We use rgb as name because some editors will show it as color direct in the\n-// editor.\n+// Using the name \"rgb\" makes some editors show the color in a tooltip.\n struct rgb {\n-  FMT_CONSTEXPR_DECL rgb() : r(0), g(0), b(0) {}\n-  FMT_CONSTEXPR_DECL rgb(uint8_t r_, uint8_t g_, uint8_t b_)\n-    : r(r_), g(g_), b(b_) {}\n-  FMT_CONSTEXPR_DECL rgb(uint32_t hex)\n-    : r((hex >> 16) & 0xFF), g((hex >> 8) & 0xFF), b((hex) & 0xFF) {}\n-  FMT_CONSTEXPR_DECL rgb(color hex)\n-    : r((uint32_t(hex) >> 16) & 0xFF), g((uint32_t(hex) >> 8) & 0xFF),\n-      b(uint32_t(hex) & 0xFF) {}\n+  FMT_CONSTEXPR rgb() : r(0), g(0), b(0) {}\n+  FMT_CONSTEXPR rgb(uint8_t r_, uint8_t g_, uint8_t b_) : r(r_), g(g_), b(b_) {}\n+  FMT_CONSTEXPR rgb(uint32_t hex)\n+      : r((hex >> 16) & 0xFF), g((hex >> 8) & 0xFF), b(hex & 0xFF) {}\n+  FMT_CONSTEXPR rgb(color hex)\n+      : r((uint32_t(hex) >> 16) & 0xFF),\n+        g((uint32_t(hex) >> 8) & 0xFF),\n+        b(uint32_t(hex) & 0xFF) {}\n   uint8_t r;\n   uint8_t g;\n   uint8_t b;\n@@ -238,19 +202,17 @@ namespace internal {\n \n // color is a struct of either a rgb color or a terminal color.\n struct color_type {\n-  FMT_CONSTEXPR color_type() FMT_NOEXCEPT\n-    : is_rgb(), value{} {}\n-  FMT_CONSTEXPR color_type(color rgb_color) FMT_NOEXCEPT\n-    : is_rgb(true), value{} {\n+  FMT_CONSTEXPR color_type() FMT_NOEXCEPT : is_rgb(), value{} {}\n+  FMT_CONSTEXPR color_type(color rgb_color) FMT_NOEXCEPT : is_rgb(true),\n+                                                           value{} {\n     value.rgb_color = static_cast<uint32_t>(rgb_color);\n   }\n-  FMT_CONSTEXPR color_type(rgb rgb_color) FMT_NOEXCEPT\n-    : is_rgb(true), value{} {\n-    value.rgb_color = (static_cast<uint32_t>(rgb_color.r) << 16)\n-       | (static_cast<uint32_t>(rgb_color.g) << 8) | rgb_color.b;\n+  FMT_CONSTEXPR color_type(rgb rgb_color) FMT_NOEXCEPT : is_rgb(true), value{} {\n+    value.rgb_color = (static_cast<uint32_t>(rgb_color.r) << 16) |\n+                      (static_cast<uint32_t>(rgb_color.g) << 8) | rgb_color.b;\n   }\n-  FMT_CONSTEXPR color_type(terminal_color term_color) FMT_NOEXCEPT\n-    : is_rgb(), value{} {\n+  FMT_CONSTEXPR color_type(terminal_color term_color) FMT_NOEXCEPT : is_rgb(),\n+                                                                     value{} {\n     value.term_color = static_cast<uint8_t>(term_color);\n   }\n   bool is_rgb;\n@@ -259,21 +221,23 @@ struct color_type {\n     uint32_t rgb_color;\n   } value;\n };\n-} // namespace internal\n+}  // namespace internal\n \n // Experimental text formatting support.\n class text_style {\n  public:\n   FMT_CONSTEXPR text_style(emphasis em = emphasis()) FMT_NOEXCEPT\n-      : set_foreground_color(), set_background_color(), ems(em) {}\n+      : set_foreground_color(),\n+        set_background_color(),\n+        ems(em) {}\n \n-  FMT_CONSTEXPR text_style &operator|=(const text_style &rhs) {\n+  FMT_CONSTEXPR text_style& operator|=(const text_style& rhs) {\n     if (!set_foreground_color) {\n       set_foreground_color = rhs.set_foreground_color;\n       foreground_color = rhs.foreground_color;\n     } else if (rhs.set_foreground_color) {\n       if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)\n-        throw format_error(\"can't OR a terminal color\");\n+        FMT_THROW(format_error(\"can't OR a terminal color\"));\n       foreground_color.value.rgb_color |= rhs.foreground_color.value.rgb_color;\n     }\n \n@@ -282,7 +246,7 @@ class text_style {\n       background_color = rhs.background_color;\n     } else if (rhs.set_background_color) {\n       if (!background_color.is_rgb || !rhs.background_color.is_rgb)\n-        throw format_error(\"can't OR a terminal color\");\n+        FMT_THROW(format_error(\"can't OR a terminal color\"));\n       background_color.value.rgb_color |= rhs.background_color.value.rgb_color;\n     }\n \n@@ -291,18 +255,18 @@ class text_style {\n     return *this;\n   }\n \n-  friend FMT_CONSTEXPR\n-  text_style operator|(text_style lhs, const text_style &rhs) {\n+  friend FMT_CONSTEXPR text_style operator|(text_style lhs,\n+                                            const text_style& rhs) {\n     return lhs |= rhs;\n   }\n \n-  FMT_CONSTEXPR text_style &operator&=(const text_style &rhs) {\n+  FMT_CONSTEXPR text_style& operator&=(const text_style& rhs) {\n     if (!set_foreground_color) {\n       set_foreground_color = rhs.set_foreground_color;\n       foreground_color = rhs.foreground_color;\n     } else if (rhs.set_foreground_color) {\n       if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)\n-        throw format_error(\"can't AND a terminal color\");\n+        FMT_THROW(format_error(\"can't AND a terminal color\"));\n       foreground_color.value.rgb_color &= rhs.foreground_color.value.rgb_color;\n     }\n \n@@ -311,7 +275,7 @@ class text_style {\n       background_color = rhs.background_color;\n     } else if (rhs.set_background_color) {\n       if (!background_color.is_rgb || !rhs.background_color.is_rgb)\n-        throw format_error(\"can't AND a terminal color\");\n+        FMT_THROW(format_error(\"can't AND a terminal color\"));\n       background_color.value.rgb_color &= rhs.background_color.value.rgb_color;\n     }\n \n@@ -320,8 +284,8 @@ class text_style {\n     return *this;\n   }\n \n-  friend FMT_CONSTEXPR\n-  text_style operator&(text_style lhs, const text_style &rhs) {\n+  friend FMT_CONSTEXPR text_style operator&(text_style lhs,\n+                                            const text_style& rhs) {\n     return lhs &= rhs;\n   }\n \n@@ -347,20 +311,20 @@ class text_style {\n     return ems;\n   }\n \n-private:\n- FMT_CONSTEXPR text_style(bool is_foreground,\n-                          internal::color_type text_color) FMT_NOEXCEPT\n-     : set_foreground_color(),\n-       set_background_color(),\n-       ems() {\n-   if (is_foreground) {\n-     foreground_color = text_color;\n-     set_foreground_color = true;\n-   } else {\n-     background_color = text_color;\n-     set_background_color = true;\n-   }\n- }\n+ private:\n+  FMT_CONSTEXPR text_style(bool is_foreground,\n+                           internal::color_type text_color) FMT_NOEXCEPT\n+      : set_foreground_color(),\n+        set_background_color(),\n+        ems() {\n+    if (is_foreground) {\n+      foreground_color = text_color;\n+      set_foreground_color = true;\n+    } else {\n+      background_color = text_color;\n+      set_background_color = true;\n+    }\n+  }\n \n   friend FMT_CONSTEXPR_DECL text_style fg(internal::color_type foreground)\n       FMT_NOEXCEPT;\n@@ -388,19 +352,17 @@ FMT_CONSTEXPR text_style operator|(emphasis lhs, emphasis rhs) FMT_NOEXCEPT {\n \n namespace internal {\n \n-template <typename Char>\n-struct ansi_color_escape {\n+template <typename Char> struct ansi_color_escape {\n   FMT_CONSTEXPR ansi_color_escape(internal::color_type text_color,\n-                                  const char * esc) FMT_NOEXCEPT {\n+                                  const char* esc) FMT_NOEXCEPT {\n     // If we have a terminal color, we need to output another escape code\n     // sequence.\n     if (!text_color.is_rgb) {\n-      bool is_background = esc == internal::data::BACKGROUND_COLOR;\n+      bool is_background = esc == internal::data::background_color;\n       uint32_t value = text_color.value.term_color;\n       // Background ASCII codes are the same as the foreground ones but with\n       // 10 more.\n-      if (is_background)\n-        value += 10u;\n+      if (is_background) value += 10u;\n \n       std::size_t index = 0;\n       buffer[index++] = static_cast<Char>('\\x1b');\n@@ -422,7 +384,7 @@ struct ansi_color_escape {\n       buffer[i] = static_cast<Char>(esc[i]);\n     }\n     rgb color(text_color.value.rgb_color);\n-    to_esc(color.r, buffer +  7, ';');\n+    to_esc(color.r, buffer + 7, ';');\n     to_esc(color.g, buffer + 11, ';');\n     to_esc(color.b, buffer + 15, 'm');\n     buffer[19] = static_cast<Char>(0);\n@@ -430,19 +392,15 @@ struct ansi_color_escape {\n   FMT_CONSTEXPR ansi_color_escape(emphasis em) FMT_NOEXCEPT {\n     uint8_t em_codes[4] = {};\n     uint8_t em_bits = static_cast<uint8_t>(em);\n-    if (em_bits & static_cast<uint8_t>(emphasis::bold))\n-      em_codes[0] = 1;\n-    if (em_bits & static_cast<uint8_t>(emphasis::italic))\n-      em_codes[1] = 3;\n-    if (em_bits & static_cast<uint8_t>(emphasis::underline))\n-      em_codes[2] = 4;\n+    if (em_bits & static_cast<uint8_t>(emphasis::bold)) em_codes[0] = 1;\n+    if (em_bits & static_cast<uint8_t>(emphasis::italic)) em_codes[1] = 3;\n+    if (em_bits & static_cast<uint8_t>(emphasis::underline)) em_codes[2] = 4;\n     if (em_bits & static_cast<uint8_t>(emphasis::strikethrough))\n       em_codes[3] = 9;\n \n     std::size_t index = 0;\n     for (int i = 0; i < 4; ++i) {\n-      if (!em_codes[i])\n-        continue;\n+      if (!em_codes[i]) continue;\n       buffer[index++] = static_cast<Char>('\\x1b');\n       buffer[index++] = static_cast<Char>('[');\n       buffer[index++] = static_cast<Char>('0' + em_codes[i]);\n@@ -450,12 +408,17 @@ struct ansi_color_escape {\n     }\n     buffer[index++] = static_cast<Char>(0);\n   }\n-  FMT_CONSTEXPR operator const Char *() const FMT_NOEXCEPT { return buffer; }\n+  FMT_CONSTEXPR operator const Char*() const FMT_NOEXCEPT { return buffer; }\n+\n+  FMT_CONSTEXPR const Char* begin() const FMT_NOEXCEPT { return buffer; }\n+  FMT_CONSTEXPR const Char* end() const FMT_NOEXCEPT {\n+    return buffer + std::strlen(buffer);\n+  }\n \n-private:\n+ private:\n   Char buffer[7u + 3u * 4u + 1u];\n \n-  static FMT_CONSTEXPR void to_esc(uint8_t c, Char *out,\n+  static FMT_CONSTEXPR void to_esc(uint8_t c, Char* out,\n                                    char delimiter) FMT_NOEXCEPT {\n     out[0] = static_cast<Char>('0' + c / 100);\n     out[1] = static_cast<Char>('0' + c / 10 % 10);\n@@ -465,67 +428,90 @@ struct ansi_color_escape {\n };\n \n template <typename Char>\n-FMT_CONSTEXPR ansi_color_escape<Char>\n-make_foreground_color(internal::color_type foreground) FMT_NOEXCEPT {\n-  return ansi_color_escape<Char>(foreground, internal::data::FOREGROUND_COLOR);\n+FMT_CONSTEXPR ansi_color_escape<Char> make_foreground_color(\n+    internal::color_type foreground) FMT_NOEXCEPT {\n+  return ansi_color_escape<Char>(foreground, internal::data::foreground_color);\n }\n \n template <typename Char>\n-FMT_CONSTEXPR ansi_color_escape<Char>\n-make_background_color(internal::color_type background) FMT_NOEXCEPT {\n-  return ansi_color_escape<Char>(background, internal::data::BACKGROUND_COLOR);\n+FMT_CONSTEXPR ansi_color_escape<Char> make_background_color(\n+    internal::color_type background) FMT_NOEXCEPT {\n+  return ansi_color_escape<Char>(background, internal::data::background_color);\n }\n \n template <typename Char>\n-FMT_CONSTEXPR ansi_color_escape<Char>\n-make_emphasis(emphasis em) FMT_NOEXCEPT {\n+FMT_CONSTEXPR ansi_color_escape<Char> make_emphasis(emphasis em) FMT_NOEXCEPT {\n   return ansi_color_escape<Char>(em);\n }\n \n template <typename Char>\n-inline void fputs(const Char *chars, FILE *stream) FMT_NOEXCEPT {\n+inline void fputs(const Char* chars, FILE* stream) FMT_NOEXCEPT {\n   std::fputs(chars, stream);\n }\n \n template <>\n-inline void fputs<wchar_t>(const wchar_t *chars, FILE *stream) FMT_NOEXCEPT {\n+inline void fputs<wchar_t>(const wchar_t* chars, FILE* stream) FMT_NOEXCEPT {\n   std::fputws(chars, stream);\n }\n \n-template <typename Char>\n-inline void reset_color(FILE *stream) FMT_NOEXCEPT {\n-  fputs(internal::data::RESET_COLOR, stream);\n+template <typename Char> inline void reset_color(FILE* stream) FMT_NOEXCEPT {\n+  fputs(internal::data::reset_color, stream);\n }\n \n-template <>\n-inline void reset_color<wchar_t>(FILE *stream) FMT_NOEXCEPT {\n-  fputs(internal::data::WRESET_COLOR, stream);\n+template <> inline void reset_color<wchar_t>(FILE* stream) FMT_NOEXCEPT {\n+  fputs(internal::data::wreset_color, stream);\n }\n \n-// The following specialiazation disables using std::FILE as a character type,\n-// which is needed because or else\n-//   fmt::print(stderr, fmt::emphasis::bold, \"\");\n-// would take stderr (a std::FILE *) as the format string.\n-template <>\n-struct is_string<std::FILE *> : std::false_type {};\n-template <>\n-struct is_string<const std::FILE *> : std::false_type {};\n-} // namespace internal\n+template <typename Char>\n+inline void reset_color(basic_memory_buffer<Char>& buffer) FMT_NOEXCEPT {\n+  const char* begin = data::reset_color;\n+  const char* end = begin + sizeof(data::reset_color) - 1;\n+  buffer.append(begin, end);\n+}\n \n-template <\n-  typename S, typename Char = typename internal::char_t<S>::type>\n-void vprint(std::FILE *f, const text_style &ts, const S &format,\n-            basic_format_args<typename buffer_context<Char>::type> args) {\n+template <typename Char>\n+std::basic_string<Char> vformat(const text_style& ts,\n+                                basic_string_view<Char> format_str,\n+                                basic_format_args<buffer_context<Char> > args) {\n+  basic_memory_buffer<Char> buffer;\n   bool has_style = false;\n   if (ts.has_emphasis()) {\n     has_style = true;\n-    internal::fputs<Char>(\n-          internal::make_emphasis<Char>(ts.get_emphasis()), f);\n+    ansi_color_escape<Char> escape = make_emphasis<Char>(ts.get_emphasis());\n+    buffer.append(escape.begin(), escape.end());\n+  }\n+  if (ts.has_foreground()) {\n+    has_style = true;\n+    ansi_color_escape<Char> escape =\n+        make_foreground_color<Char>(ts.get_foreground());\n+    buffer.append(escape.begin(), escape.end());\n+  }\n+  if (ts.has_background()) {\n+    has_style = true;\n+    ansi_color_escape<Char> escape =\n+        make_background_color<Char>(ts.get_background());\n+    buffer.append(escape.begin(), escape.end());\n+  }\n+  internal::vformat_to(buffer, format_str, args);\n+  if (has_style) {\n+    reset_color<Char>(buffer);\n+  }\n+  return fmt::to_string(buffer);\n+}\n+}  // namespace internal\n+\n+template <typename S, typename Char = char_t<S> >\n+void vprint(std::FILE* f, const text_style& ts, const S& format,\n+            basic_format_args<buffer_context<Char> > args) {\n+  bool has_style = false;\n+  if (ts.has_emphasis()) {\n+    has_style = true;\n+    internal::fputs<Char>(internal::make_emphasis<Char>(ts.get_emphasis()), f);\n   }\n   if (ts.has_foreground()) {\n     has_style = true;\n     internal::fputs<Char>(\n-          internal::make_foreground_color<Char>(ts.get_foreground()), f);\n+        internal::make_foreground_color<Char>(ts.get_foreground()), f);\n   }\n   if (ts.has_background()) {\n     has_style = true;\n@@ -545,15 +531,14 @@ void vprint(std::FILE *f, const text_style &ts, const S &format,\n     fmt::print(fmt::emphasis::bold | fg(fmt::color::red),\n                \"Elapsed time: {0:.2f} seconds\", 1.23);\n  */\n-template <typename String, typename... Args>\n-typename std::enable_if<internal::is_string<String>::value>::type print(\n-    std::FILE *f, const text_style &ts, const String &format_str,\n-    const Args &... args) {\n+template <typename S, typename... Args,\n+          FMT_ENABLE_IF(internal::is_string<S>::value)>\n+void print(std::FILE* f, const text_style& ts, const S& format_str,\n+           const Args&... args) {\n   internal::check_format_string<Args...>(format_str);\n-  typedef typename internal::char_t<String>::type char_t;\n-  typedef typename buffer_context<char_t>::type context_t;\n-  format_arg_store<context_t, Args...> as{args...};\n-  vprint(f, ts, format_str, basic_format_args<context_t>(as));\n+  using context = buffer_context<char_t<S> >;\n+  format_arg_store<context, Args...> as{args...};\n+  vprint(f, ts, format_str, basic_format_args<context>(as));\n }\n \n /**\n@@ -563,14 +548,37 @@ typename std::enable_if<internal::is_string<String>::value>::type print(\n     fmt::print(fmt::emphasis::bold | fg(fmt::color::red),\n                \"Elapsed time: {0:.2f} seconds\", 1.23);\n  */\n-template <typename String, typename... Args>\n-typename std::enable_if<internal::is_string<String>::value>::type print(\n-    const text_style &ts, const String &format_str,\n-    const Args &... args) {\n+template <typename S, typename... Args,\n+          FMT_ENABLE_IF(internal::is_string<S>::value)>\n+void print(const text_style& ts, const S& format_str, const Args&... args) {\n   return print(stdout, ts, format_str, args...);\n }\n \n-#endif\n+template <typename S, typename Char = char_t<S> >\n+inline std::basic_string<Char> vformat(\n+    const text_style& ts, const S& format_str,\n+    basic_format_args<buffer_context<Char> > args) {\n+  return internal::vformat(ts, to_string_view(format_str), args);\n+}\n+\n+/**\n+  \\rst\n+  Formats arguments and returns the result as a string using ANSI\n+  escape sequences to specify text formatting.\n+\n+  **Example**::\n+\n+    #include <fmt/color.h>\n+    std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),\n+                                      \"The answer is {}\", 42);\n+  \\endrst\n+*/\n+template <typename S, typename... Args, typename Char = char_t<S> >\n+inline std::basic_string<Char> format(const text_style& ts, const S& format_str,\n+                                      const Args&... args) {\n+  return internal::vformat(ts, to_string_view(format_str),\n+                           {internal::make_args_checked(format_str, args...)});\n+}\n \n FMT_END_NAMESPACE\n \ndiff --git a/include/spdlog/fmt/bundled/compile.h b/include/spdlog/fmt/bundled/compile.h\nnew file mode 100644\n--- /dev/null\n+++ b/include/spdlog/fmt/bundled/compile.h\n@@ -0,0 +1,466 @@\n+// Formatting library for C++ - experimental format string compilation\n+//\n+// Copyright (c) 2012 - present, Victor Zverovich and fmt contributors\n+// All rights reserved.\n+//\n+// For the license information refer to format.h.\n+\n+#ifndef FMT_COMPILE_H_\n+#define FMT_COMPILE_H_\n+\n+#include <vector>\n+#include \"format.h\"\n+\n+FMT_BEGIN_NAMESPACE\n+namespace internal {\n+\n+template <typename Char> struct format_part {\n+ public:\n+  struct named_argument_id {\n+    FMT_CONSTEXPR named_argument_id(internal::string_view_metadata id)\n+        : id(id) {}\n+    internal::string_view_metadata id;\n+  };\n+\n+  struct argument_id {\n+    FMT_CONSTEXPR argument_id() : argument_id(0u) {}\n+\n+    FMT_CONSTEXPR argument_id(unsigned id)\n+        : which(which_arg_id::index), val(id) {}\n+\n+    FMT_CONSTEXPR argument_id(internal::string_view_metadata id)\n+        : which(which_arg_id::named_index), val(id) {}\n+\n+    enum class which_arg_id { index, named_index };\n+\n+    which_arg_id which;\n+\n+    union value {\n+      FMT_CONSTEXPR value() : index(0u) {}\n+      FMT_CONSTEXPR value(unsigned id) : index(id) {}\n+      FMT_CONSTEXPR value(internal::string_view_metadata id)\n+          : named_index(id) {}\n+\n+      unsigned index;\n+      internal::string_view_metadata named_index;\n+    } val;\n+  };\n+\n+  struct specification {\n+    FMT_CONSTEXPR specification() : arg_id(0u) {}\n+    FMT_CONSTEXPR specification(unsigned id) : arg_id(id) {}\n+\n+    FMT_CONSTEXPR specification(internal::string_view_metadata id)\n+        : arg_id(id) {}\n+\n+    argument_id arg_id;\n+    internal::dynamic_format_specs<Char> parsed_specs;\n+  };\n+\n+  FMT_CONSTEXPR format_part()\n+      : which(kind::argument_id), end_of_argument_id(0u), val(0u) {}\n+\n+  FMT_CONSTEXPR format_part(internal::string_view_metadata text)\n+      : which(kind::text), end_of_argument_id(0u), val(text) {}\n+\n+  FMT_CONSTEXPR format_part(unsigned id)\n+      : which(kind::argument_id), end_of_argument_id(0u), val(id) {}\n+\n+  FMT_CONSTEXPR format_part(named_argument_id arg_id)\n+      : which(kind::named_argument_id), end_of_argument_id(0u), val(arg_id) {}\n+\n+  FMT_CONSTEXPR format_part(specification spec)\n+      : which(kind::specification), end_of_argument_id(0u), val(spec) {}\n+\n+  enum class kind { argument_id, named_argument_id, text, specification };\n+\n+  kind which;\n+  std::size_t end_of_argument_id;\n+  union value {\n+    FMT_CONSTEXPR value() : arg_id(0u) {}\n+    FMT_CONSTEXPR value(unsigned id) : arg_id(id) {}\n+    FMT_CONSTEXPR value(named_argument_id named_id)\n+        : named_arg_id(named_id.id) {}\n+    FMT_CONSTEXPR value(internal::string_view_metadata t) : text(t) {}\n+    FMT_CONSTEXPR value(specification s) : spec(s) {}\n+    unsigned arg_id;\n+    internal::string_view_metadata named_arg_id;\n+    internal::string_view_metadata text;\n+    specification spec;\n+  } val;\n+};\n+\n+template <typename Char, typename PartsContainer>\n+class format_preparation_handler : public internal::error_handler {\n+ private:\n+  using part = format_part<Char>;\n+\n+ public:\n+  using iterator = typename basic_string_view<Char>::iterator;\n+\n+  FMT_CONSTEXPR format_preparation_handler(basic_string_view<Char> format,\n+                                           PartsContainer& parts)\n+      : parts_(parts), format_(format), parse_context_(format) {}\n+\n+  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {\n+    if (begin == end) return;\n+    const auto offset = begin - format_.data();\n+    const auto size = end - begin;\n+    parts_.push_back(part(string_view_metadata(offset, size)));\n+  }\n+\n+  FMT_CONSTEXPR void on_arg_id() {\n+    parts_.push_back(part(parse_context_.next_arg_id()));\n+  }\n+\n+  FMT_CONSTEXPR void on_arg_id(unsigned id) {\n+    parse_context_.check_arg_id(id);\n+    parts_.push_back(part(id));\n+  }\n+\n+  FMT_CONSTEXPR void on_arg_id(basic_string_view<Char> id) {\n+    const auto view = string_view_metadata(format_, id);\n+    const auto arg_id = typename part::named_argument_id(view);\n+    parts_.push_back(part(arg_id));\n+  }\n+\n+  FMT_CONSTEXPR void on_replacement_field(const Char* ptr) {\n+    parts_.back().end_of_argument_id = ptr - format_.begin();\n+  }\n+\n+  FMT_CONSTEXPR const Char* on_format_specs(const Char* begin,\n+                                            const Char* end) {\n+    const auto specs_offset = to_unsigned(begin - format_.begin());\n+\n+    using parse_context = basic_parse_context<Char>;\n+    internal::dynamic_format_specs<Char> parsed_specs;\n+    dynamic_specs_handler<parse_context> handler(parsed_specs, parse_context_);\n+    begin = parse_format_specs(begin, end, handler);\n+\n+    if (*begin != '}') on_error(\"missing '}' in format string\");\n+\n+    auto& last_part = parts_.back();\n+    auto specs = last_part.which == part::kind::argument_id\n+                     ? typename part::specification(last_part.val.arg_id)\n+                     : typename part::specification(last_part.val.named_arg_id);\n+    specs.parsed_specs = parsed_specs;\n+    last_part = part(specs);\n+    last_part.end_of_argument_id = specs_offset;\n+    return begin;\n+  }\n+\n+ private:\n+  PartsContainer& parts_;\n+  basic_string_view<Char> format_;\n+  basic_parse_context<Char> parse_context_;\n+};\n+\n+template <typename Format, typename PreparedPartsProvider, typename... Args>\n+class prepared_format {\n+ public:\n+  using char_type = char_t<Format>;\n+  using format_part_t = format_part<char_type>;\n+\n+  constexpr prepared_format(Format f)\n+      : format_(std::move(f)), parts_provider_(to_string_view(format_)) {}\n+\n+  prepared_format() = delete;\n+\n+  using context = buffer_context<char_type>;\n+\n+  template <typename Range, typename Context>\n+  auto vformat_to(Range out, basic_format_args<Context> args) const ->\n+      typename Context::iterator {\n+    const auto format_view = internal::to_string_view(format_);\n+    basic_parse_context<char_type> parse_ctx(format_view);\n+    Context ctx(out.begin(), args);\n+\n+    const auto& parts = parts_provider_.parts();\n+    for (auto part_it = parts.begin(); part_it != parts.end(); ++part_it) {\n+      const auto& part = *part_it;\n+      const auto& value = part.val;\n+\n+      switch (part.which) {\n+      case format_part_t::kind::text: {\n+        const auto text = value.text.to_view(format_view.data());\n+        auto output = ctx.out();\n+        auto&& it = internal::reserve(output, text.size());\n+        it = std::copy_n(text.begin(), text.size(), it);\n+        ctx.advance_to(output);\n+      } break;\n+\n+      case format_part_t::kind::argument_id: {\n+        advance_parse_context_to_specification(parse_ctx, part);\n+        format_arg<Range>(parse_ctx, ctx, value.arg_id);\n+      } break;\n+\n+      case format_part_t::kind::named_argument_id: {\n+        advance_parse_context_to_specification(parse_ctx, part);\n+        const auto named_arg_id =\n+            value.named_arg_id.to_view(format_view.data());\n+        format_arg<Range>(parse_ctx, ctx, named_arg_id);\n+      } break;\n+      case format_part_t::kind::specification: {\n+        const auto& arg_id_value = value.spec.arg_id.val;\n+        const auto arg = value.spec.arg_id.which ==\n+                                 format_part_t::argument_id::which_arg_id::index\n+                             ? ctx.arg(arg_id_value.index)\n+                             : ctx.arg(arg_id_value.named_index.to_view(\n+                                   to_string_view(format_).data()));\n+\n+        auto specs = value.spec.parsed_specs;\n+\n+        handle_dynamic_spec<internal::width_checker>(\n+            specs.width, specs.width_ref, ctx, format_view.begin());\n+        handle_dynamic_spec<internal::precision_checker>(\n+            specs.precision, specs.precision_ref, ctx, format_view.begin());\n+\n+        check_prepared_specs(specs, arg.type());\n+        advance_parse_context_to_specification(parse_ctx, part);\n+        ctx.advance_to(\n+            visit_format_arg(arg_formatter<Range>(ctx, nullptr, &specs), arg));\n+      } break;\n+      }\n+    }\n+\n+    return ctx.out();\n+  }\n+\n+ private:\n+  void advance_parse_context_to_specification(\n+      basic_parse_context<char_type>& parse_ctx,\n+      const format_part_t& part) const {\n+    const auto view = to_string_view(format_);\n+    const auto specification_begin = view.data() + part.end_of_argument_id;\n+    advance_to(parse_ctx, specification_begin);\n+  }\n+\n+  template <typename Range, typename Context, typename Id>\n+  void format_arg(basic_parse_context<char_type>& parse_ctx, Context& ctx,\n+                  Id arg_id) const {\n+    parse_ctx.check_arg_id(arg_id);\n+    const auto stopped_at =\n+        visit_format_arg(arg_formatter<Range>(ctx), ctx.arg(arg_id));\n+    ctx.advance_to(stopped_at);\n+  }\n+\n+  template <typename Char>\n+  void check_prepared_specs(const basic_format_specs<Char>& specs,\n+                            internal::type arg_type) const {\n+    internal::error_handler h;\n+    numeric_specs_checker<internal::error_handler> checker(h, arg_type);\n+    if (specs.align == align::numeric) checker.require_numeric_argument();\n+    if (specs.sign != sign::none) checker.check_sign();\n+    if (specs.alt) checker.require_numeric_argument();\n+    if (specs.precision >= 0) checker.check_precision();\n+  }\n+\n+ private:\n+  Format format_;\n+  PreparedPartsProvider parts_provider_;\n+};\n+\n+template <typename Char> struct part_counter {\n+  unsigned num_parts = 0;\n+\n+  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {\n+    if (begin != end) ++num_parts;\n+  }\n+\n+  FMT_CONSTEXPR void on_arg_id() { ++num_parts; }\n+  FMT_CONSTEXPR void on_arg_id(unsigned) { ++num_parts; }\n+  FMT_CONSTEXPR void on_arg_id(basic_string_view<Char>) { ++num_parts; }\n+\n+  FMT_CONSTEXPR void on_replacement_field(const Char*) {}\n+\n+  FMT_CONSTEXPR const Char* on_format_specs(const Char* begin,\n+                                            const Char* end) {\n+    // Find the matching brace.\n+    unsigned braces_counter = 0;\n+    for (; begin != end; ++begin) {\n+      if (*begin == '{') {\n+        ++braces_counter;\n+      } else if (*begin == '}') {\n+        if (braces_counter == 0u) break;\n+        --braces_counter;\n+      }\n+    }\n+    return begin;\n+  }\n+\n+  FMT_CONSTEXPR void on_error(const char*) {}\n+};\n+\n+template <typename Format> class compiletime_prepared_parts_type_provider {\n+ private:\n+  using char_type = char_t<Format>;\n+\n+  static FMT_CONSTEXPR unsigned count_parts() {\n+    FMT_CONSTEXPR_DECL const auto text = to_string_view(Format{});\n+    part_counter<char_type> counter;\n+    internal::parse_format_string</*IS_CONSTEXPR=*/true>(text, counter);\n+    return counter.num_parts;\n+  }\n+\n+// Workaround for old compilers. Compiletime parts preparation will not be\n+// performed with them anyway.\n+#if FMT_USE_CONSTEXPR\n+  static FMT_CONSTEXPR_DECL const unsigned number_of_format_parts =\n+      compiletime_prepared_parts_type_provider::count_parts();\n+#else\n+  static const unsigned number_of_format_parts = 0u;\n+#endif\n+\n+ public:\n+  template <unsigned N> struct format_parts_array {\n+    using value_type = format_part<char_type>;\n+\n+    FMT_CONSTEXPR format_parts_array() : arr{} {}\n+\n+    FMT_CONSTEXPR value_type& operator[](unsigned ind) { return arr[ind]; }\n+\n+    FMT_CONSTEXPR const value_type* begin() const { return arr; }\n+    FMT_CONSTEXPR const value_type* end() const { return begin() + N; }\n+\n+   private:\n+    value_type arr[N];\n+  };\n+\n+  struct empty {\n+    // Parts preparator will search for it\n+    using value_type = format_part<char_type>;\n+  };\n+\n+  using type = conditional_t<number_of_format_parts != 0,\n+                             format_parts_array<number_of_format_parts>, empty>;\n+};\n+\n+template <typename Parts> class compiletime_prepared_parts_collector {\n+ private:\n+  using format_part = typename Parts::value_type;\n+\n+ public:\n+  FMT_CONSTEXPR explicit compiletime_prepared_parts_collector(Parts& parts)\n+      : parts_{parts}, counter_{0u} {}\n+\n+  FMT_CONSTEXPR void push_back(format_part part) { parts_[counter_++] = part; }\n+\n+  FMT_CONSTEXPR format_part& back() { return parts_[counter_ - 1]; }\n+\n+ private:\n+  Parts& parts_;\n+  unsigned counter_;\n+};\n+\n+template <typename PartsContainer, typename Char>\n+FMT_CONSTEXPR PartsContainer prepare_parts(basic_string_view<Char> format) {\n+  PartsContainer parts;\n+  internal::parse_format_string</*IS_CONSTEXPR=*/false>(\n+      format, format_preparation_handler<Char, PartsContainer>(format, parts));\n+  return parts;\n+}\n+\n+template <typename PartsContainer, typename Char>\n+FMT_CONSTEXPR PartsContainer\n+prepare_compiletime_parts(basic_string_view<Char> format) {\n+  using collector = compiletime_prepared_parts_collector<PartsContainer>;\n+\n+  PartsContainer parts;\n+  collector c(parts);\n+  internal::parse_format_string</*IS_CONSTEXPR=*/true>(\n+      format, format_preparation_handler<Char, collector>(format, c));\n+  return parts;\n+}\n+\n+template <typename PartsContainer> class runtime_parts_provider {\n+ public:\n+  runtime_parts_provider() = delete;\n+  template <typename Char>\n+  runtime_parts_provider(basic_string_view<Char> format)\n+      : parts_(prepare_parts<PartsContainer>(format)) {}\n+\n+  const PartsContainer& parts() const { return parts_; }\n+\n+ private:\n+  PartsContainer parts_;\n+};\n+\n+template <typename Format, typename PartsContainer>\n+struct compiletime_parts_provider {\n+  compiletime_parts_provider() = delete;\n+  template <typename Char>\n+  FMT_CONSTEXPR compiletime_parts_provider(basic_string_view<Char>) {}\n+\n+  const PartsContainer& parts() const {\n+    static FMT_CONSTEXPR_DECL const PartsContainer prepared_parts =\n+        prepare_compiletime_parts<PartsContainer>(\n+            internal::to_string_view(Format{}));\n+\n+    return prepared_parts;\n+  }\n+};\n+}  // namespace internal\n+\n+#if FMT_USE_CONSTEXPR\n+template <typename... Args, typename S,\n+          FMT_ENABLE_IF(is_compile_string<S>::value)>\n+FMT_CONSTEXPR auto compile(S format_str) -> internal::prepared_format<\n+    S,\n+    internal::compiletime_parts_provider<\n+        S,\n+        typename internal::compiletime_prepared_parts_type_provider<S>::type>,\n+    Args...> {\n+  return format_str;\n+}\n+#endif\n+\n+template <typename... Args, typename Char, size_t N>\n+auto compile(const Char (&format_str)[N]) -> internal::prepared_format<\n+    std::basic_string<Char>,\n+    internal::runtime_parts_provider<std::vector<internal::format_part<Char>>>,\n+    Args...> {\n+  return std::basic_string<Char>(format_str, N - 1);\n+}\n+\n+template <typename CompiledFormat, typename... Args,\n+          typename Char = typename CompiledFormat::char_type>\n+std::basic_string<Char> format(const CompiledFormat& cf, const Args&... args) {\n+  basic_memory_buffer<Char> buffer;\n+  using range = internal::buffer_range<Char>;\n+  using context = buffer_context<Char>;\n+  cf.template vformat_to<range, context>(range(buffer),\n+                                         {make_format_args<context>(args...)});\n+  return to_string(buffer);\n+}\n+\n+template <typename OutputIt, typename CompiledFormat, typename... Args>\n+OutputIt format_to(OutputIt out, const CompiledFormat& cf,\n+                   const Args&... args) {\n+  using char_type = typename CompiledFormat::char_type;\n+  using range = internal::output_range<OutputIt, char_type>;\n+  using context = format_context_t<OutputIt, char_type>;\n+  return cf.template vformat_to<range, context>(\n+      range(out), {make_format_args<context>(args...)});\n+}\n+\n+template <typename OutputIt, typename CompiledFormat, typename... Args,\n+          FMT_ENABLE_IF(internal::is_output_iterator<OutputIt>::value)>\n+format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n,\n+                                         const CompiledFormat& cf,\n+                                         const Args&... args) {\n+  auto it =\n+      format_to(internal::truncating_iterator<OutputIt>(out, n), cf, args...);\n+  return {it.base(), it.count()};\n+}\n+\n+template <typename CompiledFormat, typename... Args>\n+std::size_t formatted_size(const CompiledFormat& cf, const Args&... args) {\n+  return fmt::format_to(\n+             internal::counting_iterator<typename CompiledFormat::char_type>(),\n+             cf, args...)\n+      .count();\n+}\n+\n+FMT_END_NAMESPACE\n+\n+#endif  // FMT_COMPILE_H_\ndiff --git a/include/spdlog/fmt/bundled/core.h b/include/spdlog/fmt/bundled/core.h\n--- a/include/spdlog/fmt/bundled/core.h\n+++ b/include/spdlog/fmt/bundled/core.h\n@@ -16,192 +16,211 @@\n #include <type_traits>\n \n // The fmt library version in the form major * 10000 + minor * 100 + patch.\n-#define FMT_VERSION 50300\n+#define FMT_VERSION 60000\n \n #ifdef __has_feature\n-# define FMT_HAS_FEATURE(x) __has_feature(x)\n+#  define FMT_HAS_FEATURE(x) __has_feature(x)\n #else\n-# define FMT_HAS_FEATURE(x) 0\n+#  define FMT_HAS_FEATURE(x) 0\n #endif\n \n #if defined(__has_include) && !defined(__INTELLISENSE__) && \\\n     !(defined(__INTEL_COMPILER) && __INTEL_COMPILER < 1600)\n-# define FMT_HAS_INCLUDE(x) __has_include(x)\n+#  define FMT_HAS_INCLUDE(x) __has_include(x)\n #else\n-# define FMT_HAS_INCLUDE(x) 0\n+#  define FMT_HAS_INCLUDE(x) 0\n #endif\n \n #ifdef __has_cpp_attribute\n-# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n+#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n #else\n-# define FMT_HAS_CPP_ATTRIBUTE(x) 0\n+#  define FMT_HAS_CPP_ATTRIBUTE(x) 0\n #endif\n \n #if defined(__GNUC__) && !defined(__clang__)\n-# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)\n+#  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)\n #else\n-# define FMT_GCC_VERSION 0\n+#  define FMT_GCC_VERSION 0\n #endif\n \n #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)\n-# define FMT_HAS_GXX_CXX11 FMT_GCC_VERSION\n+#  define FMT_HAS_GXX_CXX11 FMT_GCC_VERSION\n #else\n-# define FMT_HAS_GXX_CXX11 0\n+#  define FMT_HAS_GXX_CXX11 0\n #endif\n \n #ifdef _MSC_VER\n-# define FMT_MSC_VER _MSC_VER\n+#  define FMT_MSC_VER _MSC_VER\n #else\n-# define FMT_MSC_VER 0\n+#  define FMT_MSC_VER 0\n #endif\n \n // Check if relaxed C++14 constexpr is supported.\n // GCC doesn't allow throw in constexpr until version 6 (bug 67371).\n #ifndef FMT_USE_CONSTEXPR\n-# define FMT_USE_CONSTEXPR \\\n-  (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VER >= 1910 || \\\n-   (FMT_GCC_VERSION >= 600 && __cplusplus >= 201402L))\n+#  define FMT_USE_CONSTEXPR                                           \\\n+    (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VER >= 1910 || \\\n+     (FMT_GCC_VERSION >= 600 && __cplusplus >= 201402L))\n #endif\n #if FMT_USE_CONSTEXPR\n-# define FMT_CONSTEXPR constexpr\n-# define FMT_CONSTEXPR_DECL constexpr\n+#  define FMT_CONSTEXPR constexpr\n+#  define FMT_CONSTEXPR_DECL constexpr\n #else\n-# define FMT_CONSTEXPR inline\n-# define FMT_CONSTEXPR_DECL\n-#endif\n-\n-#ifndef FMT_USE_CONSTEXPR11\n-# define FMT_USE_CONSTEXPR11 \\\n-    (FMT_USE_CONSTEXPR || FMT_GCC_VERSION >= 406 || FMT_MSC_VER >= 1900)\n-#endif\n-#if FMT_USE_CONSTEXPR11\n-# define FMT_CONSTEXPR11 constexpr\n-#else\n-# define FMT_CONSTEXPR11\n+#  define FMT_CONSTEXPR inline\n+#  define FMT_CONSTEXPR_DECL\n #endif\n \n #ifndef FMT_OVERRIDE\n-# if FMT_HAS_FEATURE(cxx_override) || \\\n-     (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900\n-#  define FMT_OVERRIDE override\n-# else\n-#  define FMT_OVERRIDE\n-# endif\n-#endif\n-\n-#if FMT_HAS_FEATURE(cxx_explicit_conversions) || \\\n-    FMT_GCC_VERSION >= 405 || FMT_MSC_VER >= 1800\n-# define FMT_USE_EXPLICIT 1\n-# define FMT_EXPLICIT explicit\n-#else\n-# define FMT_USE_EXPLICIT 0\n-# define FMT_EXPLICIT\n-#endif\n-\n-#ifndef FMT_NULL\n-# if FMT_HAS_FEATURE(cxx_nullptr) || \\\n-   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1600\n-#  define FMT_NULL nullptr\n-#  define FMT_USE_NULLPTR 1\n-# else\n-#  define FMT_NULL NULL\n-# endif\n-#endif\n-#ifndef FMT_USE_NULLPTR\n-# define FMT_USE_NULLPTR 0\n+#  if FMT_HAS_FEATURE(cxx_override) || \\\n+      (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900\n+#    define FMT_OVERRIDE override\n+#  else\n+#    define FMT_OVERRIDE\n+#  endif\n #endif\n \n // Check if exceptions are disabled.\n #ifndef FMT_EXCEPTIONS\n-# if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \\\n-     FMT_MSC_VER && !_HAS_EXCEPTIONS\n-#  define FMT_EXCEPTIONS 0\n-# else\n-#  define FMT_EXCEPTIONS 1\n-# endif\n+#  if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \\\n+      FMT_MSC_VER && !_HAS_EXCEPTIONS\n+#    define FMT_EXCEPTIONS 0\n+#  else\n+#    define FMT_EXCEPTIONS 1\n+#  endif\n #endif\n \n // Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).\n #ifndef FMT_USE_NOEXCEPT\n-# define FMT_USE_NOEXCEPT 0\n+#  define FMT_USE_NOEXCEPT 0\n #endif\n \n #if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \\\n     (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900\n-# define FMT_DETECTED_NOEXCEPT noexcept\n-# define FMT_HAS_CXX11_NOEXCEPT 1\n+#  define FMT_DETECTED_NOEXCEPT noexcept\n+#  define FMT_HAS_CXX11_NOEXCEPT 1\n #else\n-# define FMT_DETECTED_NOEXCEPT throw()\n-# define FMT_HAS_CXX11_NOEXCEPT 0\n+#  define FMT_DETECTED_NOEXCEPT throw()\n+#  define FMT_HAS_CXX11_NOEXCEPT 0\n #endif\n \n #ifndef FMT_NOEXCEPT\n-# if FMT_EXCEPTIONS || FMT_HAS_CXX11_NOEXCEPT\n-#  define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT\n-# else\n-#  define FMT_NOEXCEPT\n-# endif\n+#  if FMT_EXCEPTIONS || FMT_HAS_CXX11_NOEXCEPT\n+#    define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT\n+#  else\n+#    define FMT_NOEXCEPT\n+#  endif\n+#endif\n+\n+// [[noreturn]] is disabled on MSVC because of bogus unreachable code warnings.\n+#if FMT_EXCEPTIONS && FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VER\n+#  define FMT_NORETURN [[noreturn]]\n+#else\n+#  define FMT_NORETURN\n+#endif\n+\n+#ifndef FMT_DEPRECATED\n+#  if (FMT_HAS_CPP_ATTRIBUTE(deprecated) && __cplusplus >= 201402L) || \\\n+      FMT_MSC_VER >= 1900\n+#    define FMT_DEPRECATED [[deprecated]]\n+#  else\n+#    if defined(__GNUC__) || defined(__clang__)\n+#      define FMT_DEPRECATED __attribute__((deprecated))\n+#    elif FMT_MSC_VER\n+#      define FMT_DEPRECATED __declspec(deprecated)\n+#    else\n+#      define FMT_DEPRECATED /* deprecated */\n+#    endif\n+#  endif\n #endif\n \n #ifndef FMT_BEGIN_NAMESPACE\n-# if FMT_HAS_FEATURE(cxx_inline_namespaces) || FMT_GCC_VERSION >= 404 || \\\n-     FMT_MSC_VER >= 1900\n-#  define FMT_INLINE_NAMESPACE inline namespace\n-#  define FMT_END_NAMESPACE }}\n-# else\n-#  define FMT_INLINE_NAMESPACE namespace\n-#  define FMT_END_NAMESPACE } using namespace v5; }\n-# endif\n-# define FMT_BEGIN_NAMESPACE namespace fmt { FMT_INLINE_NAMESPACE v5 {\n+#  if FMT_HAS_FEATURE(cxx_inline_namespaces) || FMT_GCC_VERSION >= 404 || \\\n+      FMT_MSC_VER >= 1900\n+#    define FMT_INLINE_NAMESPACE inline namespace\n+#    define FMT_END_NAMESPACE \\\n+      }                       \\\n+      }\n+#  else\n+#    define FMT_INLINE_NAMESPACE namespace\n+#    define FMT_END_NAMESPACE \\\n+      }                       \\\n+      using namespace v6;     \\\n+      }\n+#  endif\n+#  define FMT_BEGIN_NAMESPACE \\\n+    namespace fmt {           \\\n+    FMT_INLINE_NAMESPACE v6 {\n #endif\n \n #if !defined(FMT_HEADER_ONLY) && defined(_WIN32)\n-# ifdef FMT_EXPORT\n-#  define FMT_API __declspec(dllexport)\n-# elif defined(FMT_SHARED)\n-#  define FMT_API __declspec(dllimport)\n-# endif\n+#  ifdef FMT_EXPORT\n+#    define FMT_API __declspec(dllexport)\n+#  elif defined(FMT_SHARED)\n+#    define FMT_API __declspec(dllimport)\n+#    define FMT_EXTERN_TEMPLATE_API FMT_API\n+#  endif\n #endif\n #ifndef FMT_API\n-# define FMT_API\n+#  define FMT_API\n+#endif\n+#ifndef FMT_EXTERN_TEMPLATE_API\n+#  define FMT_EXTERN_TEMPLATE_API\n+#endif\n+\n+#ifndef FMT_HEADER_ONLY\n+#  define FMT_EXTERN extern\n+#else\n+#  define FMT_EXTERN\n #endif\n \n #ifndef FMT_ASSERT\n-# define FMT_ASSERT(condition, message) assert((condition) && message)\n+#  define FMT_ASSERT(condition, message) assert((condition) && message)\n #endif\n \n // libc++ supports string_view in pre-c++17.\n-#if (FMT_HAS_INCLUDE(<string_view>) && \\\n-      (__cplusplus > 201402L || defined(_LIBCPP_VERSION))) || \\\n+#if (FMT_HAS_INCLUDE(<string_view>) &&                       \\\n+     (__cplusplus > 201402L || defined(_LIBCPP_VERSION))) || \\\n     (defined(_MSVC_LANG) && _MSVC_LANG > 201402L && _MSC_VER >= 1910)\n-# include <string_view>\n-# define FMT_STRING_VIEW std::basic_string_view\n-#elif FMT_HAS_INCLUDE(<experimental/string_view>) && __cplusplus >= 201402L\n-# include <experimental/string_view>\n-# define FMT_STRING_VIEW std::experimental::basic_string_view\n-#endif\n-\n-// std::result_of is defined in <functional> in gcc 4.4.\n-#if FMT_GCC_VERSION && FMT_GCC_VERSION <= 404\n-# include <functional>\n+#  include <string_view>\n+#  define FMT_USE_STRING_VIEW\n+#elif FMT_HAS_INCLUDE(\"experimental/string_view\") && __cplusplus >= 201402L\n+#  include <experimental/string_view>\n+#  define FMT_USE_EXPERIMENTAL_STRING_VIEW\n #endif\n \n FMT_BEGIN_NAMESPACE\n-namespace internal {\n \n-// An implementation of declval for pre-C++11 compilers such as gcc 4.\n+// Implementations of enable_if_t and other types for pre-C++14 systems.\n+template <bool B, class T = void>\n+using enable_if_t = typename std::enable_if<B, T>::type;\n+template <bool B, class T, class F>\n+using conditional_t = typename std::conditional<B, T, F>::type;\n+template <bool B> using bool_constant = std::integral_constant<bool, B>;\n template <typename T>\n-typename std::add_rvalue_reference<T>::type declval() FMT_NOEXCEPT;\n+using remove_reference_t = typename std::remove_reference<T>::type;\n+template <typename T>\n+using remove_const_t = typename std::remove_const<T>::type;\n \n-template <typename>\n-struct result_of;\n+struct monostate {};\n \n-template <typename F, typename... Args>\n-struct result_of<F(Args...)> {\n-  // A workaround for gcc 4.4 that doesn't allow F to be a reference.\n-  typedef typename std::result_of<\n-    typename std::remove_reference<F>::type(Args...)>::type type;\n-};\n+// An enable_if helper to be used in template parameters which results in much\n+// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed\n+// to workaround a bug in MSVC 2019 (see #1140 and #1186).\n+#define FMT_ENABLE_IF(...) enable_if_t<(__VA_ARGS__), int> = 0\n+\n+namespace internal {\n+\n+// A workaround for gcc 4.8 to make void_t work in a SFINAE context.\n+template <typename... Ts> struct void_t_impl { using type = void; };\n+\n+#if defined(FMT_USE_STRING_VIEW)\n+template <typename Char> using std_string_view = std::basic_string_view<Char>;\n+#elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)\n+template <typename Char>\n+using std_string_view = std::experimental::basic_string_view<Char>;\n+#else\n+template <typename T> struct std_string_view {};\n+#endif\n \n // Casts nonnegative integer to unsigned.\n template <typename Int>\n@@ -209,135 +228,10 @@ FMT_CONSTEXPR typename std::make_unsigned<Int>::type to_unsigned(Int value) {\n   FMT_ASSERT(value >= 0, \"negative value\");\n   return static_cast<typename std::make_unsigned<Int>::type>(value);\n }\n-\n-/** A contiguous memory buffer with an optional growing ability. */\n-template <typename T>\n-class basic_buffer {\n- private:\n-  basic_buffer(const basic_buffer &) = delete;\n-  void operator=(const basic_buffer &) = delete;\n-\n-  T *ptr_;\n-  std::size_t size_;\n-  std::size_t capacity_;\n-\n- protected:\n-  // Don't initialize ptr_ since it is not accessed to save a few cycles.\n-  basic_buffer(std::size_t sz) FMT_NOEXCEPT: size_(sz), capacity_(sz) {}\n-\n-  basic_buffer(T *p = FMT_NULL, std::size_t sz = 0, std::size_t cap = 0)\n-    FMT_NOEXCEPT: ptr_(p), size_(sz), capacity_(cap) {}\n-\n-  /** Sets the buffer data and capacity. */\n-  void set(T *buf_data, std::size_t buf_capacity) FMT_NOEXCEPT {\n-    ptr_ = buf_data;\n-    capacity_ = buf_capacity;\n-  }\n-\n-  /** Increases the buffer capacity to hold at least *capacity* elements. */\n-  virtual void grow(std::size_t capacity) = 0;\n-\n- public:\n-  typedef T value_type;\n-  typedef const T &const_reference;\n-\n-  virtual ~basic_buffer() {}\n-\n-  T *begin() FMT_NOEXCEPT { return ptr_; }\n-  T *end() FMT_NOEXCEPT { return ptr_ + size_; }\n-\n-  /** Returns the size of this buffer. */\n-  std::size_t size() const FMT_NOEXCEPT { return size_; }\n-\n-  /** Returns the capacity of this buffer. */\n-  std::size_t capacity() const FMT_NOEXCEPT { return capacity_; }\n-\n-  /** Returns a pointer to the buffer data. */\n-  T *data() FMT_NOEXCEPT { return ptr_; }\n-\n-  /** Returns a pointer to the buffer data. */\n-  const T *data() const FMT_NOEXCEPT { return ptr_; }\n-\n-  /**\n-    Resizes the buffer. If T is a POD type new elements may not be initialized.\n-   */\n-  void resize(std::size_t new_size) {\n-    reserve(new_size);\n-    size_ = new_size;\n-  }\n-\n-  /** Clears this buffer. */\n-  void clear() { size_ = 0; }\n-\n-  /** Reserves space to store at least *capacity* elements. */\n-  void reserve(std::size_t new_capacity) {\n-    if (new_capacity > capacity_)\n-      grow(new_capacity);\n-  }\n-\n-  void push_back(const T &value) {\n-    reserve(size_ + 1);\n-    ptr_[size_++] = value;\n-  }\n-\n-  /** Appends data to the end of the buffer. */\n-  template <typename U>\n-  void append(const U *begin, const U *end);\n-\n-  T &operator[](std::size_t index) { return ptr_[index]; }\n-  const T &operator[](std::size_t index) const { return ptr_[index]; }\n-};\n-\n-typedef basic_buffer<char> buffer;\n-typedef basic_buffer<wchar_t> wbuffer;\n-\n-// A container-backed buffer.\n-template <typename Container>\n-class container_buffer : public basic_buffer<typename Container::value_type> {\n- private:\n-  Container &container_;\n-\n- protected:\n-  void grow(std::size_t capacity) FMT_OVERRIDE {\n-    container_.resize(capacity);\n-    this->set(&container_[0], capacity);\n-  }\n-\n- public:\n-  explicit container_buffer(Container &c)\n-    : basic_buffer<typename Container::value_type>(c.size()), container_(c) {}\n-};\n-\n-// Extracts a reference to the container from back_insert_iterator.\n-template <typename Container>\n-inline Container &get_container(std::back_insert_iterator<Container> it) {\n-  typedef std::back_insert_iterator<Container> bi_iterator;\n-  struct accessor: bi_iterator {\n-    accessor(bi_iterator iter) : bi_iterator(iter) {}\n-    using bi_iterator::container;\n-  };\n-  return *accessor(it).container;\n-}\n-\n-struct error_handler {\n-  FMT_CONSTEXPR error_handler() {}\n-  FMT_CONSTEXPR error_handler(const error_handler &) {}\n-\n-  // This function is intentionally not constexpr to give a compile-time error.\n-  FMT_API void on_error(const char *message);\n-};\n-\n-template <typename T>\n-struct no_formatter_error : std::false_type {};\n }  // namespace internal\n \n-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 405\n-template <typename... T>\n-struct is_constructible: std::false_type {};\n-#else\n-template <typename... T>\n-struct is_constructible : std::is_constructible<T...> {};\n-#endif\n+template <typename... Ts>\n+using void_t = typename internal::void_t_impl<Ts...>::type;\n \n /**\n   An implementation of ``std::basic_string_view`` for pre-C++17. It provides a\n@@ -346,21 +240,21 @@ struct is_constructible : std::is_constructible<T...> {};\n   compiled with a different ``-std`` option than the client code (which is not\n   recommended).\n  */\n-template <typename Char>\n-class basic_string_view {\n+template <typename Char> class basic_string_view {\n  private:\n-  const Char *data_;\n+  const Char* data_;\n   size_t size_;\n \n  public:\n-  typedef Char char_type;\n-  typedef const Char *iterator;\n+  using char_type = Char;\n+  using iterator = const Char*;\n \n-  FMT_CONSTEXPR basic_string_view() FMT_NOEXCEPT : data_(FMT_NULL), size_(0) {}\n+  FMT_CONSTEXPR basic_string_view() FMT_NOEXCEPT : data_(nullptr), size_(0) {}\n \n   /** Constructs a string reference object from a C string and a size. */\n-  FMT_CONSTEXPR basic_string_view(const Char *s, size_t count) FMT_NOEXCEPT\n-    : data_(s), size_(count) {}\n+  FMT_CONSTEXPR basic_string_view(const Char* s, size_t count) FMT_NOEXCEPT\n+      : data_(s),\n+        size_(count) {}\n \n   /**\n     \\rst\n@@ -368,22 +262,23 @@ class basic_string_view {\n     the size with ``std::char_traits<Char>::length``.\n     \\endrst\n    */\n-  basic_string_view(const Char *s)\n-    : data_(s), size_(std::char_traits<Char>::length(s)) {}\n+  basic_string_view(const Char* s)\n+      : data_(s), size_(std::char_traits<Char>::length(s)) {}\n \n   /** Constructs a string reference from a ``std::basic_string`` object. */\n   template <typename Alloc>\n-  FMT_CONSTEXPR basic_string_view(\n-      const std::basic_string<Char, Alloc> &s) FMT_NOEXCEPT\n-  : data_(s.data()), size_(s.size()) {}\n+  FMT_CONSTEXPR basic_string_view(const std::basic_string<Char, Alloc>& s)\n+      FMT_NOEXCEPT : data_(s.data()),\n+                     size_(s.size()) {}\n \n-#ifdef FMT_STRING_VIEW\n-  FMT_CONSTEXPR basic_string_view(FMT_STRING_VIEW<Char> s) FMT_NOEXCEPT\n-  : data_(s.data()), size_(s.size()) {}\n-#endif\n+  template <\n+      typename S,\n+      FMT_ENABLE_IF(std::is_same<S, internal::std_string_view<Char>>::value)>\n+  FMT_CONSTEXPR basic_string_view(S s) FMT_NOEXCEPT : data_(s.data()),\n+                                                      size_(s.size()) {}\n \n   /** Returns a pointer to the string data. */\n-  FMT_CONSTEXPR const Char *data() const { return data_; }\n+  FMT_CONSTEXPR const Char* data() const { return data_; }\n \n   /** Returns the string size. */\n   FMT_CONSTEXPR size_t size() const { return size_; }\n@@ -425,47 +320,60 @@ class basic_string_view {\n   }\n };\n \n-typedef basic_string_view<char> string_view;\n-typedef basic_string_view<wchar_t> wstring_view;\n+using string_view = basic_string_view<char>;\n+using wstring_view = basic_string_view<wchar_t>;\n+\n+#ifndef __cpp_char8_t\n+// A UTF-8 code unit type.\n+enum char8_t : unsigned char {};\n+#endif\n+\n+/** Specifies if ``T`` is a character type. Can be specialized by users. */\n+template <typename T> struct is_char : std::false_type {};\n+template <> struct is_char<char> : std::true_type {};\n+template <> struct is_char<wchar_t> : std::true_type {};\n+template <> struct is_char<char8_t> : std::true_type {};\n+template <> struct is_char<char16_t> : std::true_type {};\n+template <> struct is_char<char32_t> : std::true_type {};\n \n /**\n   \\rst\n-  The function ``to_string_view`` adapts non-intrusively any kind of string or\n-  string-like type if the user provides a (possibly templated) overload of\n-  ``to_string_view`` which takes an instance of the string class\n-  ``StringType<Char>`` and returns a ``fmt::basic_string_view<Char>``.\n-  The conversion function must live in the very same namespace as\n-  ``StringType<Char>`` to be picked up by ADL. Non-templated string types\n-  like f.e. QString must return a ``basic_string_view`` with a fixed matching\n-  char type.\n+  Returns a string view of `s`. In order to add custom string type support to\n+  {fmt} provide an overload of `to_string_view` for it in the same namespace as\n+  the type for the argument-dependent lookup to work.\n \n   **Example**::\n \n     namespace my_ns {\n-    inline string_view to_string_view(const my_string &s) {\n+    inline string_view to_string_view(const my_string& s) {\n       return {s.data(), s.length()};\n     }\n     }\n-\n     std::string message = fmt::format(my_string(\"The answer is {}\"), 42);\n   \\endrst\n  */\n-template <typename Char>\n-inline basic_string_view<Char>\n-  to_string_view(basic_string_view<Char> s) { return s; }\n+template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>\n+inline basic_string_view<Char> to_string_view(const Char* s) {\n+  return s;\n+}\n \n-template <typename Char>\n-inline basic_string_view<Char>\n-  to_string_view(const std::basic_string<Char> &s) { return s; }\n+template <typename Char, typename Traits, typename Allocator>\n+inline basic_string_view<Char> to_string_view(\n+    const std::basic_string<Char, Traits, Allocator>& s) {\n+  return {s.data(), s.size()};\n+}\n \n template <typename Char>\n-inline basic_string_view<Char> to_string_view(const Char *s) { return s; }\n+inline basic_string_view<Char> to_string_view(basic_string_view<Char> s) {\n+  return s;\n+}\n \n-#ifdef FMT_STRING_VIEW\n-template <typename Char>\n-inline basic_string_view<Char>\n-  to_string_view(FMT_STRING_VIEW<Char> s) { return s; }\n-#endif\n+template <typename Char,\n+          FMT_ENABLE_IF(!std::is_empty<internal::std_string_view<Char>>::value)>\n+inline basic_string_view<Char> to_string_view(\n+    internal::std_string_view<Char> s) {\n+  return s;\n+}\n \n // A base class for compile-time strings. It is defined in the fmt namespace to\n // make formatting functions visible via ADL, e.g. format(fmt(\"{}\"), 42).\n@@ -474,332 +382,504 @@ struct compile_string {};\n template <typename S>\n struct is_compile_string : std::is_base_of<compile_string, S> {};\n \n-template <\n-  typename S,\n-  typename Enable = typename std::enable_if<is_compile_string<S>::value>::type>\n-FMT_CONSTEXPR basic_string_view<typename S::char_type>\n-  to_string_view(const S &s) { return s; }\n+template <typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>\n+constexpr basic_string_view<typename S::char_type> to_string_view(const S& s) {\n+  return s;\n+}\n+\n+namespace internal {\n+void to_string_view(...);\n+using fmt::v6::to_string_view;\n \n-template <typename Context>\n-class basic_format_arg;\n+// Specifies whether S is a string type convertible to fmt::basic_string_view.\n+// It should be a constexpr function but MSVC 2017 fails to compile it in\n+// enable_if and MSVC 2015 fails to compile it as an alias template.\n+template <typename S>\n+struct is_string : std::is_class<decltype(to_string_view(std::declval<S>()))> {\n+};\n+\n+template <typename S, typename = void> struct char_t_impl {};\n+template <typename S> struct char_t_impl<S, enable_if_t<is_string<S>::value>> {\n+  using result = decltype(to_string_view(std::declval<S>()));\n+  using type = typename result::char_type;\n+};\n \n-template <typename Context>\n-class basic_format_args;\n+struct error_handler {\n+  FMT_CONSTEXPR error_handler() {}\n+  FMT_CONSTEXPR error_handler(const error_handler&) {}\n+\n+  // This function is intentionally not constexpr to give a compile-time error.\n+  FMT_NORETURN FMT_API void on_error(const char* message);\n+};\n+}  // namespace internal\n+\n+/** String's character type. */\n+template <typename S> using char_t = typename internal::char_t_impl<S>::type;\n+\n+// Parsing context consisting of a format string range being parsed and an\n+// argument counter for automatic indexing.\n+template <typename Char, typename ErrorHandler = internal::error_handler>\n+class basic_parse_context : private ErrorHandler {\n+ private:\n+  basic_string_view<Char> format_str_;\n+  int next_arg_id_;\n+\n+ public:\n+  using char_type = Char;\n+  using iterator = typename basic_string_view<Char>::iterator;\n+\n+  explicit FMT_CONSTEXPR basic_parse_context(basic_string_view<Char> format_str,\n+                                             ErrorHandler eh = ErrorHandler())\n+      : ErrorHandler(eh), format_str_(format_str), next_arg_id_(0) {}\n+\n+  // Returns an iterator to the beginning of the format string range being\n+  // parsed.\n+  FMT_CONSTEXPR iterator begin() const FMT_NOEXCEPT {\n+    return format_str_.begin();\n+  }\n+\n+  // Returns an iterator past the end of the format string range being parsed.\n+  FMT_CONSTEXPR iterator end() const FMT_NOEXCEPT { return format_str_.end(); }\n+\n+  // Advances the begin iterator to ``it``.\n+  FMT_CONSTEXPR void advance_to(iterator it) {\n+    format_str_.remove_prefix(internal::to_unsigned(it - begin()));\n+  }\n+\n+  // Returns the next argument index.\n+  FMT_CONSTEXPR int next_arg_id() {\n+    if (next_arg_id_ >= 0) return next_arg_id_++;\n+    on_error(\"cannot switch from manual to automatic argument indexing\");\n+    return 0;\n+  }\n+\n+  FMT_CONSTEXPR bool check_arg_id(int) {\n+    if (next_arg_id_ > 0) {\n+      on_error(\"cannot switch from automatic to manual argument indexing\");\n+      return false;\n+    }\n+    next_arg_id_ = -1;\n+    return true;\n+  }\n+\n+  FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {}\n+\n+  FMT_CONSTEXPR void on_error(const char* message) {\n+    ErrorHandler::on_error(message);\n+  }\n+\n+  FMT_CONSTEXPR ErrorHandler error_handler() const { return *this; }\n+};\n+\n+using format_parse_context = basic_parse_context<char>;\n+using wformat_parse_context = basic_parse_context<wchar_t>;\n+\n+using parse_context FMT_DEPRECATED = basic_parse_context<char>;\n+using wparse_context FMT_DEPRECATED = basic_parse_context<wchar_t>;\n+\n+template <typename Context> class basic_format_arg;\n+template <typename Context> class basic_format_args;\n \n // A formatter for objects of type T.\n template <typename T, typename Char = char, typename Enable = void>\n struct formatter {\n-  static_assert(internal::no_formatter_error<T>::value,\n-    \"don't know how to format the type, include fmt/ostream.h if it provides \"\n-    \"an operator<< that should be used\");\n-\n-  // The following functions are not defined intentionally.\n-  template <typename ParseContext>\n-  typename ParseContext::iterator parse(ParseContext &);\n-  template <typename FormatContext>\n-  auto format(const T &val, FormatContext &ctx) -> decltype(ctx.out());\n+  // A deleted default constructor indicates a disabled formatter.\n+  formatter() = delete;\n };\n \n template <typename T, typename Char, typename Enable = void>\n-struct convert_to_int: std::integral_constant<\n-  bool, !std::is_arithmetic<T>::value && std::is_convertible<T, int>::value> {};\n+struct FMT_DEPRECATED convert_to_int\n+    : bool_constant<!std::is_arithmetic<T>::value &&\n+                    std::is_convertible<T, int>::value> {};\n \n namespace internal {\n \n-struct dummy_string_view { typedef void char_type; };\n-dummy_string_view to_string_view(...);\n-using fmt::v5::to_string_view;\n+// Specifies if T has an enabled formatter specialization. A type can be\n+// formattable even if it doesn't have a formatter e.g. via a conversion.\n+template <typename T, typename Context>\n+using has_formatter =\n+    std::is_constructible<typename Context::template formatter_type<T>>;\n \n-// Specifies whether S is a string type convertible to fmt::basic_string_view.\n-template <typename S>\n-struct is_string : std::integral_constant<bool, !std::is_same<\n-    dummy_string_view, decltype(to_string_view(declval<S>()))>::value> {};\n+/** A contiguous memory buffer with an optional growing ability. */\n+template <typename T> class buffer {\n+ private:\n+  buffer(const buffer&) = delete;\n+  void operator=(const buffer&) = delete;\n \n-template <typename S>\n-struct char_t {\n-  typedef decltype(to_string_view(declval<S>())) result;\n-  typedef typename result::char_type type;\n+  T* ptr_;\n+  std::size_t size_;\n+  std::size_t capacity_;\n+\n+ protected:\n+  // Don't initialize ptr_ since it is not accessed to save a few cycles.\n+  buffer(std::size_t sz) FMT_NOEXCEPT : size_(sz), capacity_(sz) {}\n+\n+  buffer(T* p = nullptr, std::size_t sz = 0, std::size_t cap = 0) FMT_NOEXCEPT\n+      : ptr_(p),\n+        size_(sz),\n+        capacity_(cap) {}\n+\n+  /** Sets the buffer data and capacity. */\n+  void set(T* buf_data, std::size_t buf_capacity) FMT_NOEXCEPT {\n+    ptr_ = buf_data;\n+    capacity_ = buf_capacity;\n+  }\n+\n+  /** Increases the buffer capacity to hold at least *capacity* elements. */\n+  virtual void grow(std::size_t capacity) = 0;\n+\n+ public:\n+  using value_type = T;\n+  using const_reference = const T&;\n+\n+  virtual ~buffer() {}\n+\n+  T* begin() FMT_NOEXCEPT { return ptr_; }\n+  T* end() FMT_NOEXCEPT { return ptr_ + size_; }\n+\n+  /** Returns the size of this buffer. */\n+  std::size_t size() const FMT_NOEXCEPT { return size_; }\n+\n+  /** Returns the capacity of this buffer. */\n+  std::size_t capacity() const FMT_NOEXCEPT { return capacity_; }\n+\n+  /** Returns a pointer to the buffer data. */\n+  T* data() FMT_NOEXCEPT { return ptr_; }\n+\n+  /** Returns a pointer to the buffer data. */\n+  const T* data() const FMT_NOEXCEPT { return ptr_; }\n+\n+  /**\n+    Resizes the buffer. If T is a POD type new elements may not be initialized.\n+   */\n+  void resize(std::size_t new_size) {\n+    reserve(new_size);\n+    size_ = new_size;\n+  }\n+\n+  /** Clears this buffer. */\n+  void clear() { size_ = 0; }\n+\n+  /** Reserves space to store at least *capacity* elements. */\n+  void reserve(std::size_t new_capacity) {\n+    if (new_capacity > capacity_) grow(new_capacity);\n+  }\n+\n+  void push_back(const T& value) {\n+    reserve(size_ + 1);\n+    ptr_[size_++] = value;\n+  }\n+\n+  /** Appends data to the end of the buffer. */\n+  template <typename U> void append(const U* begin, const U* end);\n+\n+  T& operator[](std::size_t index) { return ptr_[index]; }\n+  const T& operator[](std::size_t index) const { return ptr_[index]; }\n };\n \n-template <typename Char>\n-struct named_arg_base;\n+// A container-backed buffer.\n+template <typename Container>\n+class container_buffer : public buffer<typename Container::value_type> {\n+ private:\n+  Container& container_;\n \n-template <typename T, typename Char>\n-struct named_arg;\n+ protected:\n+  void grow(std::size_t capacity) FMT_OVERRIDE {\n+    container_.resize(capacity);\n+    this->set(&container_[0], capacity);\n+  }\n+\n+ public:\n+  explicit container_buffer(Container& c)\n+      : buffer<typename Container::value_type>(c.size()), container_(c) {}\n+};\n+\n+// Extracts a reference to the container from back_insert_iterator.\n+template <typename Container>\n+inline Container& get_container(std::back_insert_iterator<Container> it) {\n+  using bi_iterator = std::back_insert_iterator<Container>;\n+  struct accessor : bi_iterator {\n+    accessor(bi_iterator iter) : bi_iterator(iter) {}\n+    using bi_iterator::container;\n+  };\n+  return *accessor(it).container;\n+}\n+\n+template <typename T, typename Char = char, typename Enable = void>\n+struct fallback_formatter {\n+  fallback_formatter() = delete;\n+};\n+\n+// Specifies if T has an enabled fallback_formatter specialization.\n+template <typename T, typename Context>\n+using has_fallback_formatter =\n+    std::is_constructible<fallback_formatter<T, typename Context::char_type>>;\n+\n+template <typename Char> struct named_arg_base;\n+template <typename T, typename Char> struct named_arg;\n \n enum type {\n-  none_type, named_arg_type,\n+  none_type,\n+  named_arg_type,\n   // Integer types should go first,\n-  int_type, uint_type, long_long_type, ulong_long_type, bool_type, char_type,\n+  int_type,\n+  uint_type,\n+  long_long_type,\n+  ulong_long_type,\n+  bool_type,\n+  char_type,\n   last_integer_type = char_type,\n   // followed by floating-point types.\n-  double_type, long_double_type, last_numeric_type = long_double_type,\n-  cstring_type, string_type, pointer_type, custom_type\n+  double_type,\n+  long_double_type,\n+  last_numeric_type = long_double_type,\n+  cstring_type,\n+  string_type,\n+  pointer_type,\n+  custom_type\n };\n \n+// Maps core type T to the corresponding type enum constant.\n+template <typename T, typename Char>\n+struct type_constant : std::integral_constant<type, custom_type> {};\n+\n+#define FMT_TYPE_CONSTANT(Type, constant) \\\n+  template <typename Char>                \\\n+  struct type_constant<Type, Char> : std::integral_constant<type, constant> {}\n+\n+FMT_TYPE_CONSTANT(const named_arg_base<Char>&, named_arg_type);\n+FMT_TYPE_CONSTANT(int, int_type);\n+FMT_TYPE_CONSTANT(unsigned, uint_type);\n+FMT_TYPE_CONSTANT(long long, long_long_type);\n+FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);\n+FMT_TYPE_CONSTANT(bool, bool_type);\n+FMT_TYPE_CONSTANT(Char, char_type);\n+FMT_TYPE_CONSTANT(double, double_type);\n+FMT_TYPE_CONSTANT(long double, long_double_type);\n+FMT_TYPE_CONSTANT(const Char*, cstring_type);\n+FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);\n+FMT_TYPE_CONSTANT(const void*, pointer_type);\n+\n FMT_CONSTEXPR bool is_integral(type t) {\n-  FMT_ASSERT(t != internal::named_arg_type, \"invalid argument type\");\n-  return t > internal::none_type && t <= internal::last_integer_type;\n+  FMT_ASSERT(t != named_arg_type, \"invalid argument type\");\n+  return t > none_type && t <= last_integer_type;\n }\n \n FMT_CONSTEXPR bool is_arithmetic(type t) {\n-  FMT_ASSERT(t != internal::named_arg_type, \"invalid argument type\");\n-  return t > internal::none_type && t <= internal::last_numeric_type;\n+  FMT_ASSERT(t != named_arg_type, \"invalid argument type\");\n+  return t > none_type && t <= last_numeric_type;\n }\n \n-template <typename Char>\n-struct string_value {\n-  const Char *value;\n+template <typename Char> struct string_value {\n+  const Char* data;\n   std::size_t size;\n };\n \n-template <typename Context>\n-struct custom_value {\n-  const void *value;\n-  void (*format)(const void *arg, Context &ctx);\n+template <typename Context> struct custom_value {\n+  using parse_context = basic_parse_context<typename Context::char_type>;\n+  const void* value;\n+  void (*format)(const void* arg, parse_context& parse_ctx, Context& ctx);\n };\n \n // A formatting argument value.\n-template <typename Context>\n-class value {\n+template <typename Context> class value {\n  public:\n-  typedef typename Context::char_type char_type;\n+  using char_type = typename Context::char_type;\n \n   union {\n     int int_value;\n     unsigned uint_value;\n     long long long_long_value;\n     unsigned long long ulong_long_value;\n+    bool bool_value;\n+    char_type char_value;\n     double double_value;\n     long double long_double_value;\n-    const void *pointer;\n+    const void* pointer;\n     string_value<char_type> string;\n-    string_value<signed char> sstring;\n-    string_value<unsigned char> ustring;\n     custom_value<Context> custom;\n+    const named_arg_base<char_type>* named_arg;\n   };\n \n   FMT_CONSTEXPR value(int val = 0) : int_value(val) {}\n-  value(unsigned val) { uint_value = val; }\n-  value(long long val) { long_long_value = val; }\n-  value(unsigned long long val) { ulong_long_value = val; }\n-  value(double val) { double_value = val; }\n-  value(long double val) { long_double_value = val; }\n-  value(const char_type *val) { string.value = val; }\n-  value(const signed char *val) {\n-    static_assert(std::is_same<char, char_type>::value,\n-                  \"incompatible string types\");\n-    sstring.value = val;\n-  }\n-  value(const unsigned char *val) {\n-    static_assert(std::is_same<char, char_type>::value,\n-                  \"incompatible string types\");\n-    ustring.value = val;\n-  }\n+  FMT_CONSTEXPR value(unsigned val) : uint_value(val) {}\n+  value(long long val) : long_long_value(val) {}\n+  value(unsigned long long val) : ulong_long_value(val) {}\n+  value(double val) : double_value(val) {}\n+  value(long double val) : long_double_value(val) {}\n+  value(bool val) : bool_value(val) {}\n+  value(char_type val) : char_value(val) {}\n+  value(const char_type* val) { string.data = val; }\n   value(basic_string_view<char_type> val) {\n-    string.value = val.data();\n+    string.data = val.data();\n     string.size = val.size();\n   }\n-  value(const void *val) { pointer = val; }\n+  value(const void* val) : pointer(val) {}\n \n-  template <typename T>\n-  explicit value(const T &val) {\n+  template <typename T> value(const T& val) {\n     custom.value = &val;\n-    custom.format = &format_custom_arg<T>;\n+    // Get the formatter type through the context to allow different contexts\n+    // have different extension points, e.g. `formatter<T>` for `format` and\n+    // `printf_formatter<T>` for `printf`.\n+    custom.format = format_custom_arg<\n+        T, conditional_t<has_formatter<T, Context>::value,\n+                         typename Context::template formatter_type<T>,\n+                         fallback_formatter<T, char_type>>>;\n   }\n \n-  const named_arg_base<char_type> &as_named_arg() {\n-    return *static_cast<const named_arg_base<char_type>*>(pointer);\n-  }\n+  value(const named_arg_base<char_type>& val) { named_arg = &val; }\n \n  private:\n   // Formats an argument of a custom type, such as a user-defined class.\n-  template <typename T>\n-  static void format_custom_arg(const void *arg, Context &ctx) {\n-    // Get the formatter type through the context to allow different contexts\n-    // have different extension points, e.g. `formatter<T>` for `format` and\n-    // `printf_formatter<T>` for `printf`.\n-    typename Context::template formatter_type<T>::type f;\n-    auto &&parse_ctx = ctx.parse_context();\n+  template <typename T, typename Formatter>\n+  static void format_custom_arg(const void* arg,\n+                                basic_parse_context<char_type>& parse_ctx,\n+                                Context& ctx) {\n+    Formatter f;\n     parse_ctx.advance_to(f.parse(parse_ctx));\n     ctx.advance_to(f.format(*static_cast<const T*>(arg), ctx));\n   }\n };\n \n-// Value initializer used to delay conversion to value and reduce memory churn.\n-template <typename Context, typename T, type TYPE>\n-struct init {\n-  T val;\n-  static const type type_tag = TYPE;\n-\n-  FMT_CONSTEXPR init(const T &v) : val(v) {}\n-  FMT_CONSTEXPR operator value<Context>() const { return value<Context>(val); }\n-};\n-\n template <typename Context, typename T>\n-FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T &value);\n+FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T& value);\n \n-#define FMT_MAKE_VALUE(TAG, ArgType, ValueType) \\\n-  template <typename C> \\\n-  FMT_CONSTEXPR init<C, ValueType, TAG> make_value(ArgType val) { \\\n-    return static_cast<ValueType>(val); \\\n+// To minimize the number of types we need to deal with, long is translated\n+// either to int or to long long depending on its size.\n+enum { long_short = sizeof(long) == sizeof(int) };\n+using long_type = conditional_t<long_short, int, long long>;\n+using ulong_type = conditional_t<long_short, unsigned, unsigned long long>;\n+\n+// Maps formatting arguments to core types.\n+template <typename Context> struct arg_mapper {\n+  using char_type = typename Context::char_type;\n+\n+  FMT_CONSTEXPR int map(signed char val) { return val; }\n+  FMT_CONSTEXPR unsigned map(unsigned char val) { return val; }\n+  FMT_CONSTEXPR int map(short val) { return val; }\n+  FMT_CONSTEXPR unsigned map(unsigned short val) { return val; }\n+  FMT_CONSTEXPR int map(int val) { return val; }\n+  FMT_CONSTEXPR unsigned map(unsigned val) { return val; }\n+  FMT_CONSTEXPR long_type map(long val) { return val; }\n+  FMT_CONSTEXPR ulong_type map(unsigned long val) { return val; }\n+  FMT_CONSTEXPR long long map(long long val) { return val; }\n+  FMT_CONSTEXPR unsigned long long map(unsigned long long val) { return val; }\n+  FMT_CONSTEXPR bool map(bool val) { return val; }\n+\n+  template <typename T, FMT_ENABLE_IF(is_char<T>::value)>\n+  FMT_CONSTEXPR char_type map(T val) {\n+    static_assert(\n+        std::is_same<T, char>::value || std::is_same<T, char_type>::value,\n+        \"mixing character types is disallowed\");\n+    return val;\n   }\n \n-#define FMT_MAKE_VALUE_SAME(TAG, Type) \\\n-  template <typename C> \\\n-  FMT_CONSTEXPR init<C, Type, TAG> make_value(Type val) { return val; }\n-\n-FMT_MAKE_VALUE(bool_type, bool, int)\n-FMT_MAKE_VALUE(int_type, short, int)\n-FMT_MAKE_VALUE(uint_type, unsigned short, unsigned)\n-FMT_MAKE_VALUE_SAME(int_type, int)\n-FMT_MAKE_VALUE_SAME(uint_type, unsigned)\n+  FMT_CONSTEXPR double map(float val) { return static_cast<double>(val); }\n+  FMT_CONSTEXPR double map(double val) { return val; }\n+  FMT_CONSTEXPR long double map(long double val) { return val; }\n+\n+  FMT_CONSTEXPR const char_type* map(char_type* val) { return val; }\n+  FMT_CONSTEXPR const char_type* map(const char_type* val) { return val; }\n+  template <typename T, FMT_ENABLE_IF(is_string<T>::value)>\n+  FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {\n+    static_assert(std::is_same<char_type, char_t<T>>::value,\n+                  \"mixing character types is disallowed\");\n+    return to_string_view(val);\n+  }\n+  template <typename T,\n+            FMT_ENABLE_IF(\n+                std::is_constructible<basic_string_view<char_type>, T>::value &&\n+                !is_string<T>::value)>\n+  FMT_CONSTEXPR basic_string_view<char_type> map(const T& val) {\n+    return basic_string_view<char_type>(val);\n+  }\n+  FMT_CONSTEXPR const char* map(const signed char* val) {\n+    static_assert(std::is_same<char_type, char>::value, \"invalid string type\");\n+    return reinterpret_cast<const char*>(val);\n+  }\n+  FMT_CONSTEXPR const char* map(const unsigned char* val) {\n+    static_assert(std::is_same<char_type, char>::value, \"invalid string type\");\n+    return reinterpret_cast<const char*>(val);\n+  }\n \n-// To minimize the number of types we need to deal with, long is translated\n-// either to int or to long long depending on its size.\n-typedef std::conditional<sizeof(long) == sizeof(int), int, long long>::type\n-        long_type;\n-FMT_MAKE_VALUE(\n-    (sizeof(long) == sizeof(int) ? int_type : long_long_type), long, long_type)\n-typedef std::conditional<sizeof(unsigned long) == sizeof(unsigned),\n-                         unsigned, unsigned long long>::type ulong_type;\n-FMT_MAKE_VALUE(\n-    (sizeof(unsigned long) == sizeof(unsigned) ? uint_type : ulong_long_type),\n-    unsigned long, ulong_type)\n-\n-FMT_MAKE_VALUE_SAME(long_long_type, long long)\n-FMT_MAKE_VALUE_SAME(ulong_long_type, unsigned long long)\n-FMT_MAKE_VALUE(int_type, signed char, int)\n-FMT_MAKE_VALUE(uint_type, unsigned char, unsigned)\n-\n-// This doesn't use FMT_MAKE_VALUE because of ambiguity in gcc 4.4.\n-template <typename C, typename Char>\n-FMT_CONSTEXPR typename std::enable_if<\n-  std::is_same<typename C::char_type, Char>::value,\n-  init<C, int, char_type>>::type make_value(Char val) { return val; }\n-\n-template <typename C>\n-FMT_CONSTEXPR typename std::enable_if<\n-  !std::is_same<typename C::char_type, char>::value,\n-  init<C, int, char_type>>::type make_value(char val) { return val; }\n-\n-FMT_MAKE_VALUE(double_type, float, double)\n-FMT_MAKE_VALUE_SAME(double_type, double)\n-FMT_MAKE_VALUE_SAME(long_double_type, long double)\n-\n-// Formatting of wide strings into a narrow buffer and multibyte strings\n-// into a wide buffer is disallowed (https://github.com/fmtlib/fmt/pull/606).\n-FMT_MAKE_VALUE(cstring_type, typename C::char_type*,\n-               const typename C::char_type*)\n-FMT_MAKE_VALUE(cstring_type, const typename C::char_type*,\n-               const typename C::char_type*)\n-\n-FMT_MAKE_VALUE(cstring_type, signed char*, const signed char*)\n-FMT_MAKE_VALUE_SAME(cstring_type, const signed char*)\n-FMT_MAKE_VALUE(cstring_type, unsigned char*, const unsigned char*)\n-FMT_MAKE_VALUE_SAME(cstring_type, const unsigned char*)\n-FMT_MAKE_VALUE_SAME(string_type, basic_string_view<typename C::char_type>)\n-FMT_MAKE_VALUE(string_type,\n-               typename basic_string_view<typename C::char_type>::type,\n-               basic_string_view<typename C::char_type>)\n-FMT_MAKE_VALUE(string_type, const std::basic_string<typename C::char_type>&,\n-               basic_string_view<typename C::char_type>)\n-FMT_MAKE_VALUE(pointer_type, void*, const void*)\n-FMT_MAKE_VALUE_SAME(pointer_type, const void*)\n-\n-#if FMT_USE_NULLPTR\n-FMT_MAKE_VALUE(pointer_type, std::nullptr_t, const void*)\n-#endif\n+  FMT_CONSTEXPR const void* map(void* val) { return val; }\n+  FMT_CONSTEXPR const void* map(const void* val) { return val; }\n+  FMT_CONSTEXPR const void* map(std::nullptr_t val) { return val; }\n+  template <typename T> FMT_CONSTEXPR int map(const T*) {\n+    // Formatting of arbitrary pointers is disallowed. If you want to output\n+    // a pointer cast it to \"void *\" or \"const void *\". In particular, this\n+    // forbids formatting of \"[const] volatile char *\" which is printed as bool\n+    // by iostreams.\n+    static_assert(!sizeof(T), \"formatting of non-void pointers is disallowed\");\n+    return 0;\n+  }\n \n-// Formatting of arbitrary pointers is disallowed. If you want to output a\n-// pointer cast it to \"void *\" or \"const void *\". In particular, this forbids\n-// formatting of \"[const] volatile char *\" which is printed as bool by\n-// iostreams.\n-template <typename C, typename T>\n-typename std::enable_if<!std::is_same<T, typename C::char_type>::value>::type\n-    make_value(const T *) {\n-  static_assert(!sizeof(T), \"formatting of non-void pointers is disallowed\");\n-}\n+  template <typename T,\n+            FMT_ENABLE_IF(std::is_enum<T>::value &&\n+                          !has_formatter<T, Context>::value &&\n+                          !has_fallback_formatter<T, Context>::value)>\n+  FMT_CONSTEXPR int map(const T& val) {\n+    return static_cast<int>(val);\n+  }\n+  template <typename T,\n+            FMT_ENABLE_IF(!is_string<T>::value && !is_char<T>::value &&\n+                          (has_formatter<T, Context>::value ||\n+                           has_fallback_formatter<T, Context>::value))>\n+  FMT_CONSTEXPR const T& map(const T& val) {\n+    return val;\n+  }\n \n-template <typename C, typename T>\n-inline typename std::enable_if<\n-    std::is_enum<T>::value && convert_to_int<T, typename C::char_type>::value,\n-    init<C, int, int_type>>::type\n-  make_value(const T &val) { return static_cast<int>(val); }\n-\n-template <typename C, typename T, typename Char = typename C::char_type>\n-inline typename std::enable_if<\n-    is_constructible<basic_string_view<Char>, T>::value &&\n-    !internal::is_string<T>::value,\n-    init<C, basic_string_view<Char>, string_type>>::type\n-  make_value(const T &val) { return basic_string_view<Char>(val); }\n-\n-template <typename C, typename T, typename Char = typename C::char_type>\n-inline typename std::enable_if<\n-    !convert_to_int<T, Char>::value && !std::is_same<T, Char>::value &&\n-    !std::is_convertible<T, basic_string_view<Char>>::value &&\n-    !is_constructible<basic_string_view<Char>, T>::value &&\n-    !internal::is_string<T>::value,\n-    // Implicit conversion to std::string is not handled here because it's\n-    // unsafe: https://github.com/fmtlib/fmt/issues/729\n-    init<C, const T &, custom_type>>::type\n-  make_value(const T &val) { return val; }\n-\n-template <typename C, typename T>\n-init<C, const void*, named_arg_type>\n-    make_value(const named_arg<T, typename C::char_type> &val) {\n-  basic_format_arg<C> arg = make_arg<C>(val.value);\n-  std::memcpy(val.data, &arg, sizeof(arg));\n-  return static_cast<const void*>(&val);\n-}\n+  template <typename T>\n+  FMT_CONSTEXPR const named_arg_base<char_type>& map(\n+      const named_arg<T, char_type>& val) {\n+    auto arg = make_arg<Context>(val.value);\n+    std::memcpy(val.data, &arg, sizeof(arg));\n+    return val;\n+  }\n+};\n \n-template <typename C, typename S>\n-FMT_CONSTEXPR11 typename std::enable_if<\n-  internal::is_string<S>::value,\n-  init<C, basic_string_view<typename C::char_type>, string_type>>::type\n-    make_value(const S &val) {\n-  // Handle adapted strings.\n-  static_assert(std::is_same<\n-    typename C::char_type, typename internal::char_t<S>::type>::value,\n-    \"mismatch between char-types of context and argument\");\n-  return to_string_view(val);\n-}\n+// A type constant after applying arg_mapper<Context>.\n+template <typename T, typename Context>\n+using mapped_type_constant =\n+    type_constant<decltype(arg_mapper<Context>().map(std::declval<T>())),\n+                  typename Context::char_type>;\n \n // Maximum number of arguments with packed types.\n enum { max_packed_args = 15 };\n enum : unsigned long long { is_unpacked_bit = 1ull << 63 };\n \n-template <typename Context>\n-class arg_map;\n+template <typename Context> class arg_map;\n }  // namespace internal\n \n // A formatting argument. It is a trivially copyable/constructible type to\n // allow storage in basic_memory_buffer.\n-template <typename Context>\n-class basic_format_arg {\n+template <typename Context> class basic_format_arg {\n  private:\n   internal::value<Context> value_;\n   internal::type type_;\n \n   template <typename ContextType, typename T>\n-  friend FMT_CONSTEXPR basic_format_arg<ContextType>\n-    internal::make_arg(const T &value);\n+  friend FMT_CONSTEXPR basic_format_arg<ContextType> internal::make_arg(\n+      const T& value);\n \n   template <typename Visitor, typename Ctx>\n-  friend FMT_CONSTEXPR typename internal::result_of<Visitor(int)>::type\n-    visit_format_arg(Visitor &&vis, const basic_format_arg<Ctx> &arg);\n+  friend FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,\n+                                             const basic_format_arg<Ctx>& arg)\n+      -> decltype(vis(0));\n \n   friend class basic_format_args<Context>;\n   friend class internal::arg_map<Context>;\n \n-  typedef typename Context::char_type char_type;\n+  using char_type = typename Context::char_type;\n \n  public:\n   class handle {\n    public:\n-    explicit handle(internal::custom_value<Context> custom): custom_(custom) {}\n+    explicit handle(internal::custom_value<Context> custom) : custom_(custom) {}\n \n-    void format(Context &ctx) const { custom_.format(custom_.value, ctx); }\n+    void format(basic_parse_context<char_type>& parse_ctx, Context& ctx) const {\n+      custom_.format(custom_.value, parse_ctx, ctx);\n+    }\n \n    private:\n     internal::custom_value<Context> custom_;\n@@ -807,7 +887,7 @@ class basic_format_arg {\n \n   FMT_CONSTEXPR basic_format_arg() : type_(internal::none_type) {}\n \n-  FMT_EXPLICIT operator bool() const FMT_NOEXCEPT {\n+  FMT_CONSTEXPR explicit operator bool() const FMT_NOEXCEPT {\n     return type_ != internal::none_type;\n   }\n \n@@ -817,8 +897,6 @@ class basic_format_arg {\n   bool is_arithmetic() const { return internal::is_arithmetic(type_); }\n };\n \n-struct monostate {};\n-\n /**\n   \\rst\n   Visits an argument dispatching to the appropriate visit method based on\n@@ -827,9 +905,10 @@ struct monostate {};\n   \\endrst\n  */\n template <typename Visitor, typename Context>\n-FMT_CONSTEXPR typename internal::result_of<Visitor(int)>::type\n-    visit_format_arg(Visitor &&vis, const basic_format_arg<Context> &arg) {\n-  typedef typename Context::char_type char_type;\n+FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,\n+                                    const basic_format_arg<Context>& arg)\n+    -> decltype(vis(0)) {\n+  using char_type = typename Context::char_type;\n   switch (arg.type_) {\n   case internal::none_type:\n     break;\n@@ -845,18 +924,18 @@ FMT_CONSTEXPR typename internal::result_of<Visitor(int)>::type\n   case internal::ulong_long_type:\n     return vis(arg.value_.ulong_long_value);\n   case internal::bool_type:\n-    return vis(arg.value_.int_value != 0);\n+    return vis(arg.value_.bool_value);\n   case internal::char_type:\n-    return vis(static_cast<char_type>(arg.value_.int_value));\n+    return vis(arg.value_.char_value);\n   case internal::double_type:\n     return vis(arg.value_.double_value);\n   case internal::long_double_type:\n     return vis(arg.value_.long_double_value);\n   case internal::cstring_type:\n-    return vis(arg.value_.string.value);\n+    return vis(arg.value_.string.data);\n   case internal::string_type:\n-    return vis(basic_string_view<char_type>(\n-                 arg.value_.string.value, arg.value_.string.size));\n+    return vis(basic_string_view<char_type>(arg.value_.string.data,\n+                                            arg.value_.string.size));\n   case internal::pointer_type:\n     return vis(arg.value_.pointer);\n   case internal::custom_type:\n@@ -865,104 +944,38 @@ FMT_CONSTEXPR typename internal::result_of<Visitor(int)>::type\n   return vis(monostate());\n }\n \n-// DEPRECATED!\n-template <typename Visitor, typename Context>\n-FMT_CONSTEXPR typename internal::result_of<Visitor(int)>::type\n-    visit(Visitor &&vis, const basic_format_arg<Context> &arg) {\n-  return visit_format_arg(std::forward<Visitor>(vis), arg);\n-}\n-\n-// Parsing context consisting of a format string range being parsed and an\n-// argument counter for automatic indexing.\n-template <typename Char, typename ErrorHandler = internal::error_handler>\n-class basic_parse_context : private ErrorHandler {\n- private:\n-  basic_string_view<Char> format_str_;\n-  int next_arg_id_;\n-\n- public:\n-  typedef Char char_type;\n-  typedef typename basic_string_view<Char>::iterator iterator;\n-\n-  explicit FMT_CONSTEXPR basic_parse_context(\n-      basic_string_view<Char> format_str, ErrorHandler eh = ErrorHandler())\n-    : ErrorHandler(eh), format_str_(format_str), next_arg_id_(0) {}\n-\n-  // Returns an iterator to the beginning of the format string range being\n-  // parsed.\n-  FMT_CONSTEXPR iterator begin() const FMT_NOEXCEPT {\n-    return format_str_.begin();\n-  }\n-\n-  // Returns an iterator past the end of the format string range being parsed.\n-  FMT_CONSTEXPR iterator end() const FMT_NOEXCEPT { return format_str_.end(); }\n-\n-  // Advances the begin iterator to ``it``.\n-  FMT_CONSTEXPR void advance_to(iterator it) {\n-    format_str_.remove_prefix(internal::to_unsigned(it - begin()));\n-  }\n-\n-  // Returns the next argument index.\n-  FMT_CONSTEXPR unsigned next_arg_id();\n-\n-  FMT_CONSTEXPR bool check_arg_id(unsigned) {\n-    if (next_arg_id_ > 0) {\n-      on_error(\"cannot switch from automatic to manual argument indexing\");\n-      return false;\n-    }\n-    next_arg_id_ = -1;\n-    return true;\n-  }\n-  void check_arg_id(basic_string_view<Char>) {}\n-\n-  FMT_CONSTEXPR void on_error(const char *message) {\n-    ErrorHandler::on_error(message);\n-  }\n-\n-  FMT_CONSTEXPR ErrorHandler error_handler() const { return *this; }\n-};\n-\n-typedef basic_parse_context<char> format_parse_context;\n-typedef basic_parse_context<wchar_t> wformat_parse_context;\n-\n-// DEPRECATED!\n-typedef basic_parse_context<char> parse_context;\n-typedef basic_parse_context<wchar_t> wparse_context;\n-\n namespace internal {\n // A map from argument names to their values for named arguments.\n-template <typename Context>\n-class arg_map {\n+template <typename Context> class arg_map {\n  private:\n-  arg_map(const arg_map &) = delete;\n-  void operator=(const arg_map &) = delete;\n+  arg_map(const arg_map&) = delete;\n+  void operator=(const arg_map&) = delete;\n \n-  typedef typename Context::char_type char_type;\n+  using char_type = typename Context::char_type;\n \n   struct entry {\n     basic_string_view<char_type> name;\n     basic_format_arg<Context> arg;\n   };\n \n-  entry *map_;\n+  entry* map_;\n   unsigned size_;\n \n   void push_back(value<Context> val) {\n-    const internal::named_arg_base<char_type> &named = val.as_named_arg();\n-    map_[size_] = entry{named.name, named.template deserialize<Context>()};\n+    const auto& named = *val.named_arg;\n+    map_[size_] = {named.name, named.template deserialize<Context>()};\n     ++size_;\n   }\n \n  public:\n-  arg_map() : map_(FMT_NULL), size_(0) {}\n-  void init(const basic_format_args<Context> &args);\n-  ~arg_map() { delete [] map_; }\n+  arg_map() : map_(nullptr), size_(0) {}\n+  void init(const basic_format_args<Context>& args);\n+  ~arg_map() { delete[] map_; }\n \n   basic_format_arg<Context> find(basic_string_view<char_type> name) const {\n     // The list is unsorted, so just return the first matching name.\n     for (entry *it = map_, *end = map_ + size_; it != end; ++it) {\n-      if (it->name == name)\n-        return it->arg;\n+      if (it->name == name) return it->arg;\n     }\n     return {};\n   }\n@@ -971,163 +984,97 @@ class arg_map {\n // A type-erased reference to an std::locale to avoid heavy <locale> include.\n class locale_ref {\n  private:\n-  const void *locale_;  // A type-erased pointer to std::locale.\n-  friend class locale;\n-\n- public:\n-  locale_ref() : locale_(FMT_NULL) {}\n-\n-  template <typename Locale>\n-  explicit locale_ref(const Locale &loc);\n-\n-  template <typename Locale>\n-  Locale get() const;\n-};\n-\n-template <typename OutputIt, typename Context, typename Char>\n-class context_base {\n- public:\n-  typedef OutputIt iterator;\n-\n- private:\n-  basic_parse_context<Char> parse_context_;\n-  iterator out_;\n-  basic_format_args<Context> args_;\n-  locale_ref loc_;\n-\n- protected:\n-  typedef Char char_type;\n-  typedef basic_format_arg<Context> format_arg;\n-\n-  context_base(OutputIt out, basic_string_view<char_type> format_str,\n-               basic_format_args<Context> ctx_args,\n-               locale_ref loc = locale_ref())\n-  : parse_context_(format_str), out_(out), args_(ctx_args), loc_(loc) {}\n-\n-  // Returns the argument with specified index.\n-  format_arg do_get_arg(unsigned arg_id) {\n-    format_arg arg = args_.get(arg_id);\n-    if (!arg)\n-      parse_context_.on_error(\"argument index out of range\");\n-    return arg;\n-  }\n-\n-  // Checks if manual indexing is used and returns the argument with\n-  // specified index.\n-  format_arg get_arg(unsigned arg_id) {\n-    return this->parse_context().check_arg_id(arg_id) ?\n-      this->do_get_arg(arg_id) : format_arg();\n-  }\n+  const void* locale_;  // A type-erased pointer to std::locale.\n \n  public:\n-  basic_parse_context<char_type> &parse_context() { return parse_context_; }\n-  basic_format_args<Context> args() const { return args_; } // DEPRECATED!\n-  basic_format_arg<Context> arg(unsigned id) const { return args_.get(id); }\n-\n-  internal::error_handler error_handler() {\n-    return parse_context_.error_handler();\n-  }\n-\n-  void on_error(const char *message) { parse_context_.on_error(message); }\n-\n-  // Returns an iterator to the beginning of the output range.\n-  iterator out() { return out_; }\n-  iterator begin() { return out_; }  // deprecated\n-\n-  // Advances the begin iterator to ``it``.\n-  void advance_to(iterator it) { out_ = it; }\n-\n-  locale_ref locale() { return loc_; }\n-};\n+  locale_ref() : locale_(nullptr) {}\n+  template <typename Locale> explicit locale_ref(const Locale& loc);\n \n-template <typename Context, typename T>\n-struct get_type {\n-  typedef decltype(make_value<Context>(\n-        declval<typename std::decay<T>::type&>())) value_type;\n-  static const type value = value_type::type_tag;\n+  template <typename Locale> Locale get() const;\n };\n \n-template <typename Context>\n-FMT_CONSTEXPR11 unsigned long long get_types() { return 0; }\n+template <typename> constexpr unsigned long long encode_types() { return 0; }\n \n template <typename Context, typename Arg, typename... Args>\n-FMT_CONSTEXPR11 unsigned long long get_types() {\n-  return get_type<Context, Arg>::value | (get_types<Context, Args...>() << 4);\n+constexpr unsigned long long encode_types() {\n+  return mapped_type_constant<Arg, Context>::value |\n+         (encode_types<Context, Args...>() << 4);\n }\n \n template <typename Context, typename T>\n-FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T &value) {\n+FMT_CONSTEXPR basic_format_arg<Context> make_arg(const T& value) {\n   basic_format_arg<Context> arg;\n-  arg.type_ = get_type<Context, T>::value;\n-  arg.value_ = make_value<Context>(value);\n+  arg.type_ = mapped_type_constant<T, Context>::value;\n+  arg.value_ = arg_mapper<Context>().map(value);\n   return arg;\n }\n \n-template <bool IS_PACKED, typename Context, typename T>\n-inline typename std::enable_if<IS_PACKED, value<Context>>::type\n-    make_arg(const T &value) {\n-  return make_value<Context>(value);\n+template <bool IS_PACKED, typename Context, typename T,\n+          FMT_ENABLE_IF(IS_PACKED)>\n+inline value<Context> make_arg(const T& val) {\n+  return arg_mapper<Context>().map(val);\n }\n \n-template <bool IS_PACKED, typename Context, typename T>\n-inline typename std::enable_if<!IS_PACKED, basic_format_arg<Context>>::type\n-    make_arg(const T &value) {\n+template <bool IS_PACKED, typename Context, typename T,\n+          FMT_ENABLE_IF(!IS_PACKED)>\n+inline basic_format_arg<Context> make_arg(const T& value) {\n   return make_arg<Context>(value);\n }\n }  // namespace internal\n \n // Formatting context.\n-template <typename OutputIt, typename Char>\n-class basic_format_context :\n-  public internal::context_base<\n-    OutputIt, basic_format_context<OutputIt, Char>, Char> {\n+template <typename OutputIt, typename Char> class basic_format_context {\n  public:\n   /** The character type for the output. */\n-  typedef Char char_type;\n-\n-  // using formatter_type = formatter<T, char_type>;\n-  template <typename T>\n-  struct formatter_type { typedef formatter<T, char_type> type; };\n+  using char_type = Char;\n \n  private:\n+  OutputIt out_;\n+  basic_format_args<basic_format_context> args_;\n   internal::arg_map<basic_format_context> map_;\n+  internal::locale_ref loc_;\n \n-  basic_format_context(const basic_format_context &) = delete;\n-  void operator=(const basic_format_context &) = delete;\n-\n-  typedef internal::context_base<OutputIt, basic_format_context, Char> base;\n-  typedef typename base::format_arg format_arg;\n-  using base::get_arg;\n+  basic_format_context(const basic_format_context&) = delete;\n+  void operator=(const basic_format_context&) = delete;\n \n  public:\n-  using typename base::iterator;\n+  using iterator = OutputIt;\n+  using format_arg = basic_format_arg<basic_format_context>;\n+  template <typename T> using formatter_type = formatter<T, char_type>;\n \n   /**\n    Constructs a ``basic_format_context`` object. References to the arguments are\n    stored in the object so make sure they have appropriate lifetimes.\n    */\n-  basic_format_context(OutputIt out, basic_string_view<char_type> format_str,\n+  basic_format_context(OutputIt out,\n                        basic_format_args<basic_format_context> ctx_args,\n                        internal::locale_ref loc = internal::locale_ref())\n-    : base(out, format_str, ctx_args, loc) {}\n+      : out_(out), args_(ctx_args), loc_(loc) {}\n \n-  format_arg next_arg() {\n-    return this->do_get_arg(this->parse_context().next_arg_id());\n-  }\n-  format_arg get_arg(unsigned arg_id) { return this->do_get_arg(arg_id); }\n+  format_arg arg(int id) const { return args_.get(id); }\n \n   // Checks if manual indexing is used and returns the argument with the\n   // specified name.\n-  format_arg get_arg(basic_string_view<char_type> name);\n+  format_arg arg(basic_string_view<char_type> name);\n+\n+  internal::error_handler error_handler() { return {}; }\n+  void on_error(const char* message) { error_handler().on_error(message); }\n+\n+  // Returns an iterator to the beginning of the output range.\n+  iterator out() { return out_; }\n+\n+  // Advances the begin iterator to ``it``.\n+  void advance_to(iterator it) { out_ = it; }\n+\n+  internal::locale_ref locale() { return loc_; }\n };\n \n template <typename Char>\n-struct buffer_context {\n-  typedef basic_format_context<\n-    std::back_insert_iterator<internal::basic_buffer<Char>>, Char> type;\n-};\n-typedef buffer_context<char>::type format_context;\n-typedef buffer_context<wchar_t>::type wformat_context;\n+using buffer_context =\n+    basic_format_context<std::back_insert_iterator<internal::buffer<Char>>,\n+                         Char>;\n+using format_context = buffer_context<char>;\n+using wformat_context = buffer_context<wchar_t>;\n \n /**\n   \\rst\n@@ -1136,74 +1083,48 @@ typedef buffer_context<wchar_t>::type wformat_context;\n   such as `~fmt::vformat`.\n   \\endrst\n  */\n-template <typename Context, typename ...Args>\n-class format_arg_store {\n+template <typename Context, typename... Args> class format_arg_store {\n  private:\n-  static const size_t NUM_ARGS = sizeof...(Args);\n+  static const size_t num_args = sizeof...(Args);\n+  static const bool is_packed = num_args < internal::max_packed_args;\n \n-  // Packed is a macro on MinGW so use IS_PACKED instead.\n-  static const bool IS_PACKED = NUM_ARGS < internal::max_packed_args;\n-\n-  typedef typename std::conditional<IS_PACKED,\n-    internal::value<Context>, basic_format_arg<Context>>::type value_type;\n+  using value_type = conditional_t<is_packed, internal::value<Context>,\n+                                   basic_format_arg<Context>>;\n \n   // If the arguments are not packed, add one more element to mark the end.\n-  static const size_t DATA_SIZE =\n-          NUM_ARGS + (IS_PACKED && NUM_ARGS != 0 ? 0 : 1);\n-  value_type data_[DATA_SIZE];\n+  value_type data_[num_args + (num_args == 0 ? 1 : 0)];\n \n   friend class basic_format_args<Context>;\n \n-  static FMT_CONSTEXPR11 unsigned long long get_types() {\n-    return IS_PACKED ?\n-      internal::get_types<Context, Args...>() :\n-      internal::is_unpacked_bit | NUM_ARGS;\n-  }\n-\n  public:\n-#if FMT_USE_CONSTEXPR11\n-  static FMT_CONSTEXPR11 unsigned long long TYPES = get_types();\n-#else\n-  static const unsigned long long TYPES;\n-#endif\n+  static constexpr unsigned long long types =\n+      is_packed ? internal::encode_types<Context, Args...>()\n+                : internal::is_unpacked_bit | num_args;\n+  FMT_DEPRECATED static constexpr unsigned long long TYPES = types;\n \n-#if (FMT_GCC_VERSION && FMT_GCC_VERSION <= 405) || \\\n-    (FMT_MSC_VER && FMT_MSC_VER <= 1800)\n-  // Workaround array initialization issues in gcc <= 4.5 and MSVC <= 2013.\n-  format_arg_store(const Args &... args) {\n-    value_type init[DATA_SIZE] =\n-      {internal::make_arg<IS_PACKED, Context>(args)...};\n-    std::memcpy(data_, init, sizeof(init));\n-  }\n-#else\n-  format_arg_store(const Args &... args)\n-    : data_{internal::make_arg<IS_PACKED, Context>(args)...} {}\n-#endif\n+  format_arg_store(const Args&... args)\n+      : data_{internal::make_arg<is_packed, Context>(args)...} {}\n };\n \n-#if !FMT_USE_CONSTEXPR11\n-template <typename Context, typename ...Args>\n-const unsigned long long format_arg_store<Context, Args...>::TYPES =\n-    get_types();\n-#endif\n-\n /**\n   \\rst\n   Constructs an `~fmt::format_arg_store` object that contains references to\n   arguments and can be implicitly converted to `~fmt::format_args`. `Context`\n   can be omitted in which case it defaults to `~fmt::context`.\n+  See `~fmt::arg` for lifetime considerations.\n   \\endrst\n  */\n-template <typename Context = format_context, typename ...Args>\n-inline format_arg_store<Context, Args...>\n-  make_format_args(const Args &... args) { return {args...}; }\n+template <typename Context = format_context, typename... Args>\n+inline format_arg_store<Context, Args...> make_format_args(\n+    const Args&... args) {\n+  return {args...};\n+}\n \n /** Formatting arguments. */\n-template <typename Context>\n-class basic_format_args {\n+template <typename Context> class basic_format_args {\n  public:\n-  typedef unsigned size_type;\n-  typedef basic_format_arg<Context>  format_arg;\n+  using size_type = int;\n+  using format_arg = basic_format_arg<Context>;\n \n  private:\n   // To reduce compiled code size per formatting function call, types of first\n@@ -1215,37 +1136,33 @@ class basic_format_args {\n     // This is done to reduce compiled code size as storing larger objects\n     // may require more code (at least on x86-64) even if the same amount of\n     // data is actually copied to stack. It saves ~10% on the bloat test.\n-    const internal::value<Context> *values_;\n-    const format_arg *args_;\n+    const internal::value<Context>* values_;\n+    const format_arg* args_;\n   };\n \n   bool is_packed() const { return (types_ & internal::is_unpacked_bit) == 0; }\n \n-  typename internal::type type(unsigned index) const {\n-    unsigned shift = index * 4;\n-    return static_cast<typename internal::type>(\n-      (types_ & (0xfull << shift)) >> shift);\n+  internal::type type(int index) const {\n+    int shift = index * 4;\n+    return static_cast<internal::type>((types_ & (0xfull << shift)) >> shift);\n   }\n \n   friend class internal::arg_map<Context>;\n \n-  void set_data(const internal::value<Context> *values) { values_ = values; }\n-  void set_data(const format_arg *args) { args_ = args; }\n+  void set_data(const internal::value<Context>* values) { values_ = values; }\n+  void set_data(const format_arg* args) { args_ = args; }\n \n-  format_arg do_get(size_type index) const {\n+  format_arg do_get(int index) const {\n     format_arg arg;\n     if (!is_packed()) {\n       auto num_args = max_size();\n-      if (index < num_args)\n-        arg = args_[index];\n+      if (index < num_args) arg = args_[index];\n       return arg;\n     }\n-    if (index > internal::max_packed_args)\n-      return arg;\n+    if (index > internal::max_packed_args) return arg;\n     arg.type_ = type(index);\n-    if (arg.type_ == internal::none_type)\n-      return arg;\n-    internal::value<Context> &val = arg.value_;\n+    if (arg.type_ == internal::none_type) return arg;\n+    internal::value<Context>& val = arg.value_;\n     val = values_[index];\n     return arg;\n   }\n@@ -1259,8 +1176,8 @@ class basic_format_args {\n    \\endrst\n    */\n   template <typename... Args>\n-  basic_format_args(const format_arg_store<Context, Args...> &store)\n-  : types_(static_cast<unsigned long long>(store.TYPES)) {\n+  basic_format_args(const format_arg_store<Context, Args...>& store)\n+      : types_(static_cast<unsigned long long>(store.types)) {\n     set_data(store.data_);\n   }\n \n@@ -1269,131 +1186,133 @@ class basic_format_args {\n    Constructs a `basic_format_args` object from a dynamic set of arguments.\n    \\endrst\n    */\n-  basic_format_args(const format_arg *args, size_type count)\n-    : types_(internal::is_unpacked_bit | count) {\n+  basic_format_args(const format_arg* args, int count)\n+      : types_(internal::is_unpacked_bit | internal::to_unsigned(count)) {\n     set_data(args);\n   }\n \n   /** Returns the argument at specified index. */\n-  format_arg get(size_type index) const {\n+  format_arg get(int index) const {\n     format_arg arg = do_get(index);\n     if (arg.type_ == internal::named_arg_type)\n-      arg = arg.value_.as_named_arg().template deserialize<Context>();\n+      arg = arg.value_.named_arg->template deserialize<Context>();\n     return arg;\n   }\n \n-  size_type max_size() const {\n+  int max_size() const {\n     unsigned long long max_packed = internal::max_packed_args;\n-    return static_cast<size_type>(\n-      is_packed() ? max_packed : types_ & ~internal::is_unpacked_bit);\n+    return static_cast<int>(is_packed() ? max_packed\n+                                        : types_ & ~internal::is_unpacked_bit);\n   }\n };\n \n /** An alias to ``basic_format_args<context>``. */\n-// It is a separate type rather than a typedef to make symbols readable.\n+// It is a separate type rather than an alias to make symbols readable.\n struct format_args : basic_format_args<format_context> {\n-  template <typename ...Args>\n-  format_args(Args &&... arg)\n-  : basic_format_args<format_context>(std::forward<Args>(arg)...) {}\n+  template <typename... Args>\n+  format_args(Args&&... args)\n+      : basic_format_args<format_context>(std::forward<Args>(args)...) {}\n };\n struct wformat_args : basic_format_args<wformat_context> {\n-  template <typename ...Args>\n-  wformat_args(Args &&... arg)\n-  : basic_format_args<wformat_context>(std::forward<Args>(arg)...) {}\n+  template <typename... Args>\n+  wformat_args(Args&&... args)\n+      : basic_format_args<wformat_context>(std::forward<Args>(args)...) {}\n };\n \n-#define FMT_ENABLE_IF_T(B, T) typename std::enable_if<B, T>::type\n+template <typename Container> struct is_contiguous : std::false_type {};\n \n-#ifndef FMT_USE_ALIAS_TEMPLATES\n-# define FMT_USE_ALIAS_TEMPLATES FMT_HAS_FEATURE(cxx_alias_templates)\n-#endif\n-#if FMT_USE_ALIAS_TEMPLATES\n-/** String's character type. */\n-template <typename S>\n-using char_t = FMT_ENABLE_IF_T(\n-  internal::is_string<S>::value, typename internal::char_t<S>::type);\n-#define FMT_CHAR(S) fmt::char_t<S>\n-#else\n-template <typename S>\n-struct char_t : std::enable_if<\n-    internal::is_string<S>::value, typename internal::char_t<S>::type> {};\n-#define FMT_CHAR(S) typename char_t<S>::type\n-#endif\n+template <typename Char>\n+struct is_contiguous<std::basic_string<Char>> : std::true_type {};\n \n-namespace internal {\n template <typename Char>\n-struct named_arg_base {\n+struct is_contiguous<internal::buffer<Char>> : std::true_type {};\n+\n+namespace internal {\n+\n+template <typename OutputIt>\n+struct is_contiguous_back_insert_iterator : std::false_type {};\n+template <typename Container>\n+struct is_contiguous_back_insert_iterator<std::back_insert_iterator<Container>>\n+    : is_contiguous<Container> {};\n+\n+template <typename Char> struct named_arg_base {\n   basic_string_view<Char> name;\n \n   // Serialized value<context>.\n-  mutable char data[\n-    sizeof(basic_format_arg<typename buffer_context<Char>::type>)];\n+  mutable char data[sizeof(basic_format_arg<buffer_context<Char>>)];\n \n   named_arg_base(basic_string_view<Char> nm) : name(nm) {}\n \n-  template <typename Context>\n-  basic_format_arg<Context> deserialize() const {\n+  template <typename Context> basic_format_arg<Context> deserialize() const {\n     basic_format_arg<Context> arg;\n     std::memcpy(&arg, data, sizeof(basic_format_arg<Context>));\n     return arg;\n   }\n };\n \n-template <typename T, typename Char>\n-struct named_arg : named_arg_base<Char> {\n-  const T &value;\n+template <typename T, typename Char> struct named_arg : named_arg_base<Char> {\n+  const T& value;\n \n-  named_arg(basic_string_view<Char> name, const T &val)\n-    : named_arg_base<Char>(name), value(val) {}\n+  named_arg(basic_string_view<Char> name, const T& val)\n+      : named_arg_base<Char>(name), value(val) {}\n };\n \n-template <typename... Args, typename S>\n-inline typename std::enable_if<!is_compile_string<S>::value>::type\n-  check_format_string(const S &) {}\n-template <typename... Args, typename S>\n-typename std::enable_if<is_compile_string<S>::value>::type\n-  check_format_string(S);\n-\n-template <typename S, typename... Args>\n-struct checked_args : format_arg_store<\n-  typename buffer_context<FMT_CHAR(S)>::type, Args...> {\n-  typedef typename buffer_context<FMT_CHAR(S)>::type context;\n-\n-  checked_args(const S &format_str, const Args &... args):\n-    format_arg_store<context, Args...>(args...) {\n-    internal::check_format_string<Args...>(format_str);\n-  }\n-\n-  basic_format_args<context> operator*() const { return *this; }\n-};\n+template <typename..., typename S, FMT_ENABLE_IF(!is_compile_string<S>::value)>\n+inline void check_format_string(const S&) {\n+#if defined(FMT_ENFORCE_COMPILE_STRING)\n+  static_assert(is_compile_string<S>::value,\n+                \"FMT_ENFORCE_COMPILE_STRING requires all format strings to \"\n+                \"utilize FMT_STRING() or fmt().\");\n+#endif\n+}\n+template <typename..., typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>\n+void check_format_string(S);\n+\n+struct view {};\n+template <bool...> struct bool_pack;\n+template <bool... Args>\n+using all_true =\n+    std::is_same<bool_pack<Args..., true>, bool_pack<true, Args...>>;\n+\n+template <typename... Args, typename S, typename Char = char_t<S>>\n+inline format_arg_store<buffer_context<Char>, remove_reference_t<Args>...>\n+make_args_checked(const S& format_str,\n+                  const remove_reference_t<Args>&... args) {\n+  static_assert(all_true<(!std::is_base_of<view, remove_reference_t<Args>>() ||\n+                          !std::is_reference<Args>())...>::value,\n+                \"passing views as lvalues is disallowed\");\n+  check_format_string<remove_const_t<remove_reference_t<Args>>...>(format_str);\n+  return {args...};\n+}\n \n template <typename Char>\n-std::basic_string<Char> vformat(\n-  basic_string_view<Char> format_str,\n-  basic_format_args<typename buffer_context<Char>::type> args);\n+std::basic_string<Char> vformat(basic_string_view<Char> format_str,\n+                                basic_format_args<buffer_context<Char>> args);\n \n template <typename Char>\n-typename buffer_context<Char>::type::iterator vformat_to(\n-  internal::basic_buffer<Char> &buf, basic_string_view<Char> format_str,\n-  basic_format_args<typename buffer_context<Char>::type> args);\n-}\n+typename buffer_context<Char>::iterator vformat_to(\n+    buffer<Char>& buf, basic_string_view<Char> format_str,\n+    basic_format_args<buffer_context<Char>> args);\n+}  // namespace internal\n \n /**\n   \\rst\n   Returns a named argument to be used in a formatting function.\n \n+  The named argument holds a reference and does not extend the lifetime\n+  of its arguments.\n+  Consequently, a dangling reference can accidentally be created.\n+  The user should take care to only pass this function temporaries when\n+  the named argument is itself a temporary, as per the following example.\n+\n   **Example**::\n \n     fmt::print(\"Elapsed time: {s:.2f} seconds\", fmt::arg(\"s\", 1.23));\n   \\endrst\n  */\n-template <typename T>\n-inline internal::named_arg<T, char> arg(string_view name, const T &arg) {\n-  return {name, arg};\n-}\n-\n-template <typename T>\n-inline internal::named_arg<T, wchar_t> arg(wstring_view name, const T &arg) {\n+template <typename S, typename T, typename Char = char_t<S>>\n+inline internal::named_arg<T, Char> arg(const S& name, const T& arg) {\n+  static_assert(internal::is_string<S>::value, \"\");\n   return {name, arg};\n }\n \n@@ -1401,42 +1320,34 @@ inline internal::named_arg<T, wchar_t> arg(wstring_view name, const T &arg) {\n template <typename S, typename T, typename Char>\n void arg(S, internal::named_arg<T, Char>) = delete;\n \n-template <typename Container>\n-struct is_contiguous: std::false_type {};\n-\n-template <typename Char>\n-struct is_contiguous<std::basic_string<Char> >: std::true_type {};\n-\n-template <typename Char>\n-struct is_contiguous<internal::basic_buffer<Char> >: std::true_type {};\n-\n /** Formats a string and writes the output to ``out``. */\n-template <typename Container, typename S>\n-typename std::enable_if<\n-    is_contiguous<Container>::value, std::back_insert_iterator<Container>>::type\n-  vformat_to(\n-    std::back_insert_iterator<Container> out,\n-    const S &format_str,\n-    basic_format_args<typename buffer_context<FMT_CHAR(S)>::type> args) {\n-  internal::container_buffer<Container> buf(internal::get_container(out));\n+// GCC 8 and earlier cannot handle std::back_insert_iterator<Container> with\n+// vformat_to<ArgFormatter>(...) overload, so SFINAE on iterator type instead.\n+template <typename OutputIt, typename S, typename Char = char_t<S>,\n+          FMT_ENABLE_IF(\n+              internal::is_contiguous_back_insert_iterator<OutputIt>::value)>\n+OutputIt vformat_to(OutputIt out, const S& format_str,\n+                    basic_format_args<buffer_context<Char>> args) {\n+  using container = remove_reference_t<decltype(internal::get_container(out))>;\n+  internal::container_buffer<container> buf((internal::get_container(out)));\n   internal::vformat_to(buf, to_string_view(format_str), args);\n   return out;\n }\n \n-template <typename Container, typename S, typename... Args>\n-inline typename std::enable_if<\n-  is_contiguous<Container>::value && internal::is_string<S>::value,\n-  std::back_insert_iterator<Container>>::type\n-    format_to(std::back_insert_iterator<Container> out, const S &format_str,\n-              const Args &... args) {\n-  internal::checked_args<S, Args...> ca(format_str, args...);\n-  return vformat_to(out, to_string_view(format_str), *ca);\n+template <typename Container, typename S, typename... Args,\n+          FMT_ENABLE_IF(\n+              is_contiguous<Container>::value&& internal::is_string<S>::value)>\n+inline std::back_insert_iterator<Container> format_to(\n+    std::back_insert_iterator<Container> out, const S& format_str,\n+    Args&&... args) {\n+  return vformat_to(\n+      out, to_string_view(format_str),\n+      {internal::make_args_checked<Args...>(format_str, args...)});\n }\n \n-template <typename S, typename Char = FMT_CHAR(S)>\n+template <typename S, typename Char = char_t<S>>\n inline std::basic_string<Char> vformat(\n-    const S &format_str,\n-    basic_format_args<typename buffer_context<Char>::type> args) {\n+    const S& format_str, basic_format_args<buffer_context<Char>> args) {\n   return internal::vformat(to_string_view(format_str), args);\n }\n \n@@ -1450,16 +1361,17 @@ inline std::basic_string<Char> vformat(\n     std::string message = fmt::format(\"The answer is {}\", 42);\n   \\endrst\n */\n-template <typename S, typename... Args>\n-inline std::basic_string<FMT_CHAR(S)> format(\n-    const S &format_str, const Args &... args) {\n+// Pass char_t as a default template parameter instead of using\n+// std::basic_string<char_t<S>> to reduce the symbol size.\n+template <typename S, typename... Args, typename Char = char_t<S>>\n+inline std::basic_string<Char> format(const S& format_str, Args&&... args) {\n   return internal::vformat(\n-    to_string_view(format_str),\n-    *internal::checked_args<S, Args...>(format_str, args...));\n+      to_string_view(format_str),\n+      {internal::make_args_checked<Args...>(format_str, args...)});\n }\n \n-FMT_API void vprint(std::FILE *f, string_view format_str, format_args args);\n-FMT_API void vprint(std::FILE *f, wstring_view format_str, wformat_args args);\n+FMT_API void vprint(std::FILE* f, string_view format_str, format_args args);\n+FMT_API void vprint(std::FILE* f, wstring_view format_str, wformat_args args);\n \n /**\n   \\rst\n@@ -1472,11 +1384,11 @@ FMT_API void vprint(std::FILE *f, wstring_view format_str, wformat_args args);\n     fmt::print(stderr, \"Don't {}!\", \"panic\");\n   \\endrst\n  */\n-template <typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(internal::is_string<S>::value, void)\n-    print(std::FILE *f, const S &format_str, const Args &... args) {\n+template <typename S, typename... Args,\n+          FMT_ENABLE_IF(internal::is_string<S>::value)>\n+inline void print(std::FILE* f, const S& format_str, Args&&... args) {\n   vprint(f, to_string_view(format_str),\n-         internal::checked_args<S, Args...>(format_str, args...));\n+         internal::make_args_checked<Args...>(format_str, args...));\n }\n \n FMT_API void vprint(string_view format_str, format_args args);\n@@ -1491,11 +1403,11 @@ FMT_API void vprint(wstring_view format_str, wformat_args args);\n     fmt::print(\"Elapsed time: {0:.2f} seconds\", 1.23);\n   \\endrst\n  */\n-template <typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(internal::is_string<S>::value, void)\n-    print(const S &format_str, const Args &... args) {\n+template <typename S, typename... Args,\n+          FMT_ENABLE_IF(internal::is_string<S>::value)>\n+inline void print(const S& format_str, Args&&... args) {\n   vprint(to_string_view(format_str),\n-         internal::checked_args<S, Args...>(format_str, args...));\n+         internal::make_args_checked<Args...>(format_str, args...));\n }\n FMT_END_NAMESPACE\n \ndiff --git a/include/spdlog/fmt/bundled/format-inl.h b/include/spdlog/fmt/bundled/format-inl.h\n--- a/include/spdlog/fmt/bundled/format-inl.h\n+++ b/include/spdlog/fmt/bundled/format-inl.h\n@@ -19,73 +19,67 @@\n #include <cstdarg>\n #include <cstddef>  // for std::ptrdiff_t\n #include <cstring>  // for std::memmove\n+#include <cwchar>\n #if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)\n-# include <locale>\n+#  include <locale>\n #endif\n \n #if FMT_USE_WINDOWS_H\n-# if !defined(FMT_HEADER_ONLY) && !defined(WIN32_LEAN_AND_MEAN)\n-#  define WIN32_LEAN_AND_MEAN\n-# endif\n-# if defined(NOMINMAX) || defined(FMT_WIN_MINMAX)\n-#  include <windows.h>\n-# else\n-#  define NOMINMAX\n-#  include <windows.h>\n-#  undef NOMINMAX\n-# endif\n+#  if !defined(FMT_HEADER_ONLY) && !defined(WIN32_LEAN_AND_MEAN)\n+#    define WIN32_LEAN_AND_MEAN\n+#  endif\n+#  if defined(NOMINMAX) || defined(FMT_WIN_MINMAX)\n+#    include <windows.h>\n+#  else\n+#    define NOMINMAX\n+#    include <windows.h>\n+#    undef NOMINMAX\n+#  endif\n #endif\n \n #if FMT_EXCEPTIONS\n-# define FMT_TRY try\n-# define FMT_CATCH(x) catch (x)\n+#  define FMT_TRY try\n+#  define FMT_CATCH(x) catch (x)\n #else\n-# define FMT_TRY if (true)\n-# define FMT_CATCH(x) if (false)\n+#  define FMT_TRY if (true)\n+#  define FMT_CATCH(x) if (false)\n #endif\n \n #ifdef _MSC_VER\n-# pragma warning(push)\n-# pragma warning(disable: 4127)  // conditional expression is constant\n-# pragma warning(disable: 4702)  // unreachable code\n+#  pragma warning(push)\n+#  pragma warning(disable : 4127)  // conditional expression is constant\n+#  pragma warning(disable : 4702)  // unreachable code\n // Disable deprecation warning for strerror. The latter is not called but\n // MSVC fails to detect it.\n-# pragma warning(disable: 4996)\n+#  pragma warning(disable : 4996)\n #endif\n \n // Dummy implementations of strerror_r and strerror_s called if corresponding\n // system functions are not available.\n-inline fmt::internal::null<> strerror_r(int, char *, ...) {\n+inline fmt::internal::null<> strerror_r(int, char*, ...) {\n   return fmt::internal::null<>();\n }\n-inline fmt::internal::null<> strerror_s(char *, std::size_t, ...) {\n+inline fmt::internal::null<> strerror_s(char*, std::size_t, ...) {\n   return fmt::internal::null<>();\n }\n \n FMT_BEGIN_NAMESPACE\n-\n-namespace {\n+namespace internal {\n \n #ifndef _MSC_VER\n-# define FMT_SNPRINTF snprintf\n+#  define FMT_SNPRINTF snprintf\n #else  // _MSC_VER\n-inline int fmt_snprintf(char *buffer, size_t size, const char *format, ...) {\n+inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {\n   va_list args;\n   va_start(args, format);\n   int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);\n   va_end(args);\n   return result;\n }\n-# define FMT_SNPRINTF fmt_snprintf\n+#  define FMT_SNPRINTF fmt_snprintf\n #endif  // _MSC_VER\n \n-#if defined(_WIN32) && defined(__MINGW32__) && !defined(__NO_ISOCEXT)\n-# define FMT_SWPRINTF snwprintf\n-#else\n-# define FMT_SWPRINTF swprintf\n-#endif // defined(_WIN32) && defined(__MINGW32__) && !defined(__NO_ISOCEXT)\n-\n-typedef void (*FormatFunc)(internal::buffer &, int, string_view);\n+using format_func = void (*)(internal::buffer<char>&, int, string_view);\n \n // Portable thread-safe version of strerror.\n // Sets buffer to point to a string describing the error code.\n@@ -96,18 +90,18 @@ typedef void (*FormatFunc)(internal::buffer &, int, string_view);\n //   ERANGE - buffer is not large enough to store the error message\n //   other  - failure\n // Buffer should be at least of size 1.\n-int safe_strerror(\n-    int error_code, char *&buffer, std::size_t buffer_size) FMT_NOEXCEPT {\n-  FMT_ASSERT(buffer != FMT_NULL && buffer_size != 0, \"invalid buffer\");\n+FMT_FUNC int safe_strerror(int error_code, char*& buffer,\n+                           std::size_t buffer_size) FMT_NOEXCEPT {\n+  FMT_ASSERT(buffer != nullptr && buffer_size != 0, \"invalid buffer\");\n \n   class dispatcher {\n    private:\n     int error_code_;\n-    char *&buffer_;\n+    char*& buffer_;\n     std::size_t buffer_size_;\n \n     // A noop assignment operator to avoid bogus warnings.\n-    void operator=(const dispatcher &) {}\n+    void operator=(const dispatcher&) {}\n \n     // Handle the result of XSI-compliant version of strerror_r.\n     int handle(int result) {\n@@ -116,7 +110,7 @@ int safe_strerror(\n     }\n \n     // Handle the result of GNU-specific version of strerror_r.\n-    int handle(char *message) {\n+    int handle(char* message) {\n       // If the buffer is full then the message is probably truncated.\n       if (message == buffer_ && strlen(buffer_) == buffer_size_ - 1)\n         return ERANGE;\n@@ -132,8 +126,8 @@ int safe_strerror(\n     // Fallback to strerror_s when strerror_r is not available.\n     int fallback(int result) {\n       // If the buffer is full then the message is probably truncated.\n-      return result == 0 && strlen(buffer_) == buffer_size_ - 1 ?\n-            ERANGE : result;\n+      return result == 0 && strlen(buffer_) == buffer_size_ - 1 ? ERANGE\n+                                                                : result;\n     }\n \n #if !FMT_MSC_VER\n@@ -146,18 +140,16 @@ int safe_strerror(\n #endif\n \n    public:\n-    dispatcher(int err_code, char *&buf, std::size_t buf_size)\n-      : error_code_(err_code), buffer_(buf), buffer_size_(buf_size) {}\n+    dispatcher(int err_code, char*& buf, std::size_t buf_size)\n+        : error_code_(err_code), buffer_(buf), buffer_size_(buf_size) {}\n \n-    int run() {\n-      return handle(strerror_r(error_code_, buffer_, buffer_size_));\n-    }\n+    int run() { return handle(strerror_r(error_code_, buffer_, buffer_size_)); }\n   };\n   return dispatcher(error_code, buffer, buffer_size).run();\n }\n \n-void format_error_code(internal::buffer &out, int error_code,\n-                       string_view message) FMT_NOEXCEPT {\n+FMT_FUNC void format_error_code(internal::buffer<char>& out, int error_code,\n+                                string_view message) FMT_NOEXCEPT {\n   // Report error code making sure that the output fits into\n   // inline_buffer_size to avoid dynamic memory allocation and potential\n   // bad_alloc.\n@@ -166,14 +158,13 @@ void format_error_code(internal::buffer &out, int error_code,\n   static const char ERROR_STR[] = \"error \";\n   // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.\n   std::size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;\n-  typedef internal::int_traits<int>::main_type main_type;\n-  main_type abs_value = static_cast<main_type>(error_code);\n+  auto abs_value = static_cast<uint32_or_64_t<int>>(error_code);\n   if (internal::is_negative(error_code)) {\n     abs_value = 0 - abs_value;\n     ++error_code_size;\n   }\n   error_code_size += internal::to_unsigned(internal::count_digits(abs_value));\n-  writer w(out);\n+  internal::writer w(out);\n   if (message.size() <= inline_buffer_size - error_code_size) {\n     w.write(message);\n     w.write(SEP);\n@@ -183,206 +174,214 @@ void format_error_code(internal::buffer &out, int error_code,\n   assert(out.size() <= inline_buffer_size);\n }\n \n-void report_error(FormatFunc func, int error_code,\n-                  string_view message) FMT_NOEXCEPT {\n+// A wrapper around fwrite that throws on error.\n+FMT_FUNC void fwrite_fully(const void* ptr, size_t size, size_t count,\n+                           FILE* stream) {\n+  size_t written = std::fwrite(ptr, size, count, stream);\n+  if (written < count) {\n+    FMT_THROW(system_error(errno, \"cannot write to file\"));\n+  }\n+}\n+\n+FMT_FUNC void report_error(format_func func, int error_code,\n+                           string_view message) FMT_NOEXCEPT {\n   memory_buffer full_message;\n   func(full_message, error_code, message);\n-  // Use Writer::data instead of Writer::c_str to avoid potential memory\n-  // allocation.\n-  std::fwrite(full_message.data(), full_message.size(), 1, stderr);\n+  // Don't use fwrite_fully because the latter may throw.\n+  (void)std::fwrite(full_message.data(), full_message.size(), 1, stderr);\n   std::fputc('\\n', stderr);\n }\n-}  // namespace\n-\n-FMT_FUNC size_t internal::count_code_points(basic_string_view<char8_t> s) {\n-  const char8_t *data = s.data();\n-  size_t num_code_points = 0;\n-  for (size_t i = 0, size = s.size(); i != size; ++i) {\n-    if ((data[i] & 0xc0) != 0x80)\n-      ++num_code_points;\n-  }\n-  return num_code_points;\n-}\n+}  // namespace internal\n \n #if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)\n namespace internal {\n \n template <typename Locale>\n-locale_ref::locale_ref(const Locale &loc) : locale_(&loc) {\n+locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {\n   static_assert(std::is_same<Locale, std::locale>::value, \"\");\n }\n \n-template <typename Locale>\n-Locale locale_ref::get() const {\n+template <typename Locale> Locale locale_ref::get() const {\n   static_assert(std::is_same<Locale, std::locale>::value, \"\");\n   return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();\n }\n \n-template <typename Char>\n-FMT_FUNC Char thousands_sep_impl(locale_ref loc) {\n-  return std::use_facet<std::numpunct<Char> >(\n-    loc.get<std::locale>()).thousands_sep();\n+template <typename Char> FMT_FUNC Char thousands_sep_impl(locale_ref loc) {\n+  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())\n+      .thousands_sep();\n }\n+template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {\n+  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())\n+      .decimal_point();\n }\n+}  // namespace internal\n #else\n template <typename Char>\n FMT_FUNC Char internal::thousands_sep_impl(locale_ref) {\n   return FMT_STATIC_THOUSANDS_SEPARATOR;\n }\n+template <typename Char>\n+FMT_FUNC Char internal::decimal_point_impl(locale_ref) {\n+  return '.';\n+}\n #endif\n \n-FMT_FUNC void system_error::init(\n-    int err_code, string_view format_str, format_args args) {\n+FMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT {}\n+FMT_API FMT_FUNC system_error::~system_error() FMT_NOEXCEPT {}\n+\n+FMT_FUNC void system_error::init(int err_code, string_view format_str,\n+                                 format_args args) {\n   error_code_ = err_code;\n   memory_buffer buffer;\n   format_system_error(buffer, err_code, vformat(format_str, args));\n-  std::runtime_error &base = *this;\n+  std::runtime_error& base = *this;\n   base = std::runtime_error(to_string(buffer));\n }\n \n namespace internal {\n-template <typename T>\n-int char_traits<char>::format_float(\n-    char *buf, std::size_t size, const char *format, int precision, T value) {\n-  return precision < 0 ?\n-      FMT_SNPRINTF(buf, size, format, value) :\n-      FMT_SNPRINTF(buf, size, format, precision, value);\n+\n+template <> FMT_FUNC int count_digits<4>(internal::fallback_uintptr n) {\n+  // Assume little endian; pointer formatting is implementation-defined anyway.\n+  int i = static_cast<int>(sizeof(void*)) - 1;\n+  while (i > 0 && n.value[i] == 0) --i;\n+  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;\n+  return i >= 0 ? i * char_digits + count_digits<4, unsigned>(n.value[i]) : 1;\n }\n \n template <typename T>\n-int char_traits<wchar_t>::format_float(\n-    wchar_t *buf, std::size_t size, const wchar_t *format, int precision,\n-    T value) {\n-  return precision < 0 ?\n-      FMT_SWPRINTF(buf, size, format, value) :\n-      FMT_SWPRINTF(buf, size, format, precision, value);\n+int format_float(char* buf, std::size_t size, const char* format, int precision,\n+                 T value) {\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+  if (precision > 100000)\n+    throw std::runtime_error(\n+        \"fuzz mode - avoid large allocation inside snprintf\");\n+#endif\n+  // Suppress the warning about nonliteral format string.\n+  auto snprintf_ptr = FMT_SNPRINTF;\n+  return precision < 0 ? snprintf_ptr(buf, size, format, value)\n+                       : snprintf_ptr(buf, size, format, precision, value);\n }\n \n template <typename T>\n-const char basic_data<T>::DIGITS[] =\n+const char basic_data<T>::digits[] =\n     \"0001020304050607080910111213141516171819\"\n     \"2021222324252627282930313233343536373839\"\n     \"4041424344454647484950515253545556575859\"\n     \"6061626364656667686970717273747576777879\"\n     \"8081828384858687888990919293949596979899\";\n \n-#define FMT_POWERS_OF_10(factor) \\\n-  factor * 10, \\\n-  factor * 100, \\\n-  factor * 1000, \\\n-  factor * 10000, \\\n-  factor * 100000, \\\n-  factor * 1000000, \\\n-  factor * 10000000, \\\n-  factor * 100000000, \\\n-  factor * 1000000000\n+template <typename T>\n+const char basic_data<T>::hex_digits[] = \"0123456789abcdef\";\n+\n+#define FMT_POWERS_OF_10(factor)                                             \\\n+  factor * 10, factor * 100, factor * 1000, factor * 10000, factor * 100000, \\\n+      factor * 1000000, factor * 10000000, factor * 100000000,               \\\n+      factor * 1000000000\n \n template <typename T>\n-const uint32_t basic_data<T>::POWERS_OF_10_32[] = {\n-  1, FMT_POWERS_OF_10(1)\n-};\n+const uint64_t basic_data<T>::powers_of_10_64[] = {\n+    1, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ull),\n+    10000000000000000000ull};\n \n template <typename T>\n-const uint32_t basic_data<T>::ZERO_OR_POWERS_OF_10_32[] = {\n-  0, FMT_POWERS_OF_10(1)\n-};\n+const uint32_t basic_data<T>::zero_or_powers_of_10_32[] = {0,\n+                                                           FMT_POWERS_OF_10(1)};\n \n template <typename T>\n-const uint64_t basic_data<T>::ZERO_OR_POWERS_OF_10_64[] = {\n-  0,\n-  FMT_POWERS_OF_10(1),\n-  FMT_POWERS_OF_10(1000000000ull),\n-  10000000000000000000ull\n-};\n+const uint64_t basic_data<T>::zero_or_powers_of_10_64[] = {\n+    0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ull),\n+    10000000000000000000ull};\n \n // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.\n // These are generated by support/compute-powers.py.\n template <typename T>\n-const uint64_t basic_data<T>::POW10_SIGNIFICANDS[] = {\n-  0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,\n-  0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,\n-  0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,\n-  0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,\n-  0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,\n-  0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,\n-  0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,\n-  0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,\n-  0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,\n-  0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,\n-  0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,\n-  0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,\n-  0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,\n-  0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,\n-  0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,\n-  0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,\n-  0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,\n-  0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,\n-  0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,\n-  0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,\n-  0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,\n-  0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,\n-  0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,\n-  0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,\n-  0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,\n-  0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,\n-  0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,\n-  0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,\n-  0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,\n+const uint64_t basic_data<T>::pow10_significands[] = {\n+    0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,\n+    0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,\n+    0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,\n+    0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,\n+    0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,\n+    0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,\n+    0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,\n+    0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,\n+    0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,\n+    0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,\n+    0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,\n+    0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,\n+    0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,\n+    0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,\n+    0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,\n+    0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,\n+    0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,\n+    0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,\n+    0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,\n+    0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,\n+    0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,\n+    0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,\n+    0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,\n+    0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,\n+    0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,\n+    0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,\n+    0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,\n+    0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,\n+    0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,\n };\n \n // Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding\n // to significands above.\n template <typename T>\n-const int16_t basic_data<T>::POW10_EXPONENTS[] = {\n-  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,  -954,\n-   -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688,  -661,\n-   -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396,  -369,\n-   -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103,   -77,\n-    -50,   -24,     3,    30,    56,    83,   109,   136,   162,   189,   216,\n-    242,   269,   295,   322,   348,   375,   402,   428,   455,   481,   508,\n-    534,   561,   588,   614,   641,   667,   694,   720,   747,   774,   800,\n-    827,   853,   880,   907,   933,   960,   986,  1013,  1039,  1066\n-};\n+const int16_t basic_data<T>::pow10_exponents[] = {\n+    -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,\n+    -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,\n+    -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,\n+    -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,\n+    -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,\n+    242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,\n+    534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,\n+    827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};\n \n-template <typename T> const char basic_data<T>::FOREGROUND_COLOR[] = \"\\x1b[38;2;\";\n-template <typename T> const char basic_data<T>::BACKGROUND_COLOR[] = \"\\x1b[48;2;\";\n-template <typename T> const char basic_data<T>::RESET_COLOR[] = \"\\x1b[0m\";\n-template <typename T> const wchar_t basic_data<T>::WRESET_COLOR[] = L\"\\x1b[0m\";\n+template <typename T>\n+const char basic_data<T>::foreground_color[] = \"\\x1b[38;2;\";\n+template <typename T>\n+const char basic_data<T>::background_color[] = \"\\x1b[48;2;\";\n+template <typename T> const char basic_data<T>::reset_color[] = \"\\x1b[0m\";\n+template <typename T> const wchar_t basic_data<T>::wreset_color[] = L\"\\x1b[0m\";\n+\n+template <typename T> struct bits {\n+  static FMT_CONSTEXPR_DECL const int value =\n+      static_cast<int>(sizeof(T) * std::numeric_limits<unsigned char>::digits);\n+};\n \n // A handmade floating-point number f * pow(2, e).\n class fp {\n  private:\n-  typedef uint64_t significand_type;\n+  using significand_type = uint64_t;\n \n   // All sizes are in bits.\n-  static FMT_CONSTEXPR_DECL const int char_size =\n-    std::numeric_limits<unsigned char>::digits;\n   // Subtract 1 to account for an implicit most significant bit in the\n   // normalized form.\n   static FMT_CONSTEXPR_DECL const int double_significand_size =\n-    std::numeric_limits<double>::digits - 1;\n+      std::numeric_limits<double>::digits - 1;\n   static FMT_CONSTEXPR_DECL const uint64_t implicit_bit =\n-    1ull << double_significand_size;\n+      1ull << double_significand_size;\n \n  public:\n   significand_type f;\n   int e;\n \n   static FMT_CONSTEXPR_DECL const int significand_size =\n-    sizeof(significand_type) * char_size;\n+      bits<significand_type>::value;\n \n-  fp(): f(0), e(0) {}\n-  fp(uint64_t f_val, int e_val): f(f_val), e(e_val) {}\n+  fp() : f(0), e(0) {}\n+  fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}\n \n   // Constructs fp from an IEEE754 double. It is a template to prevent compile\n   // errors on platforms where double is not IEEE754.\n-  template <typename Double>\n-  explicit fp(Double d) {\n+  template <typename Double> explicit fp(Double d) {\n     // Assume double is in the format [sign][exponent][significand].\n-    typedef std::numeric_limits<Double> limits;\n-    const int double_size = static_cast<int>(sizeof(Double) * char_size);\n+    using limits = std::numeric_limits<Double>;\n     const int exponent_size =\n-      double_size - double_significand_size - 1;  // -1 for sign\n+        bits<Double>::value - double_significand_size - 1;  // -1 for sign\n     const uint64_t significand_mask = implicit_bit - 1;\n     const uint64_t exponent_mask = (~0ull >> 1) & ~significand_mask;\n     const int exponent_bias = (1 << exponent_size) - limits::max_exponent - 1;\n@@ -397,8 +396,7 @@ class fp {\n   }\n \n   // Normalizes the value converted from double and multiplied by (1 << SHIFT).\n-  template <int SHIFT = 0>\n-  void normalize() {\n+  template <int SHIFT = 0> void normalize() {\n     // Handle subnormals.\n     auto shifted_implicit_bit = implicit_bit << SHIFT;\n     while ((f & shifted_implicit_bit) == 0) {\n@@ -415,9 +413,9 @@ class fp {\n   // a boundary is a value half way between the number and its predecessor\n   // (lower) or successor (upper). The upper boundary is normalized and lower\n   // has the same exponent but may be not normalized.\n-  void compute_boundaries(fp &lower, fp &upper) const {\n-    lower = f == implicit_bit ?\n-          fp((f << 2) - 1, e - 2) : fp((f << 1) - 1, e - 1);\n+  void compute_boundaries(fp& lower, fp& upper) const {\n+    lower =\n+        f == implicit_bit ? fp((f << 2) - 1, e - 2) : fp((f << 1) - 1, e - 1);\n     upper = fp((f << 1) + 1, e - 1);\n     upper.normalize<1>();  // 1 is to account for the exponent shift above.\n     lower.f <<= lower.e - upper.e;\n@@ -432,14 +430,16 @@ inline fp operator-(fp x, fp y) {\n }\n \n // Computes an fp number r with r.f = x.f * y.f / pow(2, 64) rounded to nearest\n-// with half-up tie breaking, r.e = x.e + y.e + 64. Result may not be normalized.\n-FMT_API fp operator*(fp x, fp y);\n-\n-// Returns cached power (of 10) c_k = c_k.f * pow(2, c_k.e) such that its\n-// (binary) exponent satisfies min_exponent <= c_k.e <= min_exponent + 3.\n-FMT_API fp get_cached_power(int min_exponent, int &pow10_exponent);\n-\n+// with half-up tie breaking, r.e = x.e + y.e + 64. Result may not be\n+// normalized.\n FMT_FUNC fp operator*(fp x, fp y) {\n+  int exp = x.e + y.e + 64;\n+#if FMT_USE_INT128\n+  auto product = static_cast<__uint128_t>(x.f) * y.f;\n+  auto f = static_cast<uint64_t>(product >> 64);\n+  if ((static_cast<uint64_t>(product) & (1ULL << 63)) != 0) ++f;\n+  return fp(f, exp);\n+#else\n   // Multiply 32-bit parts of significands.\n   uint64_t mask = (1ULL << 32) - 1;\n   uint64_t a = x.f >> 32, b = x.f & mask;\n@@ -447,351 +447,376 @@ FMT_FUNC fp operator*(fp x, fp y) {\n   uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;\n   // Compute mid 64-bit of result and round.\n   uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);\n-  return fp(ac + (ad >> 32) + (bc >> 32) + (mid >> 32), x.e + y.e + 64);\n+  return fp(ac + (ad >> 32) + (bc >> 32) + (mid >> 32), exp);\n+#endif\n }\n \n-FMT_FUNC fp get_cached_power(int min_exponent, int &pow10_exponent) {\n+// Returns cached power (of 10) c_k = c_k.f * pow(2, c_k.e) such that its\n+// (binary) exponent satisfies min_exponent <= c_k.e <= min_exponent + 28.\n+FMT_FUNC fp get_cached_power(int min_exponent, int& pow10_exponent) {\n   const double one_over_log2_10 = 0.30102999566398114;  // 1 / log2(10)\n-  int index = static_cast<int>(std::ceil(\n-        (min_exponent + fp::significand_size - 1) * one_over_log2_10));\n+  int index = static_cast<int>(\n+      std::ceil((min_exponent + fp::significand_size - 1) * one_over_log2_10));\n   // Decimal exponent of the first (smallest) cached power of 10.\n   const int first_dec_exp = -348;\n   // Difference between 2 consecutive decimal exponents in cached powers of 10.\n   const int dec_exp_step = 8;\n   index = (index - first_dec_exp - 1) / dec_exp_step + 1;\n   pow10_exponent = first_dec_exp + index * dec_exp_step;\n-  return fp(data::POW10_SIGNIFICANDS[index], data::POW10_EXPONENTS[index]);\n+  return fp(data::pow10_significands[index], data::pow10_exponents[index]);\n+}\n+\n+enum round_direction { unknown, up, down };\n+\n+// Given the divisor (normally a power of 10), the remainder = v % divisor for\n+// some number v and the error, returns whether v should be rounded up, down, or\n+// whether the rounding direction can't be determined due to error.\n+// error should be less than divisor / 2.\n+inline round_direction get_round_direction(uint64_t divisor, uint64_t remainder,\n+                                           uint64_t error) {\n+  FMT_ASSERT(remainder < divisor, \"\");  // divisor - remainder won't overflow.\n+  FMT_ASSERT(error < divisor, \"\");      // divisor - error won't overflow.\n+  FMT_ASSERT(error < divisor - error, \"\");  // error * 2 won't overflow.\n+  // Round down if (remainder + error) * 2 <= divisor.\n+  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)\n+    return down;\n+  // Round up if (remainder - error) * 2 >= divisor.\n+  if (remainder >= error &&\n+      remainder - error >= divisor - (remainder - error)) {\n+    return up;\n+  }\n+  return unknown;\n }\n \n-FMT_FUNC bool grisu2_round(\n-    char *buf, int &size, int max_digits, uint64_t delta,\n-    uint64_t remainder, uint64_t exp, uint64_t diff, int &exp10) {\n-  while (remainder < diff && delta - remainder >= exp &&\n-        (remainder + exp < diff || diff - remainder > remainder + exp - diff)) {\n-    --buf[size - 1];\n-    remainder += exp;\n-  }\n-  if (size > max_digits) {\n-    --size;\n-    ++exp10;\n-    if (buf[size] >= '5')\n-      return false;\n-  }\n-  return true;\n+namespace digits {\n+enum result {\n+  more,  // Generate more digits.\n+  done,  // Done generating digits.\n+  error  // Digit generation cancelled due to an error.\n+};\n }\n \n-// Generates output using Grisu2 digit-gen algorithm.\n-FMT_FUNC bool grisu2_gen_digits(\n-    char *buf, int &size, uint32_t hi, uint64_t lo, int &exp,\n-    uint64_t delta, const fp &one, const fp &diff, int max_digits) {\n-  // Generate digits for the most significant part (hi).\n-  while (exp > 0) {\n+// Generates output using the Grisu digit-gen algorithm.\n+// error: the size of the region (lower, upper) outside of which numbers\n+// definitely do not round to value (Delta in Grisu3).\n+template <typename Handler>\n+digits::result grisu_gen_digits(fp value, uint64_t error, int& exp,\n+                                Handler& handler) {\n+  fp one(1ull << -value.e, value.e);\n+  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be\n+  // zero because it contains a product of two 64-bit numbers with MSB set (due\n+  // to normalization) - 1, shifted right by at most 60 bits.\n+  uint32_t integral = static_cast<uint32_t>(value.f >> -one.e);\n+  FMT_ASSERT(integral != 0, \"\");\n+  FMT_ASSERT(integral == value.f >> -one.e, \"\");\n+  // The fractional part of scaled value (p2 in Grisu) c = value % one.\n+  uint64_t fractional = value.f & (one.f - 1);\n+  exp = count_digits(integral);  // kappa in Grisu.\n+  // Divide by 10 to prevent overflow.\n+  auto result = handler.on_start(data::powers_of_10_64[exp - 1] << -one.e,\n+                                 value.f / 10, error * 10, exp);\n+  if (result != digits::more) return result;\n+  // Generate digits for the integral part. This can produce up to 10 digits.\n+  do {\n     uint32_t digit = 0;\n     // This optimization by miloyip reduces the number of integer divisions by\n     // one per iteration.\n     switch (exp) {\n-    case 10: digit = hi / 1000000000; hi %= 1000000000; break;\n-    case  9: digit = hi /  100000000; hi %=  100000000; break;\n-    case  8: digit = hi /   10000000; hi %=   10000000; break;\n-    case  7: digit = hi /    1000000; hi %=    1000000; break;\n-    case  6: digit = hi /     100000; hi %=     100000; break;\n-    case  5: digit = hi /      10000; hi %=      10000; break;\n-    case  4: digit = hi /       1000; hi %=       1000; break;\n-    case  3: digit = hi /        100; hi %=        100; break;\n-    case  2: digit = hi /         10; hi %=         10; break;\n-    case  1: digit = hi;              hi =           0; break;\n+    case 10:\n+      digit = integral / 1000000000;\n+      integral %= 1000000000;\n+      break;\n+    case 9:\n+      digit = integral / 100000000;\n+      integral %= 100000000;\n+      break;\n+    case 8:\n+      digit = integral / 10000000;\n+      integral %= 10000000;\n+      break;\n+    case 7:\n+      digit = integral / 1000000;\n+      integral %= 1000000;\n+      break;\n+    case 6:\n+      digit = integral / 100000;\n+      integral %= 100000;\n+      break;\n+    case 5:\n+      digit = integral / 10000;\n+      integral %= 10000;\n+      break;\n+    case 4:\n+      digit = integral / 1000;\n+      integral %= 1000;\n+      break;\n+    case 3:\n+      digit = integral / 100;\n+      integral %= 100;\n+      break;\n+    case 2:\n+      digit = integral / 10;\n+      integral %= 10;\n+      break;\n+    case 1:\n+      digit = integral;\n+      integral = 0;\n+      break;\n     default:\n       FMT_ASSERT(false, \"invalid number of digits\");\n     }\n-    if (digit != 0 || size != 0)\n-      buf[size++] = static_cast<char>('0' + digit);\n     --exp;\n-    uint64_t remainder = (static_cast<uint64_t>(hi) << -one.e) + lo;\n-    if (remainder <= delta || size > max_digits) {\n-      return grisu2_round(\n-            buf, size, max_digits, delta, remainder,\n-            static_cast<uint64_t>(data::POWERS_OF_10_32[exp]) << -one.e,\n-            diff.f, exp);\n-    }\n-  }\n-  // Generate digits for the least significant part (lo).\n+    uint64_t remainder =\n+        (static_cast<uint64_t>(integral) << -one.e) + fractional;\n+    result = handler.on_digit(static_cast<char>('0' + digit),\n+                              data::powers_of_10_64[exp] << -one.e, remainder,\n+                              error, exp, true);\n+    if (result != digits::more) return result;\n+  } while (exp > 0);\n+  // Generate digits for the fractional part.\n   for (;;) {\n-    lo *= 10;\n-    delta *= 10;\n-    char digit = static_cast<char>(lo >> -one.e);\n-    if (digit != 0 || size != 0)\n-      buf[size++] = static_cast<char>('0' + digit);\n-    lo &= one.f - 1;\n+    fractional *= 10;\n+    error *= 10;\n+    char digit =\n+        static_cast<char>('0' + static_cast<char>(fractional >> -one.e));\n+    fractional &= one.f - 1;\n     --exp;\n-    if (lo < delta || size > max_digits) {\n-      return grisu2_round(buf, size, max_digits, delta, lo, one.f,\n-                          diff.f * data::POWERS_OF_10_32[-exp], exp);\n-    }\n+    result = handler.on_digit(digit, one.f, fractional, error, exp, false);\n+    if (result != digits::more) return result;\n   }\n }\n \n-#if FMT_CLANG_VERSION\n-# define FMT_FALLTHROUGH [[clang::fallthrough]];\n-#elif FMT_GCC_VERSION >= 700\n-# define FMT_FALLTHROUGH [[gnu::fallthrough]];\n-#else\n-# define FMT_FALLTHROUGH\n-#endif\n-\n-struct gen_digits_params {\n-  int num_digits;\n+// The fixed precision digit handler.\n+struct fixed_handler {\n+  char* buf;\n+  int size;\n+  int precision;\n+  int exp10;\n   bool fixed;\n-  bool upper;\n-  bool trailing_zeros;\n-};\n-\n-struct prettify_handler {\n-  char *data;\n-  ptrdiff_t size;\n-  buffer &buf;\n-\n-  explicit prettify_handler(buffer &b, ptrdiff_t n)\n-    : data(b.data()), size(n), buf(b) {}\n-  ~prettify_handler() {\n-    assert(buf.size() >= to_unsigned(size));\n-    buf.resize(to_unsigned(size));\n-  }\n-\n-  template <typename F>\n-  void insert(ptrdiff_t pos, ptrdiff_t n, F f) {\n-    std::memmove(data + pos + n, data + pos, to_unsigned(size - pos));\n-    f(data + pos);\n-    size += n;\n-  }\n \n-  void insert(ptrdiff_t pos, char c) {\n-    std::memmove(data + pos + 1, data + pos, to_unsigned(size - pos));\n-    data[pos] = c;\n-    ++size;\n+  digits::result on_start(uint64_t divisor, uint64_t remainder, uint64_t error,\n+                          int& exp) {\n+    // Non-fixed formats require at least one digit and no precision adjustment.\n+    if (!fixed) return digits::more;\n+    // Adjust fixed precision by exponent because it is relative to decimal\n+    // point.\n+    precision += exp + exp10;\n+    // Check if precision is satisfied just by leading zeros, e.g.\n+    // format(\"{:.2f}\", 0.001) gives \"0.00\" without generating any digits.\n+    if (precision > 0) return digits::more;\n+    if (precision < 0) return digits::done;\n+    auto dir = get_round_direction(divisor, remainder, error);\n+    if (dir == unknown) return digits::error;\n+    buf[size++] = dir == up ? '1' : '0';\n+    return digits::done;\n   }\n \n-  void append(ptrdiff_t n, char c) {\n-    std::uninitialized_fill_n(data + size, n, c);\n-    size += n;\n-  }\n-\n-  void append(char c) { data[size++] = c; }\n-\n-  void remove_trailing(char c) {\n-    while (data[size - 1] == c) --size;\n+  digits::result on_digit(char digit, uint64_t divisor, uint64_t remainder,\n+                          uint64_t error, int, bool integral) {\n+    FMT_ASSERT(remainder < divisor, \"\");\n+    buf[size++] = digit;\n+    if (size < precision) return digits::more;\n+    if (!integral) {\n+      // Check if error * 2 < divisor with overflow prevention.\n+      // The check is not needed for the integral part because error = 1\n+      // and divisor > (1 << 32) there.\n+      if (error >= divisor || error >= divisor - error) return digits::error;\n+    } else {\n+      FMT_ASSERT(error == 1 && divisor > 2, \"\");\n+    }\n+    auto dir = get_round_direction(divisor, remainder, error);\n+    if (dir != up) return dir == down ? digits::done : digits::error;\n+    ++buf[size - 1];\n+    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {\n+      buf[i] = '0';\n+      ++buf[i - 1];\n+    }\n+    if (buf[0] > '9') {\n+      buf[0] = '1';\n+      buf[size++] = '0';\n+    }\n+    return digits::done;\n   }\n };\n \n-// Writes the exponent exp in the form \"[+-]d{2,3}\" to buffer.\n-template <typename Handler>\n-FMT_FUNC void write_exponent(int exp, Handler &&h) {\n-  FMT_ASSERT(-1000 < exp && exp < 1000, \"exponent out of range\");\n-  if (exp < 0) {\n-    h.append('-');\n-    exp = -exp;\n-  } else {\n-    h.append('+');\n-  }\n-  if (exp >= 100) {\n-    h.append(static_cast<char>('0' + exp / 100));\n-    exp %= 100;\n-    const char *d = data::DIGITS + exp * 2;\n-    h.append(d[0]);\n-    h.append(d[1]);\n-  } else {\n-    const char *d = data::DIGITS + exp * 2;\n-    h.append(d[0]);\n-    h.append(d[1]);\n-  }\n-}\n+// The shortest representation digit handler.\n+template <int GRISU_VERSION> struct grisu_shortest_handler {\n+  char* buf;\n+  int size;\n+  // Distance between scaled value and upper bound (wp_W in Grisu3).\n+  uint64_t diff;\n \n-struct fill {\n-  size_t n;\n-  void operator()(char *buf) const {\n-    buf[0] = '0';\n-    buf[1] = '.';\n-    std::uninitialized_fill_n(buf + 2, n, '0');\n+  digits::result on_start(uint64_t, uint64_t, uint64_t, int&) {\n+    return digits::more;\n   }\n-};\n \n-// The number is given as v = f * pow(10, exp), where f has size digits.\n-template <typename Handler>\n-FMT_FUNC void grisu2_prettify(const gen_digits_params &params,\n-                              int size, int exp, Handler &&handler) {\n-  if (!params.fixed) {\n-    // Insert a decimal point after the first digit and add an exponent.\n-    handler.insert(1, '.');\n-    exp += size - 1;\n-    if (size < params.num_digits)\n-      handler.append(params.num_digits - size, '0');\n-    handler.append(params.upper ? 'E' : 'e');\n-    write_exponent(exp, handler);\n-    return;\n-  }\n-  // pow(10, full_exp - 1) <= v <= pow(10, full_exp).\n-  int full_exp = size + exp;\n-  const int exp_threshold = 21;\n-  if (size <= full_exp && full_exp <= exp_threshold) {\n-    // 1234e7 -> 12340000000[.0+]\n-    handler.append(full_exp - size, '0');\n-    int num_zeros = params.num_digits - full_exp;\n-    if (num_zeros > 0 && params.trailing_zeros) {\n-      handler.append('.');\n-      handler.append(num_zeros, '0');\n-    }\n-  } else if (full_exp > 0) {\n-    // 1234e-2 -> 12.34[0+]\n-    handler.insert(full_exp, '.');\n-    if (!params.trailing_zeros) {\n-      // Remove trailing zeros.\n-      handler.remove_trailing('0');\n-    } else if (params.num_digits > size) {\n-      // Add trailing zeros.\n-      ptrdiff_t num_zeros = params.num_digits - size;\n-      handler.append(num_zeros, '0');\n+  // Decrement the generated number approaching value from above.\n+  void round(uint64_t d, uint64_t divisor, uint64_t& remainder,\n+             uint64_t error) {\n+    while (\n+        remainder < d && error - remainder >= divisor &&\n+        (remainder + divisor < d || d - remainder >= remainder + divisor - d)) {\n+      --buf[size - 1];\n+      remainder += divisor;\n     }\n-  } else {\n-    // 1234e-6 -> 0.001234\n-    handler.insert(0, 2 - full_exp, fill{to_unsigned(-full_exp)});\n   }\n-}\n \n-struct char_counter {\n-  ptrdiff_t size;\n-\n-  template <typename F>\n-  void insert(ptrdiff_t, ptrdiff_t n, F) { size += n; }\n-  void insert(ptrdiff_t, char) { ++size; }\n-  void append(ptrdiff_t n, char) { size += n; }\n-  void append(char) { ++size; }\n-  void remove_trailing(char) {}\n-};\n-\n-// Converts format specifiers into parameters for digit generation and computes\n-// output buffer size for a number in the range [pow(10, exp - 1), pow(10, exp)\n-// or 0 if exp == 1.\n-FMT_FUNC gen_digits_params process_specs(const core_format_specs &specs,\n-                                         int exp, buffer &buf) {\n-  auto params = gen_digits_params();\n-  int num_digits = specs.precision >= 0 ? specs.precision : 6;\n-  switch (specs.type) {\n-  case 'G':\n-    params.upper = true;\n-    FMT_FALLTHROUGH\n-  case '\\0': case 'g':\n-    params.trailing_zeros = (specs.flags & HASH_FLAG) != 0;\n-    if (-4 <= exp && exp < num_digits + 1) {\n-      params.fixed = true;\n-      if (!specs.type && params.trailing_zeros && exp >= 0)\n-        num_digits = exp + 1;\n+  // Implements Grisu's round_weed.\n+  digits::result on_digit(char digit, uint64_t divisor, uint64_t remainder,\n+                          uint64_t error, int exp, bool integral) {\n+    buf[size++] = digit;\n+    if (remainder >= error) return digits::more;\n+    if (GRISU_VERSION != 3) {\n+      uint64_t d = integral ? diff : diff * data::powers_of_10_64[-exp];\n+      round(d, divisor, remainder, error);\n+      return digits::done;\n     }\n-    break;\n-  case 'F':\n-    params.upper = true;\n-    FMT_FALLTHROUGH\n-  case 'f': {\n-    params.fixed = true;\n-    params.trailing_zeros = true;\n-    int adjusted_min_digits = num_digits + exp;\n-    if (adjusted_min_digits > 0)\n-      num_digits = adjusted_min_digits;\n-    break;\n-  }\n-  case 'E':\n-    params.upper = true;\n-    FMT_FALLTHROUGH\n-  case 'e':\n-    ++num_digits;\n-    break;\n+    uint64_t unit = integral ? 1 : data::powers_of_10_64[-exp];\n+    uint64_t up = (diff - 1) * unit;  // wp_Wup\n+    round(up, divisor, remainder, error);\n+    uint64_t down = (diff + 1) * unit;  // wp_Wdown\n+    if (remainder < down && error - remainder >= divisor &&\n+        (remainder + divisor < down ||\n+         down - remainder > remainder + divisor - down)) {\n+      return digits::error;\n+    }\n+    return 2 * unit <= remainder && remainder <= error - 4 * unit\n+               ? digits::done\n+               : digits::error;\n   }\n-  params.num_digits = num_digits;\n-  char_counter counter{num_digits};\n-  grisu2_prettify(params, params.num_digits, exp - num_digits, counter);\n-  buf.resize(to_unsigned(counter.size));\n-  return params;\n-}\n+};\n \n-template <typename Double>\n-FMT_FUNC typename std::enable_if<sizeof(Double) == sizeof(uint64_t), bool>::type\n-    grisu2_format(Double value, buffer &buf, core_format_specs specs) {\n+template <typename Double,\n+          enable_if_t<(sizeof(Double) == sizeof(uint64_t)), int>>\n+FMT_API bool grisu_format(Double value, buffer<char>& buf, int precision,\n+                          unsigned options, int& exp) {\n   FMT_ASSERT(value >= 0, \"value is negative\");\n-  if (value == 0) {\n-    gen_digits_params params = process_specs(specs, 1, buf);\n-    const size_t size = 1;\n-    buf[0] = '0';\n-    grisu2_prettify(params, size, 0, prettify_handler(buf, size));\n+  bool fixed = (options & grisu_options::fixed) != 0;\n+  if (value <= 0) {  // <= instead of == to silence a warning.\n+    if (precision <= 0 || !fixed) {\n+      exp = 0;\n+      buf.push_back('0');\n+    } else {\n+      exp = -precision;\n+      buf.resize(precision);\n+      std::uninitialized_fill_n(buf.data(), precision, '0');\n+    }\n     return true;\n   }\n \n   fp fp_value(value);\n-  fp lower, upper;  // w^- and w^+ in the Grisu paper.\n-  fp_value.compute_boundaries(lower, upper);\n-\n-  // Find a cached power of 10 close to 1 / upper and use it to scale upper.\n   const int min_exp = -60;  // alpha in Grisu.\n-  int cached_exp = 0;  // K in Grisu.\n-  auto cached_pow = get_cached_power(  // \\tilde{c}_{-k} in Grisu.\n-      min_exp - (upper.e + fp::significand_size), cached_exp);\n-  cached_exp = -cached_exp;\n-  upper = upper * cached_pow;  // \\tilde{M}^+ in Grisu.\n-  --upper.f;  // \\tilde{M}^+ - 1 ulp -> M^+_{\\downarrow}.\n-  fp one(1ull << -upper.e, upper.e);\n-  // hi (p1 in Grisu) contains the most significant digits of scaled_upper.\n-  // hi = floor(upper / one).\n-  uint32_t hi = static_cast<uint32_t>(upper.f >> -one.e);\n-  int exp = count_digits(hi);  // kappa in Grisu.\n-  gen_digits_params params = process_specs(specs, cached_exp + exp, buf);\n-  fp_value.normalize();\n-  fp scaled_value = fp_value * cached_pow;\n-  lower = lower * cached_pow;  // \\tilde{M}^- in Grisu.\n-  ++lower.f;  // \\tilde{M}^- + 1 ulp -> M^-_{\\uparrow}.\n-  uint64_t delta = upper.f - lower.f;\n-  fp diff = upper - scaled_value; // wp_w in Grisu.\n-  // lo (p2 in Grisu) contains the least significants digits of scaled_upper.\n-  // lo = supper % one.\n-  uint64_t lo = upper.f & (one.f - 1);\n-  int size = 0;\n-  if (!grisu2_gen_digits(buf.data(), size, hi, lo, exp, delta, one, diff,\n-                         params.num_digits)) {\n-    buf.clear();\n-    return false;\n+  int cached_exp10 = 0;     // K in Grisu.\n+  if (precision != -1) {\n+    if (precision > 17) return false;\n+    fp_value.normalize();\n+    auto cached_pow = get_cached_power(\n+        min_exp - (fp_value.e + fp::significand_size), cached_exp10);\n+    fp_value = fp_value * cached_pow;\n+    fixed_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};\n+    if (grisu_gen_digits(fp_value, 1, exp, handler) == digits::error)\n+      return false;\n+    buf.resize(to_unsigned(handler.size));\n+  } else {\n+    fp lower, upper;  // w^- and w^+ in the Grisu paper.\n+    fp_value.compute_boundaries(lower, upper);\n+    // Find a cached power of 10 such that multiplying upper by it will bring\n+    // the exponent in the range [min_exp, -32].\n+    auto cached_pow = get_cached_power(  // \\tilde{c}_{-k} in Grisu.\n+        min_exp - (upper.e + fp::significand_size), cached_exp10);\n+    fp_value.normalize();\n+    fp_value = fp_value * cached_pow;\n+    lower = lower * cached_pow;  // \\tilde{M}^- in Grisu.\n+    upper = upper * cached_pow;  // \\tilde{M}^+ in Grisu.\n+    assert(min_exp <= upper.e && upper.e <= -32);\n+    auto result = digits::result();\n+    int size = 0;\n+    if ((options & grisu_options::grisu3) != 0) {\n+      --lower.f;  // \\tilde{M}^- - 1 ulp -> M^-_{\\downarrow}.\n+      ++upper.f;  // \\tilde{M}^+ + 1 ulp -> M^+_{\\uparrow}.\n+      // Numbers outside of (lower, upper) definitely do not round to value.\n+      grisu_shortest_handler<3> handler{buf.data(), 0, (upper - fp_value).f};\n+      result = grisu_gen_digits(upper, upper.f - lower.f, exp, handler);\n+      size = handler.size;\n+    } else {\n+      ++lower.f;  // \\tilde{M}^- + 1 ulp -> M^-_{\\uparrow}.\n+      --upper.f;  // \\tilde{M}^+ - 1 ulp -> M^+_{\\downarrow}.\n+      grisu_shortest_handler<2> handler{buf.data(), 0, (upper - fp_value).f};\n+      result = grisu_gen_digits(upper, upper.f - lower.f, exp, handler);\n+      size = handler.size;\n+    }\n+    if (result == digits::error) return false;\n+    buf.resize(to_unsigned(size));\n   }\n-  grisu2_prettify(params, size, cached_exp + exp, prettify_handler(buf, size));\n+  exp -= cached_exp10;\n   return true;\n }\n \n template <typename Double>\n-void sprintf_format(Double value, internal::buffer &buf,\n-                    core_format_specs spec) {\n+char* sprintf_format(Double value, internal::buffer<char>& buf,\n+                     sprintf_specs specs) {\n   // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.\n   FMT_ASSERT(buf.capacity() != 0, \"empty buffer\");\n \n   // Build format string.\n-  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg\n-  char format[MAX_FORMAT_SIZE];\n-  char *format_ptr = format;\n+  enum { max_format_size = 10 };  // longest format: %#-*.*Lg\n+  char format[max_format_size];\n+  char* format_ptr = format;\n   *format_ptr++ = '%';\n-  if (spec.has(HASH_FLAG))\n-    *format_ptr++ = '#';\n-  if (spec.precision >= 0) {\n+  if (specs.alt || !specs.type) *format_ptr++ = '#';\n+  if (specs.precision >= 0) {\n     *format_ptr++ = '.';\n     *format_ptr++ = '*';\n   }\n-  if (std::is_same<Double, long double>::value)\n-    *format_ptr++ = 'L';\n-  *format_ptr++ = spec.type;\n+  if (std::is_same<Double, long double>::value) *format_ptr++ = 'L';\n+\n+  char type = specs.type;\n+\n+  if (type == '%')\n+    type = 'f';\n+  else if (type == 0 || type == 'n')\n+    type = 'g';\n+#if FMT_MSC_VER\n+  if (type == 'F') {\n+    // MSVC's printf doesn't support 'F'.\n+    type = 'f';\n+  }\n+#endif\n+  *format_ptr++ = type;\n   *format_ptr = '\\0';\n \n   // Format using snprintf.\n-  char *start = FMT_NULL;\n+  char* start = nullptr;\n+  char* decimal_point_pos = nullptr;\n   for (;;) {\n     std::size_t buffer_size = buf.capacity();\n     start = &buf[0];\n-    int result = internal::char_traits<char>::format_float(\n-        start, buffer_size, format, spec.precision, value);\n+    int result =\n+        format_float(start, buffer_size, format, specs.precision, value);\n     if (result >= 0) {\n       unsigned n = internal::to_unsigned(result);\n       if (n < buf.capacity()) {\n+        // Find the decimal point.\n+        auto p = buf.data(), end = p + n;\n+        if (*p == '+' || *p == '-') ++p;\n+        if (specs.type != 'a' && specs.type != 'A') {\n+          while (p < end && *p >= '0' && *p <= '9') ++p;\n+          if (p < end && *p != 'e' && *p != 'E') {\n+            decimal_point_pos = p;\n+            if (!specs.type) {\n+              // Keep only one trailing zero after the decimal point.\n+              ++p;\n+              if (*p == '0') ++p;\n+              while (p != end && *p >= '1' && *p <= '9') ++p;\n+              char* where = p;\n+              while (p != end && *p == '0') ++p;\n+              if (p == end || *p < '0' || *p > '9') {\n+                if (p != end) std::memmove(where, p, to_unsigned(end - p));\n+                n -= static_cast<unsigned>(p - where);\n+              }\n+            }\n+          }\n+        }\n         buf.resize(n);\n         break;  // The buffer is large enough - continue with formatting.\n       }\n@@ -802,6 +827,7 @@ void sprintf_format(Double value, internal::buffer &buf,\n       buf.reserve(buf.capacity() + 1);\n     }\n   }\n+  return decimal_point_pos;\n }\n }  // namespace internal\n \n@@ -819,28 +845,25 @@ FMT_FUNC internal::utf8_to_utf16::utf8_to_utf16(string_view s) {\n     return;\n   }\n \n-  int length = MultiByteToWideChar(\n-      CP_UTF8, MB_ERR_INVALID_CHARS, s.data(), s_size, FMT_NULL, 0);\n-  if (length == 0)\n-    FMT_THROW(windows_error(GetLastError(), ERROR_MSG));\n+  int length = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, s.data(),\n+                                   s_size, nullptr, 0);\n+  if (length == 0) FMT_THROW(windows_error(GetLastError(), ERROR_MSG));\n   buffer_.resize(length + 1);\n-  length = MultiByteToWideChar(\n-    CP_UTF8, MB_ERR_INVALID_CHARS, s.data(), s_size, &buffer_[0], length);\n-  if (length == 0)\n-    FMT_THROW(windows_error(GetLastError(), ERROR_MSG));\n+  length = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, s.data(), s_size,\n+                               &buffer_[0], length);\n+  if (length == 0) FMT_THROW(windows_error(GetLastError(), ERROR_MSG));\n   buffer_[length] = 0;\n }\n \n FMT_FUNC internal::utf16_to_utf8::utf16_to_utf8(wstring_view s) {\n   if (int error_code = convert(s)) {\n     FMT_THROW(windows_error(error_code,\n-        \"cannot convert string from UTF-16 to UTF-8\"));\n+                            \"cannot convert string from UTF-16 to UTF-8\"));\n   }\n }\n \n FMT_FUNC int internal::utf16_to_utf8::convert(wstring_view s) {\n-  if (s.size() > INT_MAX)\n-    return ERROR_INVALID_PARAMETER;\n+  if (s.size() > INT_MAX) return ERROR_INVALID_PARAMETER;\n   int s_size = static_cast<int>(s.size());\n   if (s_size == 0) {\n     // WideCharToMultiByte does not support zero length, handle separately.\n@@ -849,43 +872,42 @@ FMT_FUNC int internal::utf16_to_utf8::convert(wstring_view s) {\n     return 0;\n   }\n \n-  int length = WideCharToMultiByte(\n-        CP_UTF8, 0, s.data(), s_size, FMT_NULL, 0, FMT_NULL, FMT_NULL);\n-  if (length == 0)\n-    return GetLastError();\n+  int length = WideCharToMultiByte(CP_UTF8, 0, s.data(), s_size, nullptr, 0,\n+                                   nullptr, nullptr);\n+  if (length == 0) return GetLastError();\n   buffer_.resize(length + 1);\n-  length = WideCharToMultiByte(\n-    CP_UTF8, 0, s.data(), s_size, &buffer_[0], length, FMT_NULL, FMT_NULL);\n-  if (length == 0)\n-    return GetLastError();\n+  length = WideCharToMultiByte(CP_UTF8, 0, s.data(), s_size, &buffer_[0],\n+                               length, nullptr, nullptr);\n+  if (length == 0) return GetLastError();\n   buffer_[length] = 0;\n   return 0;\n }\n \n-FMT_FUNC void windows_error::init(\n-    int err_code, string_view format_str, format_args args) {\n+FMT_FUNC void windows_error::init(int err_code, string_view format_str,\n+                                  format_args args) {\n   error_code_ = err_code;\n   memory_buffer buffer;\n   internal::format_windows_error(buffer, err_code, vformat(format_str, args));\n-  std::runtime_error &base = *this;\n+  std::runtime_error& base = *this;\n   base = std::runtime_error(to_string(buffer));\n }\n \n-FMT_FUNC void internal::format_windows_error(\n-    internal::buffer &out, int error_code, string_view message) FMT_NOEXCEPT {\n+FMT_FUNC void internal::format_windows_error(internal::buffer<char>& out,\n+                                             int error_code,\n+                                             string_view message) FMT_NOEXCEPT {\n   FMT_TRY {\n     wmemory_buffer buf;\n     buf.resize(inline_buffer_size);\n     for (;;) {\n-      wchar_t *system_message = &buf[0];\n+      wchar_t* system_message = &buf[0];\n       int result = FormatMessageW(\n-          FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n-          FMT_NULL, error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-          system_message, static_cast<uint32_t>(buf.size()), FMT_NULL);\n+          FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr,\n+          error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), system_message,\n+          static_cast<uint32_t>(buf.size()), nullptr);\n       if (result != 0) {\n         utf16_to_utf8 utf8_message;\n         if (utf8_message.convert(system_message) == ERROR_SUCCESS) {\n-          writer w(out);\n+          internal::writer w(out);\n           w.write(message);\n           w.write(\": \");\n           w.write(utf8_message);\n@@ -897,22 +919,24 @@ FMT_FUNC void internal::format_windows_error(\n         break;  // Can't get error message, report error code instead.\n       buf.resize(buf.size() * 2);\n     }\n-  } FMT_CATCH(...) {}\n+  }\n+  FMT_CATCH(...) {}\n   format_error_code(out, error_code, message);\n }\n \n #endif  // FMT_USE_WINDOWS_H\n \n-FMT_FUNC void format_system_error(\n-    internal::buffer &out, int error_code, string_view message) FMT_NOEXCEPT {\n+FMT_FUNC void format_system_error(internal::buffer<char>& out, int error_code,\n+                                  string_view message) FMT_NOEXCEPT {\n   FMT_TRY {\n     memory_buffer buf;\n     buf.resize(inline_buffer_size);\n     for (;;) {\n-      char *system_message = &buf[0];\n-      int result = safe_strerror(error_code, system_message, buf.size());\n+      char* system_message = &buf[0];\n+      int result =\n+          internal::safe_strerror(error_code, system_message, buf.size());\n       if (result == 0) {\n-        writer w(out);\n+        internal::writer w(out);\n         w.write(message);\n         w.write(\": \");\n         w.write(system_message);\n@@ -922,37 +946,41 @@ FMT_FUNC void format_system_error(\n         break;  // Can't get error message, report error code instead.\n       buf.resize(buf.size() * 2);\n     }\n-  } FMT_CATCH(...) {}\n+  }\n+  FMT_CATCH(...) {}\n   format_error_code(out, error_code, message);\n }\n \n-FMT_FUNC void internal::error_handler::on_error(const char *message) {\n+FMT_FUNC void internal::error_handler::on_error(const char* message) {\n   FMT_THROW(format_error(message));\n }\n \n-FMT_FUNC void report_system_error(\n-    int error_code, fmt::string_view message) FMT_NOEXCEPT {\n+FMT_FUNC void report_system_error(int error_code,\n+                                  fmt::string_view message) FMT_NOEXCEPT {\n   report_error(format_system_error, error_code, message);\n }\n \n #if FMT_USE_WINDOWS_H\n-FMT_FUNC void report_windows_error(\n-    int error_code, fmt::string_view message) FMT_NOEXCEPT {\n+FMT_FUNC void report_windows_error(int error_code,\n+                                   fmt::string_view message) FMT_NOEXCEPT {\n   report_error(internal::format_windows_error, error_code, message);\n }\n #endif\n \n-FMT_FUNC void vprint(std::FILE *f, string_view format_str, format_args args) {\n+FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {\n   memory_buffer buffer;\n   internal::vformat_to(buffer, format_str,\n-                       basic_format_args<buffer_context<char>::type>(args));\n-  std::fwrite(buffer.data(), 1, buffer.size(), f);\n+                       basic_format_args<buffer_context<char>>(args));\n+  internal::fwrite_fully(buffer.data(), 1, buffer.size(), f);\n }\n \n-FMT_FUNC void vprint(std::FILE *f, wstring_view format_str, wformat_args args) {\n+FMT_FUNC void vprint(std::FILE* f, wstring_view format_str, wformat_args args) {\n   wmemory_buffer buffer;\n   internal::vformat_to(buffer, format_str, args);\n-  std::fwrite(buffer.data(), sizeof(wchar_t), buffer.size(), f);\n+  buffer.push_back(L'\\0');\n+  if (std::fputws(buffer.data(), f) == -1) {\n+    FMT_THROW(system_error(errno, \"cannot write to file\"));\n+  }\n }\n \n FMT_FUNC void vprint(string_view format_str, format_args args) {\n@@ -966,7 +994,7 @@ FMT_FUNC void vprint(wstring_view format_str, wformat_args args) {\n FMT_END_NAMESPACE\n \n #ifdef _MSC_VER\n-# pragma warning(pop)\n+#  pragma warning(pop)\n #endif\n \n #endif  // FMT_FORMAT_INL_H_\ndiff --git a/include/spdlog/fmt/bundled/format.h b/include/spdlog/fmt/bundled/format.h\n--- a/include/spdlog/fmt/bundled/format.h\n+++ b/include/spdlog/fmt/bundled/format.h\n@@ -2,27 +2,32 @@\n  Formatting library for C++\n \n  Copyright (c) 2012 - present, Victor Zverovich\n- All rights reserved.\n-\n- Redistribution and use in source and binary forms, with or without\n- modification, are permitted provided that the following conditions are met:\n-\n- 1. Redistributions of source code must retain the above copyright notice, this\n-    list of conditions and the following disclaimer.\n- 2. Redistributions in binary form must reproduce the above copyright notice,\n-    this list of conditions and the following disclaimer in the documentation\n-    and/or other materials provided with the distribution.\n-\n- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n- ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+ Permission is hereby granted, free of charge, to any person obtaining\n+ a copy of this software and associated documentation files (the\n+ \"Software\"), to deal in the Software without restriction, including\n+ without limitation the rights to use, copy, modify, merge, publish,\n+ distribute, sublicense, and/or sell copies of the Software, and to\n+ permit persons to whom the Software is furnished to do so, subject to\n+ the following conditions:\n+\n+ The above copyright notice and this permission notice shall be\n+ included in all copies or substantial portions of the Software.\n+\n+ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+ NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+ LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+ OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+ --- Optional exception to the license ---\n+\n+ As an exception, if, as a result of your compiling your source code, portions\n+ of this Software are embedded into a machine-executable object form of such\n+ source code, you may redistribute such embedded portions in such object form\n+ without including the above copyright and permission notices.\n  */\n \n #ifndef FMT_FORMAT_H_\n@@ -31,165 +36,122 @@\n #include <algorithm>\n #include <cassert>\n #include <cmath>\n+#include <cstdint>\n #include <cstring>\n+#include <iterator>\n #include <limits>\n #include <memory>\n #include <stdexcept>\n-#include <stdint.h>\n+\n+#include \"core.h\"\n \n #ifdef __clang__\n-# define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)\n+#  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)\n #else\n-# define FMT_CLANG_VERSION 0\n+#  define FMT_CLANG_VERSION 0\n #endif\n \n #ifdef __INTEL_COMPILER\n-# define FMT_ICC_VERSION __INTEL_COMPILER\n+#  define FMT_ICC_VERSION __INTEL_COMPILER\n #elif defined(__ICL)\n-# define FMT_ICC_VERSION __ICL\n+#  define FMT_ICC_VERSION __ICL\n #else\n-# define FMT_ICC_VERSION 0\n+#  define FMT_ICC_VERSION 0\n #endif\n \n #ifdef __NVCC__\n-# define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)\n-#else\n-# define FMT_CUDA_VERSION 0\n-#endif\n-\n-#include \"core.h\"\n-\n-#if FMT_GCC_VERSION >= 406 || FMT_CLANG_VERSION\n-# pragma GCC diagnostic push\n-\n-// Disable the warning about declaration shadowing because it affects too\n-// many valid cases.\n-# pragma GCC diagnostic ignored \"-Wshadow\"\n-\n-// Disable the warning about nonliteral format strings because we construct\n-// them dynamically when falling back to snprintf for FP formatting.\n-# pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n-#endif\n-\n-# if FMT_CLANG_VERSION\n-#  pragma GCC diagnostic ignored \"-Wgnu-string-literal-operator-template\"\n-# endif\n-\n-#ifdef _SECURE_SCL\n-# define FMT_SECURE_SCL _SECURE_SCL\n+#  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)\n #else\n-# define FMT_SECURE_SCL 0\n-#endif\n-\n-#if FMT_SECURE_SCL\n-# include <iterator>\n+#  define FMT_CUDA_VERSION 0\n #endif\n \n #ifdef __has_builtin\n-# define FMT_HAS_BUILTIN(x) __has_builtin(x)\n+#  define FMT_HAS_BUILTIN(x) __has_builtin(x)\n #else\n-# define FMT_HAS_BUILTIN(x) 0\n-#endif\n-\n-#ifdef __GNUC_LIBSTD__\n-# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)\n+#  define FMT_HAS_BUILTIN(x) 0\n #endif\n \n #ifndef FMT_THROW\n-# if FMT_EXCEPTIONS\n-#  if FMT_MSC_VER\n+#  if FMT_EXCEPTIONS\n+#    if FMT_MSC_VER\n FMT_BEGIN_NAMESPACE\n namespace internal {\n-template <typename Exception>\n-inline void do_throw(const Exception &x) {\n+template <typename Exception> inline void do_throw(const Exception& x) {\n   // Silence unreachable code warnings in MSVC because these are nearly\n   // impossible to fix in a generic code.\n   volatile bool b = true;\n-  if (b)\n-    throw x;\n-}\n+  if (b) throw x;\n }\n+}  // namespace internal\n FMT_END_NAMESPACE\n-#   define FMT_THROW(x) fmt::internal::do_throw(x)\n+#      define FMT_THROW(x) fmt::internal::do_throw(x)\n+#    else\n+#      define FMT_THROW(x) throw x\n+#    endif\n #  else\n-#   define FMT_THROW(x) throw x\n+#    define FMT_THROW(x)              \\\n+      do {                            \\\n+        static_cast<void>(sizeof(x)); \\\n+        assert(false);                \\\n+      } while (false)\n #  endif\n-# else\n-#  define FMT_THROW(x) do { static_cast<void>(sizeof(x)); assert(false); } while(false);\n-# endif\n #endif\n \n #ifndef FMT_USE_USER_DEFINED_LITERALS\n-// For Intel's compiler and NVIDIA's compiler both it and the system gcc/msc\n-// must support UDLs.\n-# if (FMT_HAS_FEATURE(cxx_user_literals) || \\\n-      FMT_GCC_VERSION >= 407 || FMT_MSC_VER >= 1900) && \\\n-      (!(FMT_ICC_VERSION || FMT_CUDA_VERSION) || \\\n-       FMT_ICC_VERSION >= 1500 || FMT_CUDA_VERSION >= 700)\n-#  define FMT_USE_USER_DEFINED_LITERALS 1\n-# else\n-#  define FMT_USE_USER_DEFINED_LITERALS 0\n-# endif\n-#endif\n-\n-// EDG C++ Front End based compilers (icc, nvcc) do not currently support UDL\n-// templates.\n-#if FMT_USE_USER_DEFINED_LITERALS && \\\n-    FMT_ICC_VERSION == 0 && \\\n-    FMT_CUDA_VERSION == 0 && \\\n-    ((FMT_GCC_VERSION >= 600 && __cplusplus >= 201402L) || \\\n-    (defined(FMT_CLANG_VERSION) && FMT_CLANG_VERSION >= 304))\n-# define FMT_UDL_TEMPLATE 1\n-#else\n-# define FMT_UDL_TEMPLATE 0\n+// For Intel and NVIDIA compilers both they and the system gcc/msc support UDLs.\n+#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 ||      \\\n+       FMT_MSC_VER >= 1900) &&                                              \\\n+      (!(FMT_ICC_VERSION || FMT_CUDA_VERSION) || FMT_ICC_VERSION >= 1500 || \\\n+       FMT_CUDA_VERSION >= 700)\n+#    define FMT_USE_USER_DEFINED_LITERALS 1\n+#  else\n+#    define FMT_USE_USER_DEFINED_LITERALS 0\n+#  endif\n #endif\n \n-#ifndef FMT_USE_EXTERN_TEMPLATES\n-# ifndef FMT_HEADER_ONLY\n-#  define FMT_USE_EXTERN_TEMPLATES \\\n-     ((FMT_CLANG_VERSION >= 209 && __cplusplus >= 201103L) || \\\n-      (FMT_GCC_VERSION >= 303 && FMT_HAS_GXX_CXX11))\n-# else\n-#  define FMT_USE_EXTERN_TEMPLATES 0\n-# endif\n+#ifndef FMT_USE_UDL_TEMPLATE\n+// EDG front end based compilers (icc, nvcc) do not support UDL templates yet\n+// and GCC 9 warns about them.\n+#  if FMT_USE_USER_DEFINED_LITERALS && FMT_ICC_VERSION == 0 && \\\n+      FMT_CUDA_VERSION == 0 &&                                 \\\n+      ((FMT_GCC_VERSION >= 600 && FMT_GCC_VERSION <= 900 &&    \\\n+        __cplusplus >= 201402L) ||                             \\\n+       FMT_CLANG_VERSION >= 304)\n+#    define FMT_USE_UDL_TEMPLATE 1\n+#  else\n+#    define FMT_USE_UDL_TEMPLATE 0\n+#  endif\n #endif\n \n-#if FMT_HAS_GXX_CXX11 || FMT_HAS_FEATURE(cxx_trailing_return) || \\\n-    FMT_MSC_VER >= 1600\n-# define FMT_USE_TRAILING_RETURN 1\n+#ifdef FMT_USE_INT128\n+// Do nothing.\n+#elif defined(__SIZEOF_INT128__)\n+#  define FMT_USE_INT128 1\n #else\n-# define FMT_USE_TRAILING_RETURN 0\n-#endif\n-\n-#ifndef FMT_USE_GRISU\n-# define FMT_USE_GRISU 0\n-//# define FMT_USE_GRISU std::numeric_limits<double>::is_iec559\n+#  define FMT_USE_INT128 0\n #endif\n \n // __builtin_clz is broken in clang with Microsoft CodeGen:\n // https://github.com/fmtlib/fmt/issues/519\n-#ifndef _MSC_VER\n-# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clz)\n+#if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clz)) && !FMT_MSC_VER\n #  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)\n-# endif\n-\n-# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clzll)\n+#endif\n+#if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clzll)) && !FMT_MSC_VER\n #  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)\n-# endif\n #endif\n \n // Some compilers masquerade as both MSVC and GCC-likes or otherwise support\n // __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the\n // MSVC intrinsics if the clz and clzll builtins are not available.\n #if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(_MANAGED)\n-# include <intrin.h>  // _BitScanReverse, _BitScanReverse64\n+#  include <intrin.h>  // _BitScanReverse, _BitScanReverse64\n \n FMT_BEGIN_NAMESPACE\n namespace internal {\n // Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.\n-# ifndef __clang__\n-#  pragma intrinsic(_BitScanReverse)\n-# endif\n+#  ifndef __clang__\n+#    pragma intrinsic(_BitScanReverse)\n+#  endif\n inline uint32_t clz(uint32_t x) {\n   unsigned long r = 0;\n   _BitScanReverse(&r, x);\n@@ -198,43 +160,52 @@ inline uint32_t clz(uint32_t x) {\n   // Static analysis complains about using uninitialized data\n   // \"r\", but the only way that can happen is if \"x\" is 0,\n   // which the callers guarantee to not happen.\n-# pragma warning(suppress: 6102)\n+#  pragma warning(suppress : 6102)\n   return 31 - r;\n }\n-# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)\n+#  define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)\n \n-# if defined(_WIN64) && !defined(__clang__)\n-#  pragma intrinsic(_BitScanReverse64)\n-# endif\n+#  if defined(_WIN64) && !defined(__clang__)\n+#    pragma intrinsic(_BitScanReverse64)\n+#  endif\n \n inline uint32_t clzll(uint64_t x) {\n   unsigned long r = 0;\n-# ifdef _WIN64\n+#  ifdef _WIN64\n   _BitScanReverse64(&r, x);\n-# else\n+#  else\n   // Scan the high 32 bits.\n-  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))\n-    return 63 - (r + 32);\n+  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32))) return 63 - (r + 32);\n \n   // Scan the low 32 bits.\n   _BitScanReverse(&r, static_cast<uint32_t>(x));\n-# endif\n+#  endif\n \n   assert(x != 0);\n   // Static analysis complains about using uninitialized data\n   // \"r\", but the only way that can happen is if \"x\" is 0,\n   // which the callers guarantee to not happen.\n-# pragma warning(suppress: 6102)\n+#  pragma warning(suppress : 6102)\n   return 63 - r;\n }\n-# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)\n-}\n+#  define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)\n+}  // namespace internal\n FMT_END_NAMESPACE\n #endif\n \n FMT_BEGIN_NAMESPACE\n namespace internal {\n \n+// A fallback implementation of uintptr_t for systems that lack it.\n+struct fallback_uintptr {\n+  unsigned char value[sizeof(void*)];\n+};\n+#ifdef UINTPTR_MAX\n+using uintptr_t = ::uintptr_t;\n+#else\n+using uintptr_t = fallback_uintptr;\n+#endif\n+\n // An equivalent of `*reinterpret_cast<Dest*>(&source)` that doesn't produce\n // undefined behavior (e.g. due to type aliasing).\n // Example: uint64_t d = bit_cast<uint64_t>(2.718);\n@@ -246,184 +217,283 @@ inline Dest bit_cast(const Source& source) {\n   return dest;\n }\n \n-// An implementation of begin and end for pre-C++11 compilers such as gcc 4.\n-template <typename C>\n-FMT_CONSTEXPR auto begin(const C &c) -> decltype(c.begin()) {\n-  return c.begin();\n-}\n-template <typename T, std::size_t N>\n-FMT_CONSTEXPR T *begin(T (&array)[N]) FMT_NOEXCEPT { return array; }\n-template <typename C>\n-FMT_CONSTEXPR auto end(const C &c) -> decltype(c.end()) { return c.end(); }\n-template <typename T, std::size_t N>\n-FMT_CONSTEXPR T *end(T (&array)[N]) FMT_NOEXCEPT { return array + N; }\n+// An approximation of iterator_t for pre-C++20 systems.\n+template <typename T>\n+using iterator_t = decltype(std::begin(std::declval<T&>()));\n+\n+// Detect the iterator category of *any* given type in a SFINAE-friendly way.\n+// Unfortunately, older implementations of std::iterator_traits are not safe\n+// for use in a SFINAE-context.\n+template <typename It, typename Enable = void>\n+struct iterator_category : std::false_type {};\n \n-// For std::result_of in gcc 4.4.\n-template <typename Result>\n-struct function {\n-  template <typename T>\n-  struct result { typedef Result type; };\n+template <typename T> struct iterator_category<T*> {\n+  using type = std::random_access_iterator_tag;\n };\n \n-struct dummy_int {\n-  int data[2];\n-  operator int() const { return 0; }\n+template <typename It>\n+struct iterator_category<It, void_t<typename It::iterator_category>> {\n+  using type = typename It::iterator_category;\n+};\n+\n+// Detect if *any* given type models the OutputIterator concept.\n+template <typename It> class is_output_iterator {\n+  // Check for mutability because all iterator categories derived from\n+  // std::input_iterator_tag *may* also meet the requirements of an\n+  // OutputIterator, thereby falling into the category of 'mutable iterators'\n+  // [iterator.requirements.general] clause 4. The compiler reveals this\n+  // property only at the point of *actually dereferencing* the iterator!\n+  template <typename U>\n+  static decltype(*(std::declval<U>())) test(std::input_iterator_tag);\n+  template <typename U> static char& test(std::output_iterator_tag);\n+  template <typename U> static const char& test(...);\n+\n+  using type = decltype(test<It>(typename iterator_category<It>::type{}));\n+\n+ public:\n+  static const bool value = !std::is_const<remove_reference_t<type>>::value;\n };\n-typedef std::numeric_limits<internal::dummy_int> fputil;\n-\n-// Dummy implementations of system functions called if the latter are not\n-// available.\n-inline dummy_int isinf(...) { return dummy_int(); }\n-inline dummy_int _finite(...) { return dummy_int(); }\n-inline dummy_int isnan(...) { return dummy_int(); }\n-inline dummy_int _isnan(...) { return dummy_int(); }\n-\n-template <typename Allocator>\n-typename Allocator::value_type *allocate(Allocator& alloc, std::size_t n) {\n-#if __cplusplus >= 201103L || FMT_MSC_VER >= 1700\n-  return std::allocator_traits<Allocator>::allocate(alloc, n);\n+\n+// A workaround for std::string not having mutable data() until C++17.\n+template <typename Char> inline Char* get_data(std::basic_string<Char>& s) {\n+  return &s[0];\n+}\n+template <typename Container>\n+inline typename Container::value_type* get_data(Container& c) {\n+  return c.data();\n+}\n+\n+#ifdef _SECURE_SCL\n+// Make a checked iterator to avoid MSVC warnings.\n+template <typename T> using checked_ptr = stdext::checked_array_iterator<T*>;\n+template <typename T> checked_ptr<T> make_checked(T* p, std::size_t size) {\n+  return {p, size};\n+}\n #else\n-  return alloc.allocate(n);\n+template <typename T> using checked_ptr = T*;\n+template <typename T> inline T* make_checked(T* p, std::size_t) { return p; }\n #endif\n+\n+template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>\n+inline checked_ptr<typename Container::value_type> reserve(\n+    std::back_insert_iterator<Container>& it, std::size_t n) {\n+  Container& c = get_container(it);\n+  std::size_t size = c.size();\n+  c.resize(size + n);\n+  return make_checked(get_data(c) + size, n);\n }\n \n-// A helper function to suppress bogus \"conditional expression is constant\"\n-// warnings.\n-template <typename T>\n-inline T const_check(T value) { return value; }\n-}  // namespace internal\n-FMT_END_NAMESPACE\n+template <typename Iterator>\n+inline Iterator& reserve(Iterator& it, std::size_t) {\n+  return it;\n+}\n+\n+// An output iterator that counts the number of objects written to it and\n+// discards them.\n+template <typename T> class counting_iterator {\n+ private:\n+  std::size_t count_;\n+  mutable T blackhole_;\n \n-namespace std {\n-// Standard permits specialization of std::numeric_limits. This specialization\n-// is used to resolve ambiguity between isinf and std::isinf in glibc:\n-// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48891\n-// and the same for isnan.\n-template <>\n-class numeric_limits<fmt::internal::dummy_int> :\n-    public std::numeric_limits<int> {\n  public:\n-  // Portable version of isinf.\n-  template <typename T>\n-  static bool isinfinity(T x) {\n-    using namespace fmt::internal;\n-    // The resolution \"priority\" is:\n-    // isinf macro > std::isinf > ::isinf > fmt::internal::isinf\n-    if (const_check(sizeof(isinf(x)) != sizeof(fmt::internal::dummy_int)))\n-      return isinf(x) != 0;\n-    return !_finite(static_cast<double>(x));\n-  }\n-\n-  // Portable version of isnan.\n-  template <typename T>\n-  static bool isnotanumber(T x) {\n-    using namespace fmt::internal;\n-    if (const_check(sizeof(isnan(x)) != sizeof(fmt::internal::dummy_int)))\n-      return isnan(x) != 0;\n-    return _isnan(static_cast<double>(x)) != 0;\n+  using iterator_category = std::output_iterator_tag;\n+  using value_type = T;\n+  using difference_type = std::ptrdiff_t;\n+  using pointer = T*;\n+  using reference = T&;\n+  using _Unchecked_type = counting_iterator;  // Mark iterator as checked.\n+\n+  counting_iterator() : count_(0) {}\n+\n+  std::size_t count() const { return count_; }\n+\n+  counting_iterator& operator++() {\n+    ++count_;\n+    return *this;\n+  }\n+\n+  counting_iterator operator++(int) {\n+    auto it = *this;\n+    ++*this;\n+    return it;\n   }\n+\n+  T& operator*() const { return blackhole_; }\n };\n-}  // namespace std\n \n-FMT_BEGIN_NAMESPACE\n-template <typename Range>\n-class basic_writer;\n+template <typename OutputIt> class truncating_iterator_base {\n+ protected:\n+  OutputIt out_;\n+  std::size_t limit_;\n+  std::size_t count_;\n \n-template <typename OutputIt, typename T = typename OutputIt::value_type>\n-class output_range {\n- private:\n-  OutputIt it_;\n+  truncating_iterator_base(OutputIt out, std::size_t limit)\n+      : out_(out), limit_(limit), count_(0) {}\n+\n+ public:\n+  using iterator_category = std::output_iterator_tag;\n+  using difference_type = void;\n+  using pointer = void;\n+  using reference = void;\n+  using _Unchecked_type =\n+      truncating_iterator_base;  // Mark iterator as checked.\n+\n+  OutputIt base() const { return out_; }\n+  std::size_t count() const { return count_; }\n+};\n+\n+// An output iterator that truncates the output and counts the number of objects\n+// written to it.\n+template <typename OutputIt,\n+          typename Enable = typename std::is_void<\n+              typename std::iterator_traits<OutputIt>::value_type>::type>\n+class truncating_iterator;\n+\n+template <typename OutputIt>\n+class truncating_iterator<OutputIt, std::false_type>\n+    : public truncating_iterator_base<OutputIt> {\n+  using traits = std::iterator_traits<OutputIt>;\n \n-  // Unused yet.\n-  typedef void sentinel;\n-  sentinel end() const;\n+  mutable typename traits::value_type blackhole_;\n \n  public:\n-  typedef OutputIt iterator;\n-  typedef T value_type;\n+  using value_type = typename traits::value_type;\n \n-  explicit output_range(OutputIt it): it_(it) {}\n-  OutputIt begin() const { return it_; }\n+  truncating_iterator(OutputIt out, std::size_t limit)\n+      : truncating_iterator_base<OutputIt>(out, limit) {}\n+\n+  truncating_iterator& operator++() {\n+    if (this->count_++ < this->limit_) ++this->out_;\n+    return *this;\n+  }\n+\n+  truncating_iterator operator++(int) {\n+    auto it = *this;\n+    ++*this;\n+    return it;\n+  }\n+\n+  value_type& operator*() const {\n+    return this->count_ < this->limit_ ? *this->out_ : blackhole_;\n+  }\n };\n \n-// A range where begin() returns back_insert_iterator.\n-template <typename Container>\n-class back_insert_range:\n-    public output_range<std::back_insert_iterator<Container>> {\n-  typedef output_range<std::back_insert_iterator<Container>> base;\n+template <typename OutputIt>\n+class truncating_iterator<OutputIt, std::true_type>\n+    : public truncating_iterator_base<OutputIt> {\n  public:\n-  typedef typename Container::value_type value_type;\n+  using value_type = typename OutputIt::container_type::value_type;\n+\n+  truncating_iterator(OutputIt out, std::size_t limit)\n+      : truncating_iterator_base<OutputIt>(out, limit) {}\n+\n+  truncating_iterator& operator=(value_type val) {\n+    if (this->count_++ < this->limit_) this->out_ = val;\n+    return *this;\n+  }\n \n-  back_insert_range(Container &c): base(std::back_inserter(c)) {}\n-  back_insert_range(typename base::iterator it): base(it) {}\n+  truncating_iterator& operator++() { return *this; }\n+  truncating_iterator& operator++(int) { return *this; }\n+  truncating_iterator& operator*() { return *this; }\n };\n \n-typedef basic_writer<back_insert_range<internal::buffer>> writer;\n-typedef basic_writer<back_insert_range<internal::wbuffer>> wwriter;\n+// A range with the specified output iterator and value type.\n+template <typename OutputIt, typename T = typename OutputIt::value_type>\n+class output_range {\n+ private:\n+  OutputIt it_;\n \n-/** A formatting error such as invalid format string. */\n-class format_error : public std::runtime_error {\n  public:\n-  explicit format_error(const char *message)\n-  : std::runtime_error(message) {}\n+  using value_type = T;\n+  using iterator = OutputIt;\n+  struct sentinel {};\n \n-  explicit format_error(const std::string &message)\n-  : std::runtime_error(message) {}\n+  explicit output_range(OutputIt it) : it_(it) {}\n+  OutputIt begin() const { return it_; }\n+  sentinel end() const { return {}; }  // Sentinel is not used yet.\n };\n \n-namespace internal {\n-\n-#if FMT_SECURE_SCL\n+// A range with an iterator appending to a buffer.\n template <typename T>\n-struct checked { typedef stdext::checked_array_iterator<T*> type; };\n+class buffer_range\n+    : public output_range<std::back_insert_iterator<buffer<T>>, T> {\n+ public:\n+  using iterator = std::back_insert_iterator<buffer<T>>;\n+  using output_range<iterator, T>::output_range;\n+  buffer_range(buffer<T>& buf)\n+      : output_range<iterator, T>(std::back_inserter(buf)) {}\n+};\n \n-// Make a checked iterator to avoid warnings on MSVC.\n-template <typename T>\n-inline stdext::checked_array_iterator<T*> make_checked(T *p, std::size_t size) {\n-  return {p, size};\n+template <typename Char>\n+inline size_t count_code_points(basic_string_view<Char> s) {\n+  return s.size();\n }\n-#else\n-template <typename T>\n-struct checked { typedef T *type; };\n-template <typename T>\n-inline T *make_checked(T *p, std::size_t) { return p; }\n+\n+// Counts the number of code points in a UTF-8 string.\n+inline size_t count_code_points(basic_string_view<char8_t> s) {\n+  const char8_t* data = s.data();\n+  size_t num_code_points = 0;\n+  for (size_t i = 0, size = s.size(); i != size; ++i) {\n+    if ((data[i] & 0xc0) != 0x80) ++num_code_points;\n+  }\n+  return num_code_points;\n+}\n+\n+inline char8_t to_char8_t(char c) { return static_cast<char8_t>(c); }\n+\n+template <typename InputIt, typename OutChar>\n+using needs_conversion = bool_constant<\n+    std::is_same<typename std::iterator_traits<InputIt>::value_type,\n+                 char>::value &&\n+    std::is_same<OutChar, char8_t>::value>;\n+\n+template <typename OutChar, typename InputIt, typename OutputIt,\n+          FMT_ENABLE_IF(!needs_conversion<InputIt, OutChar>::value)>\n+OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {\n+  return std::copy(begin, end, it);\n+}\n+\n+template <typename OutChar, typename InputIt, typename OutputIt,\n+          FMT_ENABLE_IF(needs_conversion<InputIt, OutChar>::value)>\n+OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {\n+  return std::transform(begin, end, it, to_char8_t);\n+}\n+\n+#ifndef FMT_USE_GRISU\n+#  define FMT_USE_GRISU 0\n #endif\n \n+template <typename T> constexpr bool use_grisu() {\n+  return FMT_USE_GRISU && std::numeric_limits<double>::is_iec559 &&\n+         sizeof(T) <= sizeof(double);\n+}\n+\n template <typename T>\n template <typename U>\n-void basic_buffer<T>::append(const U *begin, const U *end) {\n-  std::size_t new_size = size_ + internal::to_unsigned(end - begin);\n+void buffer<T>::append(const U* begin, const U* end) {\n+  std::size_t new_size = size_ + to_unsigned(end - begin);\n   reserve(new_size);\n-  std::uninitialized_copy(begin, end,\n-                          internal::make_checked(ptr_, capacity_) + size_);\n+  std::uninitialized_copy(begin, end, make_checked(ptr_, capacity_) + size_);\n   size_ = new_size;\n }\n }  // namespace internal\n \n-// C++20 feature test, since r346892 Clang considers char8_t a fundamental\n-// type in this mode. If this is the case __cpp_char8_t will be defined.\n-#if !defined(__cpp_char8_t)\n-// A UTF-8 code unit type.\n-enum char8_t: unsigned char {};\n-#endif\n-\n // A UTF-8 string view.\n class u8string_view : public basic_string_view<char8_t> {\n  public:\n-  typedef char8_t char_type;\n-\n-  u8string_view(const char *s):\n-    basic_string_view<char8_t>(reinterpret_cast<const char8_t*>(s)) {}\n-  u8string_view(const char *s, size_t count) FMT_NOEXCEPT:\n-    basic_string_view<char8_t>(reinterpret_cast<const char8_t*>(s), count) {}\n+  u8string_view(const char* s)\n+      : basic_string_view<char8_t>(reinterpret_cast<const char8_t*>(s)) {}\n+  u8string_view(const char* s, size_t count) FMT_NOEXCEPT\n+      : basic_string_view<char8_t>(reinterpret_cast<const char8_t*>(s), count) {\n+  }\n };\n \n #if FMT_USE_USER_DEFINED_LITERALS\n inline namespace literals {\n-inline u8string_view operator\"\" _u(const char *s, std::size_t n) {\n+inline u8string_view operator\"\" _u(const char* s, std::size_t n) {\n   return {s, n};\n }\n-}\n+}  // namespace literals\n #endif\n \n // The number of characters to store in the basic_memory_buffer object itself\n@@ -435,7 +505,7 @@ enum { inline_buffer_size = 500 };\n   A dynamically growing memory buffer for trivially copyable/constructible types\n   with the first ``SIZE`` elements stored in the object itself.\n \n-  You can use one of the following typedefs for common character types:\n+  You can use one of the following type aliases for common character types:\n \n   +----------------+------------------------------+\n   | Type           | Definition                   |\n@@ -460,8 +530,8 @@ enum { inline_buffer_size = 500 };\n   \\endrst\n  */\n template <typename T, std::size_t SIZE = inline_buffer_size,\n-          typename Allocator = std::allocator<T> >\n-class basic_memory_buffer: private Allocator, public internal::basic_buffer<T> {\n+          typename Allocator = std::allocator<T>>\n+class basic_memory_buffer : private Allocator, public internal::buffer<T> {\n  private:\n   T store_[SIZE];\n \n@@ -475,10 +545,10 @@ class basic_memory_buffer: private Allocator, public internal::basic_buffer<T> {\n   void grow(std::size_t size) FMT_OVERRIDE;\n \n  public:\n-  typedef T value_type;\n-  typedef const T &const_reference;\n+  using value_type = T;\n+  using const_reference = const T&;\n \n-  explicit basic_memory_buffer(const Allocator &alloc = Allocator())\n+  explicit basic_memory_buffer(const Allocator& alloc = Allocator())\n       : Allocator(alloc) {\n     this->set(store_, SIZE);\n   }\n@@ -486,7 +556,7 @@ class basic_memory_buffer: private Allocator, public internal::basic_buffer<T> {\n \n  private:\n   // Move data from other to this buffer.\n-  void move(basic_memory_buffer &other) {\n+  void move(basic_memory_buffer& other) {\n     Allocator &this_alloc = *this, &other_alloc = other;\n     this_alloc = std::move(other_alloc);\n     T* data = other.data();\n@@ -511,16 +581,14 @@ class basic_memory_buffer: private Allocator, public internal::basic_buffer<T> {\n     of the other object to it.\n     \\endrst\n    */\n-  basic_memory_buffer(basic_memory_buffer &&other) {\n-    move(other);\n-  }\n+  basic_memory_buffer(basic_memory_buffer&& other) { move(other); }\n \n   /**\n     \\rst\n     Moves the content of the other ``basic_memory_buffer`` object to this one.\n     \\endrst\n    */\n-  basic_memory_buffer &operator=(basic_memory_buffer &&other) {\n+  basic_memory_buffer& operator=(basic_memory_buffer&& other) {\n     assert(this != &other);\n     deallocate();\n     move(other);\n@@ -533,12 +601,14 @@ class basic_memory_buffer: private Allocator, public internal::basic_buffer<T> {\n \n template <typename T, std::size_t SIZE, typename Allocator>\n void basic_memory_buffer<T, SIZE, Allocator>::grow(std::size_t size) {\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+  if (size > 1000) throw std::runtime_error(\"fuzz mode - won't grow that much\");\n+#endif\n   std::size_t old_capacity = this->capacity();\n   std::size_t new_capacity = old_capacity + old_capacity / 2;\n-  if (size > new_capacity)\n-      new_capacity = size;\n-  T *old_data = this->data();\n-  T *new_data = internal::allocate<Allocator>(*this, new_capacity);\n+  if (size > new_capacity) new_capacity = size;\n+  T* old_data = this->data();\n+  T* new_data = std::allocator_traits<Allocator>::allocate(*this, new_capacity);\n   // The following code doesn't throw, so the raw pointer above doesn't leak.\n   std::uninitialized_copy(old_data, old_data + this->size(),\n                           internal::make_checked(new_data, new_capacity));\n@@ -546,290 +616,109 @@ void basic_memory_buffer<T, SIZE, Allocator>::grow(std::size_t size) {\n   // deallocate must not throw according to the standard, but even if it does,\n   // the buffer already uses the new storage and will deallocate it in\n   // destructor.\n-  if (old_data != store_)\n-    Allocator::deallocate(old_data, old_capacity);\n+  if (old_data != store_) Allocator::deallocate(old_data, old_capacity);\n }\n \n-typedef basic_memory_buffer<char> memory_buffer;\n-typedef basic_memory_buffer<wchar_t> wmemory_buffer;\n-\n-namespace internal {\n-\n-template <typename Char>\n-struct char_traits;\n-\n-template <>\n-struct char_traits<char> {\n-  // Formats a floating-point number.\n-  template <typename T>\n-  FMT_API static int format_float(char *buffer, std::size_t size,\n-      const char *format, int precision, T value);\n-};\n+using memory_buffer = basic_memory_buffer<char>;\n+using wmemory_buffer = basic_memory_buffer<wchar_t>;\n \n-template <>\n-struct char_traits<wchar_t> {\n-  template <typename T>\n-  FMT_API static int format_float(wchar_t *buffer, std::size_t size,\n-      const wchar_t *format, int precision, T value);\n+/** A formatting error such as invalid format string. */\n+class FMT_API format_error : public std::runtime_error {\n+ public:\n+  explicit format_error(const char* message) : std::runtime_error(message) {}\n+  explicit format_error(const std::string& message)\n+      : std::runtime_error(message) {}\n+  ~format_error() FMT_NOEXCEPT;\n };\n \n-#if FMT_USE_EXTERN_TEMPLATES\n-extern template int char_traits<char>::format_float<double>(\n-    char *buffer, std::size_t size, const char* format, int precision,\n-    double value);\n-extern template int char_traits<char>::format_float<long double>(\n-    char *buffer, std::size_t size, const char* format, int precision,\n-    long double value);\n-\n-extern template int char_traits<wchar_t>::format_float<double>(\n-    wchar_t *buffer, std::size_t size, const wchar_t* format, int precision,\n-    double value);\n-extern template int char_traits<wchar_t>::format_float<long double>(\n-    wchar_t *buffer, std::size_t size, const wchar_t* format, int precision,\n-    long double value);\n-#endif\n+namespace internal {\n \n-template <typename Container>\n-inline typename std::enable_if<\n-  is_contiguous<Container>::value,\n-  typename checked<typename Container::value_type>::type>::type\n-    reserve(std::back_insert_iterator<Container> &it, std::size_t n) {\n-  Container &c = internal::get_container(it);\n-  std::size_t size = c.size();\n-  c.resize(size + n);\n-  return make_checked(&c[size], n);\n+// Returns true if value is negative, false otherwise.\n+// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.\n+template <typename T, FMT_ENABLE_IF(std::numeric_limits<T>::is_signed)>\n+FMT_CONSTEXPR bool is_negative(T value) {\n+  return value < 0;\n+}\n+template <typename T, FMT_ENABLE_IF(!std::numeric_limits<T>::is_signed)>\n+FMT_CONSTEXPR bool is_negative(T) {\n+  return false;\n }\n \n-template <typename Iterator>\n-inline Iterator &reserve(Iterator &it, std::size_t) { return it; }\n-\n-template <typename Char>\n-class null_terminating_iterator;\n-\n-template <typename Char>\n-FMT_CONSTEXPR_DECL const Char *pointer_from(null_terminating_iterator<Char> it);\n-\n-// An output iterator that counts the number of objects written to it and\n-// discards them.\n+// Smallest of uint32_t and uint64_t that is large enough to represent all\n+// values of T.\n template <typename T>\n-class counting_iterator {\n- private:\n-  std::size_t count_;\n-  mutable T blackhole_;\n+using uint32_or_64_t =\n+    conditional_t<std::numeric_limits<T>::digits <= 32, uint32_t, uint64_t>;\n \n- public:\n-  typedef std::output_iterator_tag iterator_category;\n-  typedef T value_type;\n-  typedef std::ptrdiff_t difference_type;\n-  typedef T* pointer;\n-  typedef T& reference;\n-  typedef counting_iterator _Unchecked_type;  // Mark iterator as checked.\n+// Static data is placed in this class template for the header-only config.\n+template <typename T = void> struct FMT_EXTERN_TEMPLATE_API basic_data {\n+  static const uint64_t powers_of_10_64[];\n+  static const uint32_t zero_or_powers_of_10_32[];\n+  static const uint64_t zero_or_powers_of_10_64[];\n+  static const uint64_t pow10_significands[];\n+  static const int16_t pow10_exponents[];\n+  static const char digits[];\n+  static const char hex_digits[];\n+  static const char foreground_color[];\n+  static const char background_color[];\n+  static const char reset_color[5];\n+  static const wchar_t wreset_color[5];\n+};\n \n-  counting_iterator(): count_(0) {}\n+FMT_EXTERN template struct basic_data<void>;\n \n-  std::size_t count() const { return count_; }\n+// This is a struct rather than an alias to avoid shadowing warnings in gcc.\n+struct data : basic_data<> {};\n \n-  counting_iterator& operator++() {\n-    ++count_;\n-    return *this;\n+#ifdef FMT_BUILTIN_CLZLL\n+// Returns the number of decimal digits in n. Leading zeros are not counted\n+// except for n == 0 in which case count_digits returns 1.\n+inline int count_digits(uint64_t n) {\n+  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n+  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.\n+  int t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;\n+  return t - (n < data::zero_or_powers_of_10_64[t]) + 1;\n+}\n+#else\n+// Fallback version of count_digits used when __builtin_clz is not available.\n+inline int count_digits(uint64_t n) {\n+  int count = 1;\n+  for (;;) {\n+    // Integer division is slow so do it for a group of four digits instead\n+    // of for every digit. The idea comes from the talk by Alexandrescu\n+    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n+    if (n < 10) return count;\n+    if (n < 100) return count + 1;\n+    if (n < 1000) return count + 2;\n+    if (n < 10000) return count + 3;\n+    n /= 10000u;\n+    count += 4;\n   }\n+}\n+#endif\n \n-  counting_iterator operator++(int) {\n-    auto it = *this;\n-    ++*this;\n-    return it;\n-  }\n+// Counts the number of digits in n. BITS = log2(radix).\n+template <unsigned BITS, typename UInt> inline int count_digits(UInt n) {\n+  int num_digits = 0;\n+  do {\n+    ++num_digits;\n+  } while ((n >>= BITS) != 0);\n+  return num_digits;\n+}\n \n-  T &operator*() const { return blackhole_; }\n-};\n-\n-template <typename OutputIt>\n-class truncating_iterator_base {\n- protected:\n-  OutputIt out_;\n-  std::size_t limit_;\n-  std::size_t count_;\n-\n-  truncating_iterator_base(OutputIt out, std::size_t limit)\n-    : out_(out), limit_(limit), count_(0) {}\n-\n- public:\n-  typedef std::output_iterator_tag iterator_category;\n-  typedef void difference_type;\n-  typedef void pointer;\n-  typedef void reference;\n-  typedef truncating_iterator_base _Unchecked_type; // Mark iterator as checked.\n-\n-  OutputIt base() const { return out_; }\n-  std::size_t count() const { return count_; }\n-};\n-\n-// An output iterator that truncates the output and counts the number of objects\n-// written to it.\n-template <typename OutputIt, typename Enable = typename std::is_void<\n-    typename std::iterator_traits<OutputIt>::value_type>::type>\n-class truncating_iterator;\n-\n-template <typename OutputIt>\n-class truncating_iterator<OutputIt, std::false_type>:\n-  public truncating_iterator_base<OutputIt> {\n-  typedef std::iterator_traits<OutputIt> traits;\n-\n-  mutable typename traits::value_type blackhole_;\n-\n- public:\n-  typedef typename traits::value_type value_type;\n-\n-  truncating_iterator(OutputIt out, std::size_t limit)\n-    : truncating_iterator_base<OutputIt>(out, limit) {}\n-\n-  truncating_iterator& operator++() {\n-    if (this->count_++ < this->limit_)\n-      ++this->out_;\n-    return *this;\n-  }\n-\n-  truncating_iterator operator++(int) {\n-    auto it = *this;\n-    ++*this;\n-    return it;\n-  }\n-\n-  value_type& operator*() const {\n-    return this->count_ < this->limit_ ? *this->out_ : blackhole_;\n-  }\n-};\n-\n-template <typename OutputIt>\n-class truncating_iterator<OutputIt, std::true_type>:\n-  public truncating_iterator_base<OutputIt> {\n- public:\n-  typedef typename OutputIt::container_type::value_type value_type;\n-\n-  truncating_iterator(OutputIt out, std::size_t limit)\n-    : truncating_iterator_base<OutputIt>(out, limit) {}\n-\n-  truncating_iterator& operator=(value_type val) {\n-    if (this->count_++ < this->limit_)\n-      this->out_ = val;\n-    return *this;\n-  }\n-\n-  truncating_iterator& operator++() { return *this; }\n-  truncating_iterator& operator++(int) { return *this; }\n-  truncating_iterator& operator*() { return *this; }\n-};\n-\n-// Returns true if value is negative, false otherwise.\n-// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.\n-template <typename T>\n-FMT_CONSTEXPR typename std::enable_if<\n-    std::numeric_limits<T>::is_signed, bool>::type is_negative(T value) {\n-  return value < 0;\n-}\n-template <typename T>\n-FMT_CONSTEXPR typename std::enable_if<\n-    !std::numeric_limits<T>::is_signed, bool>::type is_negative(T) {\n-  return false;\n-}\n-\n-template <typename T>\n-struct int_traits {\n-  // Smallest of uint32_t and uint64_t that is large enough to represent\n-  // all values of T.\n-  typedef typename std::conditional<\n-    std::numeric_limits<T>::digits <= 32, uint32_t, uint64_t>::type main_type;\n-};\n-\n-// Static data is placed in this class template to allow header-only\n-// configuration.\n-template <typename T = void>\n-struct FMT_API basic_data {\n-  static const uint32_t POWERS_OF_10_32[];\n-  static const uint32_t ZERO_OR_POWERS_OF_10_32[];\n-  static const uint64_t ZERO_OR_POWERS_OF_10_64[];\n-  static const uint64_t POW10_SIGNIFICANDS[];\n-  static const int16_t POW10_EXPONENTS[];\n-  static const char DIGITS[];\n-  static const char FOREGROUND_COLOR[];\n-  static const char BACKGROUND_COLOR[];\n-  static const char RESET_COLOR[];\n-  static const wchar_t WRESET_COLOR[];\n-};\n-\n-#if FMT_USE_EXTERN_TEMPLATES\n-extern template struct basic_data<void>;\n-#endif\n-\n-typedef basic_data<> data;\n-\n-#ifdef FMT_BUILTIN_CLZLL\n-// Returns the number of decimal digits in n. Leading zeros are not counted\n-// except for n == 0 in which case count_digits returns 1.\n-inline int count_digits(uint64_t n) {\n-  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n-  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.\n-  int t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;\n-  return t - (n < data::ZERO_OR_POWERS_OF_10_64[t]) + 1;\n-}\n-#else\n-// Fallback version of count_digits used when __builtin_clz is not available.\n-inline int count_digits(uint64_t n) {\n-  int count = 1;\n-  for (;;) {\n-    // Integer division is slow so do it for a group of four digits instead\n-    // of for every digit. The idea comes from the talk by Alexandrescu\n-    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n-    if (n < 10) return count;\n-    if (n < 100) return count + 1;\n-    if (n < 1000) return count + 2;\n-    if (n < 10000) return count + 3;\n-    n /= 10000u;\n-    count += 4;\n-  }\n-}\n-#endif\n-\n-template <typename Char>\n-inline size_t count_code_points(basic_string_view<Char> s) { return s.size(); }\n-\n-// Counts the number of code points in a UTF-8 string.\n-FMT_API size_t count_code_points(basic_string_view<char8_t> s);\n-\n-inline char8_t to_char8_t(char c) { return static_cast<char8_t>(c); }\n-\n-template <typename InputIt, typename OutChar>\n-struct needs_conversion: std::integral_constant<bool,\n-  std::is_same<\n-    typename std::iterator_traits<InputIt>::value_type, char>::value &&\n-  std::is_same<OutChar, char8_t>::value> {};\n-\n-template <typename OutChar, typename InputIt, typename OutputIt>\n-typename std::enable_if<\n-  !needs_conversion<InputIt, OutChar>::value, OutputIt>::type\n-    copy_str(InputIt begin, InputIt end, OutputIt it) {\n-  return std::copy(begin, end, it);\n-}\n-\n-template <typename OutChar, typename InputIt, typename OutputIt>\n-typename std::enable_if<\n-  needs_conversion<InputIt, OutChar>::value, OutputIt>::type\n-    copy_str(InputIt begin, InputIt end, OutputIt it) {\n-  return std::transform(begin, end, it, to_char8_t);\n-}\n+template <> int count_digits<4>(internal::fallback_uintptr n);\n \n #if FMT_HAS_CPP_ATTRIBUTE(always_inline)\n-# define FMT_ALWAYS_INLINE __attribute__((always_inline))\n+#  define FMT_ALWAYS_INLINE __attribute__((always_inline))\n #else\n-# define FMT_ALWAYS_INLINE\n+#  define FMT_ALWAYS_INLINE\n #endif\n \n template <typename Handler>\n-inline char *lg(uint32_t n, Handler h) FMT_ALWAYS_INLINE;\n+inline char* lg(uint32_t n, Handler h) FMT_ALWAYS_INLINE;\n \n // Computes g = floor(log10(n)) and calls h.on<g>(n);\n-template <typename Handler>\n-inline char *lg(uint32_t n, Handler h) {\n+template <typename Handler> inline char* lg(uint32_t n, Handler h) {\n   return n < 100 ? n < 10 ? h.template on<0>(n) : h.template on<1>(n)\n                  : n < 1000000\n                        ? n < 10000 ? n < 1000 ? h.template on<2>(n)\n@@ -846,16 +735,16 @@ inline char *lg(uint32_t n, Handler h) {\n // Usage: lg(n, decimal_formatter(buffer));\n class decimal_formatter {\n  private:\n-  char *buffer_;\n+  char* buffer_;\n \n   void write_pair(unsigned N, uint32_t index) {\n-    std::memcpy(buffer_ + N, data::DIGITS + index * 2, 2);\n+    std::memcpy(buffer_ + N, data::digits + index * 2, 2);\n   }\n \n  public:\n-  explicit decimal_formatter(char *buf) : buffer_(buf) {}\n+  explicit decimal_formatter(char* buf) : buffer_(buf) {}\n \n-  template <unsigned N> char *on(uint32_t u) {\n+  template <unsigned N> char* on(uint32_t u) {\n     if (N == 0) {\n       *buffer_ = static_cast<char>(u) + '0';\n     } else if (N == 1) {\n@@ -865,8 +754,8 @@ class decimal_formatter {\n       // https://github.com/jeaiii/itoa\n       unsigned n = N - 1;\n       unsigned a = n / 5 * n * 53 / 16;\n-      uint64_t t = ((1ULL << (32 + a)) /\n-                   data::ZERO_OR_POWERS_OF_10_32[n] + 1 - n / 9);\n+      uint64_t t =\n+          ((1ULL << (32 + a)) / data::zero_or_powers_of_10_32[n] + 1 - n / 9);\n       t = ((t * u) >> a) + n / 5 * 4;\n       write_pair(0, t >> 32);\n       for (unsigned i = 2; i < N; i += 2) {\n@@ -874,140 +763,92 @@ class decimal_formatter {\n         write_pair(i, t >> 32);\n       }\n       if (N % 2 == 0) {\n-        buffer_[N] = static_cast<char>(\n-          (10ULL * static_cast<uint32_t>(t)) >> 32) + '0';\n+        buffer_[N] =\n+            static_cast<char>((10ULL * static_cast<uint32_t>(t)) >> 32) + '0';\n       }\n     }\n     return buffer_ += N + 1;\n   }\n };\n \n-// An lg handler that formats a decimal number with a terminating null.\n-class decimal_formatter_null : public decimal_formatter {\n- public:\n-  explicit decimal_formatter_null(char *buf) : decimal_formatter(buf) {}\n-\n-  template <unsigned N> char *on(uint32_t u) {\n-    char *buf = decimal_formatter::on<N>(u);\n-    *buf = '\\0';\n-    return buf;\n-  }\n-};\n-\n #ifdef FMT_BUILTIN_CLZ\n // Optional version of count_digits for better performance on 32-bit platforms.\n inline int count_digits(uint32_t n) {\n   int t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 >> 12;\n-  return t - (n < data::ZERO_OR_POWERS_OF_10_32[t]) + 1;\n+  return t - (n < data::zero_or_powers_of_10_32[t]) + 1;\n }\n #endif\n \n-// A functor that doesn't add a thousands separator.\n-struct no_thousands_sep {\n-  typedef char char_type;\n-\n-  template <typename Char>\n-  void operator()(Char *) {}\n-\n-  enum { size = 0 };\n-};\n-\n-// A functor that adds a thousands separator.\n-template <typename Char>\n-class add_thousands_sep {\n- private:\n-  basic_string_view<Char> sep_;\n-\n-  // Index of a decimal digit with the least significant digit having index 0.\n-  unsigned digit_index_;\n-\n- public:\n-  typedef Char char_type;\n-\n-  explicit add_thousands_sep(basic_string_view<Char> sep)\n-    : sep_(sep), digit_index_(0) {}\n-\n-  void operator()(Char *&buffer) {\n-    if (++digit_index_ % 3 != 0)\n-      return;\n-    buffer -= sep_.size();\n-    std::uninitialized_copy(sep_.data(), sep_.data() + sep_.size(),\n-                            internal::make_checked(buffer, sep_.size()));\n-  }\n-\n-  enum { size = 1 };\n-};\n-\n-template <typename Char>\n-FMT_API Char thousands_sep_impl(locale_ref loc);\n-\n-template <typename Char>\n-inline Char thousands_sep(locale_ref loc) {\n+template <typename Char> FMT_API Char thousands_sep_impl(locale_ref loc);\n+template <typename Char> inline Char thousands_sep(locale_ref loc) {\n   return Char(thousands_sep_impl<char>(loc));\n }\n-\n-template <>\n-inline wchar_t thousands_sep(locale_ref loc) {\n+template <> inline wchar_t thousands_sep(locale_ref loc) {\n   return thousands_sep_impl<wchar_t>(loc);\n }\n \n+template <typename Char> FMT_API Char decimal_point_impl(locale_ref loc);\n+template <typename Char> inline Char decimal_point(locale_ref loc) {\n+  return Char(decimal_point_impl<char>(loc));\n+}\n+template <> inline wchar_t decimal_point(locale_ref loc) {\n+  return decimal_point_impl<wchar_t>(loc);\n+}\n+\n // Formats a decimal unsigned integer value writing into buffer.\n-// thousands_sep is a functor that is called after writing each char to\n-// add a thousands separator if necessary.\n-template <typename UInt, typename Char, typename ThousandsSep>\n-inline Char *format_decimal(Char *buffer, UInt value, int num_digits,\n-                            ThousandsSep thousands_sep) {\n+// add_thousands_sep is called after writing each char to add a thousands\n+// separator if necessary.\n+template <typename UInt, typename Char, typename F>\n+inline Char* format_decimal(Char* buffer, UInt value, int num_digits,\n+                            F add_thousands_sep) {\n   FMT_ASSERT(num_digits >= 0, \"invalid digit count\");\n   buffer += num_digits;\n-  Char *end = buffer;\n+  Char* end = buffer;\n   while (value >= 100) {\n     // Integer division is slow so do it for a group of two digits instead\n     // of for every digit. The idea comes from the talk by Alexandrescu\n     // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n     unsigned index = static_cast<unsigned>((value % 100) * 2);\n     value /= 100;\n-    *--buffer = static_cast<Char>(data::DIGITS[index + 1]);\n-    thousands_sep(buffer);\n-    *--buffer = static_cast<Char>(data::DIGITS[index]);\n-    thousands_sep(buffer);\n+    *--buffer = static_cast<Char>(data::digits[index + 1]);\n+    add_thousands_sep(buffer);\n+    *--buffer = static_cast<Char>(data::digits[index]);\n+    add_thousands_sep(buffer);\n   }\n   if (value < 10) {\n     *--buffer = static_cast<Char>('0' + value);\n     return end;\n   }\n   unsigned index = static_cast<unsigned>(value * 2);\n-  *--buffer = static_cast<Char>(data::DIGITS[index + 1]);\n-  thousands_sep(buffer);\n-  *--buffer = static_cast<Char>(data::DIGITS[index]);\n+  *--buffer = static_cast<Char>(data::digits[index + 1]);\n+  add_thousands_sep(buffer);\n+  *--buffer = static_cast<Char>(data::digits[index]);\n   return end;\n }\n \n-template <typename OutChar, typename UInt, typename Iterator,\n-          typename ThousandsSep>\n-inline Iterator format_decimal(\n-    Iterator out, UInt value, int num_digits, ThousandsSep sep) {\n+template <typename Char, typename UInt, typename Iterator, typename F>\n+inline Iterator format_decimal(Iterator out, UInt value, int num_digits,\n+                               F add_thousands_sep) {\n   FMT_ASSERT(num_digits >= 0, \"invalid digit count\");\n-  typedef typename ThousandsSep::char_type char_type;\n   // Buffer should be large enough to hold all digits (<= digits10 + 1).\n   enum { max_size = std::numeric_limits<UInt>::digits10 + 1 };\n-  FMT_ASSERT(ThousandsSep::size <= 1, \"invalid separator\");\n-  char_type buffer[max_size + max_size / 3];\n-  auto end = format_decimal(buffer, value, num_digits, sep);\n-  return internal::copy_str<OutChar>(buffer, end, out);\n+  Char buffer[max_size + max_size / 3];\n+  auto end = format_decimal(buffer, value, num_digits, add_thousands_sep);\n+  return internal::copy_str<Char>(buffer, end, out);\n }\n \n-template <typename OutChar, typename It, typename UInt>\n+template <typename Char, typename It, typename UInt>\n inline It format_decimal(It out, UInt value, int num_digits) {\n-  return format_decimal<OutChar>(out, value, num_digits, no_thousands_sep());\n+  return format_decimal<Char>(out, value, num_digits, [](Char*) {});\n }\n \n template <unsigned BASE_BITS, typename Char, typename UInt>\n-inline Char *format_uint(Char *buffer, UInt value, int num_digits,\n+inline Char* format_uint(Char* buffer, UInt value, int num_digits,\n                          bool upper = false) {\n   buffer += num_digits;\n-  Char *end = buffer;\n+  Char* end = buffer;\n   do {\n-    const char *digits = upper ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n+    const char* digits = upper ? \"0123456789ABCDEF\" : data::hex_digits;\n     unsigned digit = (value & ((1 << BASE_BITS) - 1));\n     *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)\n                                                 : digits[digit]);\n@@ -1015,20 +856,40 @@ inline Char *format_uint(Char *buffer, UInt value, int num_digits,\n   return end;\n }\n \n+template <unsigned BASE_BITS, typename Char>\n+Char* format_uint(Char* buffer, internal::fallback_uintptr n, int num_digits,\n+                  bool = false) {\n+  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;\n+  int start = (num_digits + char_digits - 1) / char_digits - 1;\n+  if (int start_digits = num_digits % char_digits) {\n+    unsigned value = n.value[start--];\n+    buffer = format_uint<BASE_BITS>(buffer, value, start_digits);\n+  }\n+  for (; start >= 0; --start) {\n+    unsigned value = n.value[start];\n+    buffer += char_digits;\n+    auto p = buffer;\n+    for (int i = 0; i < char_digits; ++i) {\n+      unsigned digit = (value & ((1 << BASE_BITS) - 1));\n+      *--p = static_cast<Char>(data::hex_digits[digit]);\n+      value >>= BASE_BITS;\n+    }\n+  }\n+  return buffer;\n+}\n+\n template <unsigned BASE_BITS, typename Char, typename It, typename UInt>\n-inline It format_uint(It out, UInt value, int num_digits,\n-                      bool upper = false) {\n-  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1)\n-  // and null.\n-  char buffer[std::numeric_limits<UInt>::digits / BASE_BITS + 2];\n+inline It format_uint(It out, UInt value, int num_digits, bool upper = false) {\n+  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).\n+  char buffer[std::numeric_limits<UInt>::digits / BASE_BITS + 1];\n   format_uint<BASE_BITS>(buffer, value, num_digits, upper);\n   return internal::copy_str<Char>(buffer, buffer + num_digits, out);\n }\n \n #ifndef _WIN32\n-# define FMT_USE_WINDOWS_H 0\n+#  define FMT_USE_WINDOWS_H 0\n #elif !defined(FMT_USE_WINDOWS_H)\n-# define FMT_USE_WINDOWS_H 1\n+#  define FMT_USE_WINDOWS_H 1\n #endif\n \n // Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.\n@@ -1044,7 +905,7 @@ class utf8_to_utf16 {\n   FMT_API explicit utf8_to_utf16(string_view s);\n   operator wstring_view() const { return wstring_view(&buffer_[0], size()); }\n   size_t size() const { return buffer_.size() - 1; }\n-  const wchar_t *c_str() const { return &buffer_[0]; }\n+  const wchar_t* c_str() const { return &buffer_[0]; }\n   std::wstring str() const { return std::wstring(&buffer_[0], size()); }\n };\n \n@@ -1059,7 +920,7 @@ class utf16_to_utf8 {\n   FMT_API explicit utf16_to_utf8(wstring_view s);\n   operator string_view() const { return string_view(&buffer_[0], size()); }\n   size_t size() const { return buffer_.size() - 1; }\n-  const char *c_str() const { return &buffer_[0]; }\n+  const char* c_str() const { return &buffer_[0]; }\n   std::string str() const { return std::string(&buffer_[0], size()); }\n \n   // Performs conversion returning a system error code instead of\n@@ -1068,84 +929,198 @@ class utf16_to_utf8 {\n   FMT_API int convert(wstring_view s);\n };\n \n-FMT_API void format_windows_error(fmt::internal::buffer &out, int error_code,\n+FMT_API void format_windows_error(fmt::internal::buffer<char>& out,\n+                                  int error_code,\n                                   fmt::string_view message) FMT_NOEXCEPT;\n #endif\n \n-template <typename T = void>\n-struct null {};\n-}  // namespace internal\n+template <typename T = void> struct null {};\n \n-enum alignment {\n-  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC\n-};\n+// Workaround an array initialization issue in gcc 4.8.\n+template <typename Char> struct fill_t {\n+ private:\n+  Char data_[6];\n \n-// Flags.\n-enum { SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8 };\n-\n-// An alignment specifier.\n-struct align_spec {\n-  unsigned width_;\n-  // Fill is always wchar_t and cast to char if necessary to avoid having\n-  // two specialization of AlignSpec and its subclasses.\n-  wchar_t fill_;\n-  alignment align_;\n-\n-  FMT_CONSTEXPR align_spec() : width_(0), fill_(' '), align_(ALIGN_DEFAULT) {}\n-  FMT_CONSTEXPR unsigned width() const { return width_; }\n-  FMT_CONSTEXPR wchar_t fill() const { return fill_; }\n-  FMT_CONSTEXPR alignment align() const { return align_; }\n+ public:\n+  FMT_CONSTEXPR Char& operator[](size_t index) { return data_[index]; }\n+  FMT_CONSTEXPR const Char& operator[](size_t index) const {\n+    return data_[index];\n+  }\n+\n+  static FMT_CONSTEXPR fill_t<Char> make() {\n+    auto fill = fill_t<Char>();\n+    fill[0] = Char(' ');\n+    return fill;\n+  }\n };\n+}  // namespace internal\n+\n+// We cannot use enum classes as bit fields because of a gcc bug\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414.\n+namespace align {\n+enum type { none, left, right, center, numeric };\n+}\n+using align_t = align::type;\n+\n+namespace sign {\n+enum type { none, minus, plus, space };\n+}\n+using sign_t = sign::type;\n \n-struct core_format_specs {\n+// Format specifiers for built-in and string types.\n+template <typename Char> struct basic_format_specs {\n+  int width;\n   int precision;\n-  uint_least8_t flags;\n   char type;\n+  align_t align : 4;\n+  sign_t sign : 3;\n+  bool alt : 1;  // Alternate form ('#').\n+  internal::fill_t<Char> fill;\n \n-  FMT_CONSTEXPR core_format_specs() : precision(-1), flags(0), type(0) {}\n-  FMT_CONSTEXPR bool has(unsigned f) const { return (flags & f) != 0; }\n+  constexpr basic_format_specs()\n+      : width(0),\n+        precision(-1),\n+        type(0),\n+        align(align::none),\n+        sign(sign::none),\n+        alt(false),\n+        fill(internal::fill_t<Char>::make()) {}\n };\n \n-// Format specifiers.\n-template <typename Char>\n-struct basic_format_specs : align_spec, core_format_specs {\n-  FMT_CONSTEXPR basic_format_specs() {}\n-};\n+using format_specs = basic_format_specs<char>;\n+\n+namespace internal {\n \n-typedef basic_format_specs<char> format_specs;\n+// Writes the exponent exp in the form \"[+-]d{2,3}\" to buffer.\n+template <typename Char, typename It> It write_exponent(int exp, It it) {\n+  FMT_ASSERT(-1000 < exp && exp < 1000, \"exponent out of range\");\n+  if (exp < 0) {\n+    *it++ = static_cast<Char>('-');\n+    exp = -exp;\n+  } else {\n+    *it++ = static_cast<Char>('+');\n+  }\n+  if (exp >= 100) {\n+    *it++ = static_cast<Char>(static_cast<char>('0' + exp / 100));\n+    exp %= 100;\n+  }\n+  const char* d = data::digits + exp * 2;\n+  *it++ = static_cast<Char>(d[0]);\n+  *it++ = static_cast<Char>(d[1]);\n+  return it;\n+}\n \n-template <typename Char, typename ErrorHandler>\n-FMT_CONSTEXPR unsigned basic_parse_context<Char, ErrorHandler>::next_arg_id() {\n-  if (next_arg_id_ >= 0)\n-    return internal::to_unsigned(next_arg_id_++);\n-  on_error(\"cannot switch from manual to automatic argument indexing\");\n-  return 0;\n+struct gen_digits_params {\n+  int num_digits;\n+  bool fixed;\n+  bool upper;\n+  bool trailing_zeros;\n+};\n+\n+// The number is given as v = digits * pow(10, exp).\n+template <typename Char, typename It>\n+It grisu_prettify(const char* digits, int size, int exp, It it,\n+                  gen_digits_params params, Char decimal_point) {\n+  // pow(10, full_exp - 1) <= v <= pow(10, full_exp).\n+  int full_exp = size + exp;\n+  if (!params.fixed) {\n+    // Insert a decimal point after the first digit and add an exponent.\n+    *it++ = static_cast<Char>(*digits);\n+    if (size > 1) *it++ = decimal_point;\n+    exp += size - 1;\n+    it = copy_str<Char>(digits + 1, digits + size, it);\n+    if (size < params.num_digits)\n+      it = std::fill_n(it, params.num_digits - size, static_cast<Char>('0'));\n+    *it++ = static_cast<Char>(params.upper ? 'E' : 'e');\n+    return write_exponent<Char>(exp, it);\n+  }\n+  if (size <= full_exp) {\n+    // 1234e7 -> 12340000000[.0+]\n+    it = copy_str<Char>(digits, digits + size, it);\n+    it = std::fill_n(it, full_exp - size, static_cast<Char>('0'));\n+    int num_zeros = (std::max)(params.num_digits - full_exp, 1);\n+    if (params.trailing_zeros) {\n+      *it++ = decimal_point;\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+      if (num_zeros > 1000)\n+        throw std::runtime_error(\"fuzz mode - avoiding excessive cpu use\");\n+#endif\n+      it = std::fill_n(it, num_zeros, static_cast<Char>('0'));\n+    }\n+  } else if (full_exp > 0) {\n+    // 1234e-2 -> 12.34[0+]\n+    it = copy_str<Char>(digits, digits + full_exp, it);\n+    if (!params.trailing_zeros) {\n+      // Remove trailing zeros.\n+      while (size > full_exp && digits[size - 1] == '0') --size;\n+      if (size != full_exp) *it++ = decimal_point;\n+      return copy_str<Char>(digits + full_exp, digits + size, it);\n+    }\n+    *it++ = decimal_point;\n+    it = copy_str<Char>(digits + full_exp, digits + size, it);\n+    if (params.num_digits > size) {\n+      // Add trailing zeros.\n+      int num_zeros = params.num_digits - size;\n+      it = std::fill_n(it, num_zeros, static_cast<Char>('0'));\n+    }\n+  } else {\n+    // 1234e-6 -> 0.001234\n+    *it++ = static_cast<Char>('0');\n+    int num_zeros = -full_exp;\n+    if (params.num_digits >= 0 && params.num_digits < num_zeros)\n+      num_zeros = params.num_digits;\n+    if (!params.trailing_zeros)\n+      while (size > 0 && digits[size - 1] == '0') --size;\n+    if (num_zeros != 0 || size != 0) {\n+      *it++ = decimal_point;\n+      it = std::fill_n(it, num_zeros, static_cast<Char>('0'));\n+      it = copy_str<Char>(digits, digits + size, it);\n+    }\n+  }\n+  return it;\n }\n \n-namespace internal {\n+namespace grisu_options {\n+enum { fixed = 1, grisu3 = 2 };\n+}\n \n-// Formats value using Grisu2 algorithm:\n+// Formats value using the Grisu algorithm:\n // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf\n-template <typename Double>\n-FMT_API typename std::enable_if<sizeof(Double) == sizeof(uint64_t), bool>::type\n-  grisu2_format(Double value, buffer &buf, core_format_specs);\n-template <typename Double>\n-inline typename std::enable_if<sizeof(Double) != sizeof(uint64_t), bool>::type\n-  grisu2_format(Double, buffer &, core_format_specs) { return false; }\n+template <typename Double, FMT_ENABLE_IF(sizeof(Double) == sizeof(uint64_t))>\n+FMT_API bool grisu_format(Double, buffer<char>&, int, unsigned, int&);\n+template <typename Double, FMT_ENABLE_IF(sizeof(Double) != sizeof(uint64_t))>\n+inline bool grisu_format(Double, buffer<char>&, int, unsigned, int&) {\n+  return false;\n+}\n+\n+struct sprintf_specs {\n+  int precision;\n+  char type;\n+  bool alt : 1;\n+\n+  template <typename Char>\n+  constexpr sprintf_specs(basic_format_specs<Char> specs)\n+      : precision(specs.precision), type(specs.type), alt(specs.alt) {}\n+\n+  constexpr bool has_precision() const { return precision >= 0; }\n+};\n \n template <typename Double>\n-void sprintf_format(Double, internal::buffer &, core_format_specs);\n+char* sprintf_format(Double, internal::buffer<char>&, sprintf_specs);\n \n template <typename Handler>\n-FMT_CONSTEXPR void handle_int_type_spec(char spec, Handler &&handler) {\n+FMT_CONSTEXPR void handle_int_type_spec(char spec, Handler&& handler) {\n   switch (spec) {\n-  case 0: case 'd':\n+  case 0:\n+  case 'd':\n     handler.on_dec();\n     break;\n-  case 'x': case 'X':\n+  case 'x':\n+  case 'X':\n     handler.on_hex();\n     break;\n-  case 'b': case 'B':\n+  case 'b':\n+  case 'B':\n     handler.on_bin();\n     break;\n   case 'o':\n@@ -1160,20 +1135,31 @@ FMT_CONSTEXPR void handle_int_type_spec(char spec, Handler &&handler) {\n }\n \n template <typename Handler>\n-FMT_CONSTEXPR void handle_float_type_spec(char spec, Handler &&handler) {\n+FMT_CONSTEXPR void handle_float_type_spec(char spec, Handler&& handler) {\n   switch (spec) {\n-  case 0: case 'g': case 'G':\n+  case 0:\n+  case 'g':\n+  case 'G':\n     handler.on_general();\n     break;\n-  case 'e': case 'E':\n+  case 'e':\n+  case 'E':\n     handler.on_exp();\n     break;\n-  case 'f': case 'F':\n+  case 'f':\n+  case 'F':\n     handler.on_fixed();\n     break;\n-   case 'a': case 'A':\n+  case '%':\n+    handler.on_percent();\n+    break;\n+  case 'a':\n+  case 'A':\n     handler.on_hex();\n     break;\n+  case 'n':\n+    handler.on_num();\n+    break;\n   default:\n     handler.on_error();\n     break;\n@@ -1181,17 +1167,17 @@ FMT_CONSTEXPR void handle_float_type_spec(char spec, Handler &&handler) {\n }\n \n template <typename Char, typename Handler>\n-FMT_CONSTEXPR void handle_char_specs(\n-    const basic_format_specs<Char> *specs, Handler &&handler) {\n+FMT_CONSTEXPR void handle_char_specs(const basic_format_specs<Char>* specs,\n+                                     Handler&& handler) {\n   if (!specs) return handler.on_char();\n   if (specs->type && specs->type != 'c') return handler.on_int();\n-  if (specs->align() == ALIGN_NUMERIC || specs->flags != 0)\n+  if (specs->align == align::numeric || specs->sign != sign::none || specs->alt)\n     handler.on_error(\"invalid format specifier for char\");\n   handler.on_char();\n }\n \n template <typename Char, typename Handler>\n-FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler &&handler) {\n+FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler&& handler) {\n   if (spec == 0 || spec == 's')\n     handler.on_string();\n   else if (spec == 'p')\n@@ -1201,19 +1187,16 @@ FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler &&handler) {\n }\n \n template <typename Char, typename ErrorHandler>\n-FMT_CONSTEXPR void check_string_type_spec(Char spec, ErrorHandler &&eh) {\n-  if (spec != 0 && spec != 's')\n-    eh.on_error(\"invalid type specifier\");\n+FMT_CONSTEXPR void check_string_type_spec(Char spec, ErrorHandler&& eh) {\n+  if (spec != 0 && spec != 's') eh.on_error(\"invalid type specifier\");\n }\n \n template <typename Char, typename ErrorHandler>\n-FMT_CONSTEXPR void check_pointer_type_spec(Char spec, ErrorHandler &&eh) {\n-  if (spec != 0 && spec != 'p')\n-    eh.on_error(\"invalid type specifier\");\n+FMT_CONSTEXPR void check_pointer_type_spec(Char spec, ErrorHandler&& eh) {\n+  if (spec != 0 && spec != 'p') eh.on_error(\"invalid type specifier\");\n }\n \n-template <typename ErrorHandler>\n-class int_type_checker : private ErrorHandler {\n+template <typename ErrorHandler> class int_type_checker : private ErrorHandler {\n  public:\n   FMT_CONSTEXPR explicit int_type_checker(ErrorHandler eh) : ErrorHandler(eh) {}\n \n@@ -1232,12 +1215,14 @@ template <typename ErrorHandler>\n class float_type_checker : private ErrorHandler {\n  public:\n   FMT_CONSTEXPR explicit float_type_checker(ErrorHandler eh)\n-    : ErrorHandler(eh) {}\n+      : ErrorHandler(eh) {}\n \n   FMT_CONSTEXPR void on_general() {}\n   FMT_CONSTEXPR void on_exp() {}\n   FMT_CONSTEXPR void on_fixed() {}\n+  FMT_CONSTEXPR void on_percent() {}\n   FMT_CONSTEXPR void on_hex() {}\n+  FMT_CONSTEXPR void on_num() {}\n \n   FMT_CONSTEXPR void on_error() {\n     ErrorHandler::on_error(\"invalid type specifier\");\n@@ -1251,7 +1236,7 @@ class char_specs_checker : public ErrorHandler {\n \n  public:\n   FMT_CONSTEXPR char_specs_checker(char type, ErrorHandler eh)\n-    : ErrorHandler(eh), type_(type) {}\n+      : ErrorHandler(eh), type_(type) {}\n \n   FMT_CONSTEXPR void on_int() {\n     handle_int_type_spec(type_, int_type_checker<ErrorHandler>(*this));\n@@ -1263,139 +1248,555 @@ template <typename ErrorHandler>\n class cstring_type_checker : public ErrorHandler {\n  public:\n   FMT_CONSTEXPR explicit cstring_type_checker(ErrorHandler eh)\n-    : ErrorHandler(eh) {}\n+      : ErrorHandler(eh) {}\n \n   FMT_CONSTEXPR void on_string() {}\n   FMT_CONSTEXPR void on_pointer() {}\n };\n \n template <typename Context>\n-void arg_map<Context>::init(const basic_format_args<Context> &args) {\n-  if (map_)\n-    return;\n-  map_ = new entry[args.max_size()];\n+void arg_map<Context>::init(const basic_format_args<Context>& args) {\n+  if (map_) return;\n+  map_ = new entry[internal::to_unsigned(args.max_size())];\n   if (args.is_packed()) {\n-    for (unsigned i = 0;/*nothing*/; ++i) {\n+    for (int i = 0;; ++i) {\n       internal::type arg_type = args.type(i);\n-      switch (arg_type) {\n-        case internal::none_type:\n-          return;\n-        case internal::named_arg_type:\n-          push_back(args.values_[i]);\n-          break;\n-        default:\n-          break; // Do nothing.\n-      }\n+      if (arg_type == internal::none_type) return;\n+      if (arg_type == internal::named_arg_type) push_back(args.values_[i]);\n     }\n   }\n-  for (unsigned i = 0; ; ++i) {\n-    switch (args.args_[i].type_) {\n-      case internal::none_type:\n-        return;\n-      case internal::named_arg_type:\n-        push_back(args.args_[i].value_);\n-        break;\n-      default:\n-        break; // Do nothing.\n-    }\n+  for (int i = 0, n = args.max_size(); i < n; ++i) {\n+    auto type = args.args_[i].type_;\n+    if (type == internal::named_arg_type) push_back(args.args_[i].value_);\n   }\n }\n \n-template <typename Range>\n-class arg_formatter_base {\n+// This template provides operations for formatting and writing data into a\n+// character range.\n+template <typename Range> class basic_writer {\n  public:\n-  typedef typename Range::value_type char_type;\n-  typedef decltype(internal::declval<Range>().begin()) iterator;\n-  typedef basic_format_specs<char_type> format_specs;\n+  using char_type = typename Range::value_type;\n+  using iterator = typename Range::iterator;\n+  using format_specs = basic_format_specs<char_type>;\n \n  private:\n-  typedef basic_writer<Range> writer_type;\n-  writer_type writer_;\n-  format_specs *specs_;\n+  iterator out_;  // Output iterator.\n+  internal::locale_ref locale_;\n \n-  struct char_writer {\n-    char_type value;\n+  // Attempts to reserve space for n extra characters in the output range.\n+  // Returns a pointer to the reserved range or a reference to out_.\n+  auto reserve(std::size_t n) -> decltype(internal::reserve(out_, n)) {\n+    return internal::reserve(out_, n);\n+  }\n \n-    size_t size() const { return 1; }\n-    size_t width() const { return 1; }\n+  template <typename F> struct padded_int_writer {\n+    size_t size_;\n+    string_view prefix;\n+    char_type fill;\n+    std::size_t padding;\n+    F f;\n \n-    template <typename It>\n-    void operator()(It &&it) const { *it++ = value; }\n+    size_t size() const { return size_; }\n+    size_t width() const { return size_; }\n+\n+    template <typename It> void operator()(It&& it) const {\n+      if (prefix.size() != 0)\n+        it = internal::copy_str<char_type>(prefix.begin(), prefix.end(), it);\n+      it = std::fill_n(it, padding, fill);\n+      f(it);\n+    }\n   };\n \n-  void write_char(char_type value) {\n-    if (specs_)\n-      writer_.write_padded(*specs_, char_writer{value});\n-    else\n-      writer_.write(value);\n+  // Writes an integer in the format\n+  //   <left-padding><prefix><numeric-padding><digits><right-padding>\n+  // where <digits> are written by f(it).\n+  template <typename F>\n+  void write_int(int num_digits, string_view prefix, format_specs specs, F f) {\n+    std::size_t size = prefix.size() + internal::to_unsigned(num_digits);\n+    char_type fill = specs.fill[0];\n+    std::size_t padding = 0;\n+    if (specs.align == align::numeric) {\n+      auto unsiged_width = internal::to_unsigned(specs.width);\n+      if (unsiged_width > size) {\n+        padding = unsiged_width - size;\n+        size = unsiged_width;\n+      }\n+    } else if (specs.precision > num_digits) {\n+      size = prefix.size() + internal::to_unsigned(specs.precision);\n+      padding = internal::to_unsigned(specs.precision - num_digits);\n+      fill = static_cast<char_type>('0');\n+    }\n+    if (specs.align == align::none) specs.align = align::right;\n+    write_padded(specs, padded_int_writer<F>{size, prefix, fill, padding, f});\n   }\n \n-  void write_pointer(const void *p) {\n-    format_specs specs = specs_ ? *specs_ : format_specs();\n-    specs.flags = HASH_FLAG;\n-    specs.type = 'x';\n-    writer_.write_int(reinterpret_cast<uintptr_t>(p), specs);\n+  // Writes a decimal integer.\n+  template <typename Int> void write_decimal(Int value) {\n+    auto abs_value = static_cast<uint32_or_64_t<Int>>(value);\n+    bool is_negative = internal::is_negative(value);\n+    if (is_negative) abs_value = 0 - abs_value;\n+    int num_digits = internal::count_digits(abs_value);\n+    auto&& it =\n+        reserve((is_negative ? 1 : 0) + static_cast<size_t>(num_digits));\n+    if (is_negative) *it++ = static_cast<char_type>('-');\n+    it = internal::format_decimal<char_type>(it, abs_value, num_digits);\n   }\n \n- protected:\n-  writer_type &writer() { return writer_; }\n-  format_specs *spec() { return specs_; }\n-  iterator out() { return writer_.out(); }\n+  // The handle_int_type_spec handler that writes an integer.\n+  template <typename Int, typename Specs> struct int_writer {\n+    using unsigned_type = uint32_or_64_t<Int>;\n \n-  void write(bool value) {\n-    string_view sv(value ? \"true\" : \"false\");\n-    specs_ ? writer_.write(sv, *specs_) : writer_.write(sv);\n-  }\n+    basic_writer<Range>& writer;\n+    const Specs& specs;\n+    unsigned_type abs_value;\n+    char prefix[4];\n+    unsigned prefix_size;\n \n-  void write(const char_type *value) {\n-    if (!value)\n-      FMT_THROW(format_error(\"string pointer is null\"));\n-    auto length = std::char_traits<char_type>::length(value);\n-    basic_string_view<char_type> sv(value, length);\n-    specs_ ? writer_.write(sv, *specs_) : writer_.write(sv);\n-  }\n+    string_view get_prefix() const { return string_view(prefix, prefix_size); }\n+\n+    int_writer(basic_writer<Range>& w, Int value, const Specs& s)\n+        : writer(w),\n+          specs(s),\n+          abs_value(static_cast<unsigned_type>(value)),\n+          prefix_size(0) {\n+      if (internal::is_negative(value)) {\n+        prefix[0] = '-';\n+        ++prefix_size;\n+        abs_value = 0 - abs_value;\n+      } else if (specs.sign != sign::none && specs.sign != sign::minus) {\n+        prefix[0] = specs.sign == sign::plus ? '+' : ' ';\n+        ++prefix_size;\n+      }\n+    }\n+\n+    struct dec_writer {\n+      unsigned_type abs_value;\n+      int num_digits;\n+\n+      template <typename It> void operator()(It&& it) const {\n+        it = internal::format_decimal<char_type>(it, abs_value, num_digits);\n+      }\n+    };\n+\n+    void on_dec() {\n+      int num_digits = internal::count_digits(abs_value);\n+      writer.write_int(num_digits, get_prefix(), specs,\n+                       dec_writer{abs_value, num_digits});\n+    }\n+\n+    struct hex_writer {\n+      int_writer& self;\n+      int num_digits;\n+\n+      template <typename It> void operator()(It&& it) const {\n+        it = internal::format_uint<4, char_type>(it, self.abs_value, num_digits,\n+                                                 self.specs.type != 'x');\n+      }\n+    };\n+\n+    void on_hex() {\n+      if (specs.alt) {\n+        prefix[prefix_size++] = '0';\n+        prefix[prefix_size++] = specs.type;\n+      }\n+      int num_digits = internal::count_digits<4>(abs_value);\n+      writer.write_int(num_digits, get_prefix(), specs,\n+                       hex_writer{*this, num_digits});\n+    }\n+\n+    template <int BITS> struct bin_writer {\n+      unsigned_type abs_value;\n+      int num_digits;\n+\n+      template <typename It> void operator()(It&& it) const {\n+        it = internal::format_uint<BITS, char_type>(it, abs_value, num_digits);\n+      }\n+    };\n+\n+    void on_bin() {\n+      if (specs.alt) {\n+        prefix[prefix_size++] = '0';\n+        prefix[prefix_size++] = static_cast<char>(specs.type);\n+      }\n+      int num_digits = internal::count_digits<1>(abs_value);\n+      writer.write_int(num_digits, get_prefix(), specs,\n+                       bin_writer<1>{abs_value, num_digits});\n+    }\n+\n+    void on_oct() {\n+      int num_digits = internal::count_digits<3>(abs_value);\n+      if (specs.alt && specs.precision <= num_digits) {\n+        // Octal prefix '0' is counted as a digit, so only add it if precision\n+        // is not greater than the number of digits.\n+        prefix[prefix_size++] = '0';\n+      }\n+      writer.write_int(num_digits, get_prefix(), specs,\n+                       bin_writer<3>{abs_value, num_digits});\n+    }\n+\n+    enum { sep_size = 1 };\n+\n+    struct num_writer {\n+      unsigned_type abs_value;\n+      int size;\n+      char_type sep;\n+\n+      template <typename It> void operator()(It&& it) const {\n+        basic_string_view<char_type> s(&sep, sep_size);\n+        // Index of a decimal digit with the least significant digit having\n+        // index 0.\n+        unsigned digit_index = 0;\n+        it = internal::format_decimal<char_type>(\n+            it, abs_value, size, [s, &digit_index](char_type*& buffer) {\n+              if (++digit_index % 3 != 0) return;\n+              buffer -= s.size();\n+              std::uninitialized_copy(s.data(), s.data() + s.size(),\n+                                      internal::make_checked(buffer, s.size()));\n+            });\n+      }\n+    };\n+\n+    void on_num() {\n+      char_type sep = internal::thousands_sep<char_type>(writer.locale_);\n+      if (!sep) return on_dec();\n+      int num_digits = internal::count_digits(abs_value);\n+      int size = num_digits + sep_size * ((num_digits - 1) / 3);\n+      writer.write_int(size, get_prefix(), specs,\n+                       num_writer{abs_value, size, sep});\n+    }\n+\n+    FMT_NORETURN void on_error() {\n+      FMT_THROW(format_error(\"invalid type specifier\"));\n+    }\n+  };\n+\n+  enum { inf_size = 3 };  // This is an enum to workaround a bug in MSVC.\n+\n+  struct inf_or_nan_writer {\n+    char sign;\n+    bool as_percentage;\n+    const char* str;\n+\n+    size_t size() const {\n+      return static_cast<std::size_t>(inf_size + (sign ? 1 : 0) +\n+                                      (as_percentage ? 1 : 0));\n+    }\n+    size_t width() const { return size(); }\n+\n+    template <typename It> void operator()(It&& it) const {\n+      if (sign) *it++ = static_cast<char_type>(sign);\n+      it = internal::copy_str<char_type>(\n+          str, str + static_cast<std::size_t>(inf_size), it);\n+      if (as_percentage) *it++ = static_cast<char_type>('%');\n+    }\n+  };\n+\n+  struct double_writer {\n+    char sign;\n+    internal::buffer<char>& buffer;\n+    char* decimal_point_pos;\n+    char_type decimal_point;\n+\n+    size_t size() const { return buffer.size() + (sign ? 1 : 0); }\n+    size_t width() const { return size(); }\n+\n+    template <typename It> void operator()(It&& it) {\n+      if (sign) *it++ = static_cast<char_type>(sign);\n+      auto begin = buffer.begin();\n+      if (decimal_point_pos) {\n+        it = internal::copy_str<char_type>(begin, decimal_point_pos, it);\n+        *it++ = decimal_point;\n+        begin = decimal_point_pos + 1;\n+      }\n+      it = internal::copy_str<char_type>(begin, buffer.end(), it);\n+    }\n+  };\n+\n+  class grisu_writer {\n+   private:\n+    internal::buffer<char>& digits_;\n+    size_t size_;\n+    char sign_;\n+    int exp_;\n+    internal::gen_digits_params params_;\n+    char_type decimal_point_;\n+\n+   public:\n+    grisu_writer(char sign, internal::buffer<char>& digits, int exp,\n+                 const internal::gen_digits_params& params,\n+                 char_type decimal_point)\n+        : digits_(digits),\n+          sign_(sign),\n+          exp_(exp),\n+          params_(params),\n+          decimal_point_(decimal_point) {\n+      int num_digits = static_cast<int>(digits.size());\n+      int full_exp = num_digits + exp - 1;\n+      int precision = params.num_digits > 0 ? params.num_digits : 11;\n+      params_.fixed |= full_exp >= -4 && full_exp < precision;\n+      auto it = internal::grisu_prettify<char>(\n+          digits.data(), num_digits, exp, internal::counting_iterator<char>(),\n+          params_, '.');\n+      size_ = it.count();\n+    }\n+\n+    size_t size() const { return size_ + (sign_ ? 1 : 0); }\n+    size_t width() const { return size(); }\n+\n+    template <typename It> void operator()(It&& it) {\n+      if (sign_) *it++ = static_cast<char_type>(sign_);\n+      int num_digits = static_cast<int>(digits_.size());\n+      it = internal::grisu_prettify<char_type>(digits_.data(), num_digits, exp_,\n+                                               it, params_, decimal_point_);\n+    }\n+  };\n+\n+  template <typename Char> struct str_writer {\n+    const Char* s;\n+    size_t size_;\n+\n+    size_t size() const { return size_; }\n+    size_t width() const {\n+      return internal::count_code_points(basic_string_view<Char>(s, size_));\n+    }\n+\n+    template <typename It> void operator()(It&& it) const {\n+      it = internal::copy_str<char_type>(s, s + size_, it);\n+    }\n+  };\n+\n+  template <typename UIntPtr> struct pointer_writer {\n+    UIntPtr value;\n+    int num_digits;\n+\n+    size_t size() const { return to_unsigned(num_digits) + 2; }\n+    size_t width() const { return size(); }\n+\n+    template <typename It> void operator()(It&& it) const {\n+      *it++ = static_cast<char_type>('0');\n+      *it++ = static_cast<char_type>('x');\n+      it = internal::format_uint<4, char_type>(it, value, num_digits);\n+    }\n+  };\n+\n+ public:\n+  /** Constructs a ``basic_writer`` object. */\n+  explicit basic_writer(Range out,\n+                        internal::locale_ref loc = internal::locale_ref())\n+      : out_(out.begin()), locale_(loc) {}\n+\n+  iterator out() const { return out_; }\n+\n+  // Writes a value in the format\n+  //   <left-padding><value><right-padding>\n+  // where <value> is written by f(it).\n+  template <typename F> void write_padded(const format_specs& specs, F&& f) {\n+    // User-perceived width (in code points).\n+    unsigned width = to_unsigned(specs.width);\n+    size_t size = f.size();  // The number of code units.\n+    size_t num_code_points = width != 0 ? f.width() : size;\n+    if (width <= num_code_points) return f(reserve(size));\n+    auto&& it = reserve(width + (size - num_code_points));\n+    char_type fill = specs.fill[0];\n+    std::size_t padding = width - num_code_points;\n+    if (specs.align == align::right) {\n+      it = std::fill_n(it, padding, fill);\n+      f(it);\n+    } else if (specs.align == align::center) {\n+      std::size_t left_padding = padding / 2;\n+      it = std::fill_n(it, left_padding, fill);\n+      f(it);\n+      it = std::fill_n(it, padding - left_padding, fill);\n+    } else {\n+      f(it);\n+      it = std::fill_n(it, padding, fill);\n+    }\n+  }\n+\n+  void write(int value) { write_decimal(value); }\n+  void write(long value) { write_decimal(value); }\n+  void write(long long value) { write_decimal(value); }\n+\n+  void write(unsigned value) { write_decimal(value); }\n+  void write(unsigned long value) { write_decimal(value); }\n+  void write(unsigned long long value) { write_decimal(value); }\n+\n+  // Writes a formatted integer.\n+  template <typename T, typename Spec>\n+  void write_int(T value, const Spec& spec) {\n+    internal::handle_int_type_spec(spec.type,\n+                                   int_writer<T, Spec>(*this, value, spec));\n+  }\n+\n+  void write(double value, const format_specs& specs = format_specs()) {\n+    write_double(value, specs);\n+  }\n+\n+  /**\n+    \\rst\n+    Formats *value* using the general format for floating-point numbers\n+    (``'g'``) and writes it to the buffer.\n+    \\endrst\n+   */\n+  void write(long double value, const format_specs& specs = format_specs()) {\n+    write_double(value, specs);\n+  }\n+\n+  // Formats a floating-point number (double or long double).\n+  template <typename T, bool USE_GRISU = fmt::internal::use_grisu<T>()>\n+  void write_double(T value, const format_specs& specs);\n+\n+  /** Writes a character to the buffer. */\n+  void write(char value) {\n+    auto&& it = reserve(1);\n+    *it++ = value;\n+  }\n+\n+  template <typename Char, FMT_ENABLE_IF(std::is_same<Char, char_type>::value)>\n+  void write(Char value) {\n+    auto&& it = reserve(1);\n+    *it++ = value;\n+  }\n+\n+  /**\n+    \\rst\n+    Writes *value* to the buffer.\n+    \\endrst\n+   */\n+  void write(string_view value) {\n+    auto&& it = reserve(value.size());\n+    it = internal::copy_str<char_type>(value.begin(), value.end(), it);\n+  }\n+  void write(wstring_view value) {\n+    static_assert(std::is_same<char_type, wchar_t>::value, \"\");\n+    auto&& it = reserve(value.size());\n+    it = std::copy(value.begin(), value.end(), it);\n+  }\n+\n+  // Writes a formatted string.\n+  template <typename Char>\n+  void write(const Char* s, std::size_t size, const format_specs& specs) {\n+    write_padded(specs, str_writer<Char>{s, size});\n+  }\n+\n+  template <typename Char>\n+  void write(basic_string_view<Char> s,\n+             const format_specs& specs = format_specs()) {\n+    const Char* data = s.data();\n+    std::size_t size = s.size();\n+    if (specs.precision >= 0 && internal::to_unsigned(specs.precision) < size)\n+      size = internal::to_unsigned(specs.precision);\n+    write(data, size, specs);\n+  }\n+\n+  template <typename UIntPtr>\n+  void write_pointer(UIntPtr value, const format_specs* specs) {\n+    int num_digits = internal::count_digits<4>(value);\n+    auto pw = pointer_writer<UIntPtr>{value, num_digits};\n+    if (!specs) return pw(reserve(to_unsigned(num_digits) + 2));\n+    format_specs specs_copy = *specs;\n+    if (specs_copy.align == align::none) specs_copy.align = align::right;\n+    write_padded(specs_copy, pw);\n+  }\n+};\n+\n+using writer = basic_writer<buffer_range<char>>;\n+\n+template <typename Range, typename ErrorHandler = internal::error_handler>\n+class arg_formatter_base {\n+ public:\n+  using char_type = typename Range::value_type;\n+  using iterator = typename Range::iterator;\n+  using format_specs = basic_format_specs<char_type>;\n+\n+ private:\n+  using writer_type = basic_writer<Range>;\n+  writer_type writer_;\n+  format_specs* specs_;\n+\n+  struct char_writer {\n+    char_type value;\n+\n+    size_t size() const { return 1; }\n+    size_t width() const { return 1; }\n+\n+    template <typename It> void operator()(It&& it) const { *it++ = value; }\n+  };\n+\n+  void write_char(char_type value) {\n+    if (specs_)\n+      writer_.write_padded(*specs_, char_writer{value});\n+    else\n+      writer_.write(value);\n+  }\n+\n+  void write_pointer(const void* p) {\n+    writer_.write_pointer(internal::bit_cast<internal::uintptr_t>(p), specs_);\n+  }\n+\n+ protected:\n+  writer_type& writer() { return writer_; }\n+  FMT_DEPRECATED format_specs* spec() { return specs_; }\n+  format_specs* specs() { return specs_; }\n+  iterator out() { return writer_.out(); }\n+\n+  void write(bool value) {\n+    string_view sv(value ? \"true\" : \"false\");\n+    specs_ ? writer_.write(sv, *specs_) : writer_.write(sv);\n+  }\n+\n+  void write(const char_type* value) {\n+    if (!value) {\n+      FMT_THROW(format_error(\"string pointer is null\"));\n+    } else {\n+      auto length = std::char_traits<char_type>::length(value);\n+      basic_string_view<char_type> sv(value, length);\n+      specs_ ? writer_.write(sv, *specs_) : writer_.write(sv);\n+    }\n+  }\n \n  public:\n-  arg_formatter_base(Range r, format_specs *s, locale_ref loc)\n-    : writer_(r, loc), specs_(s) {}\n+  arg_formatter_base(Range r, format_specs* s, locale_ref loc)\n+      : writer_(r, loc), specs_(s) {}\n \n   iterator operator()(monostate) {\n     FMT_ASSERT(false, \"invalid argument type\");\n     return out();\n   }\n \n-  template <typename T>\n-  typename std::enable_if<\n-    std::is_integral<T>::value || std::is_same<T, char_type>::value,\n-    iterator>::type operator()(T value) {\n-    // MSVC2013 fails to compile separate overloads for bool and char_type so\n-    // use std::is_same instead.\n-    if (std::is_same<T, bool>::value) {\n-      if (specs_ && specs_->type)\n-        return (*this)(value ? 1 : 0);\n-      write(value != 0);\n-    } else if (std::is_same<T, char_type>::value) {\n-      internal::handle_char_specs(\n+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+  iterator operator()(T value) {\n+    if (specs_)\n+      writer_.write_int(value, *specs_);\n+    else\n+      writer_.write(value);\n+    return out();\n+  }\n+\n+  iterator operator()(char_type value) {\n+    internal::handle_char_specs(\n         specs_, char_spec_handler(*this, static_cast<char_type>(value)));\n-    } else {\n-      specs_ ? writer_.write_int(value, *specs_) : writer_.write(value);\n-    }\n     return out();\n   }\n \n-  template <typename T>\n-  typename std::enable_if<std::is_floating_point<T>::value, iterator>::type\n-      operator()(T value) {\n+  iterator operator()(bool value) {\n+    if (specs_ && specs_->type) return (*this)(value ? 1 : 0);\n+    write(value != 0);\n+    return out();\n+  }\n+\n+  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n+  iterator operator()(T value) {\n     writer_.write_double(value, specs_ ? *specs_ : format_specs());\n     return out();\n   }\n \n-  struct char_spec_handler : internal::error_handler {\n-    arg_formatter_base &formatter;\n+  struct char_spec_handler : ErrorHandler {\n+    arg_formatter_base& formatter;\n     char_type value;\n \n     char_spec_handler(arg_formatter_base& f, char_type val)\n-      : formatter(f), value(val) {}\n+        : formatter(f), value(val) {}\n \n     void on_int() {\n       if (formatter.specs_)\n@@ -1407,27 +1808,26 @@ class arg_formatter_base {\n   };\n \n   struct cstring_spec_handler : internal::error_handler {\n-    arg_formatter_base &formatter;\n-    const char_type *value;\n+    arg_formatter_base& formatter;\n+    const char_type* value;\n \n-    cstring_spec_handler(arg_formatter_base &f, const char_type *val)\n-      : formatter(f), value(val) {}\n+    cstring_spec_handler(arg_formatter_base& f, const char_type* val)\n+        : formatter(f), value(val) {}\n \n     void on_string() { formatter.write(value); }\n     void on_pointer() { formatter.write_pointer(value); }\n   };\n \n-  iterator operator()(const char_type *value) {\n+  iterator operator()(const char_type* value) {\n     if (!specs_) return write(value), out();\n-    internal::handle_cstring_type_spec(\n-          specs_->type, cstring_spec_handler(*this, value));\n+    internal::handle_cstring_type_spec(specs_->type,\n+                                       cstring_spec_handler(*this, value));\n     return out();\n   }\n \n   iterator operator()(basic_string_view<char_type> value) {\n     if (specs_) {\n-      internal::check_string_type_spec(\n-            specs_->type, internal::error_handler());\n+      internal::check_string_type_spec(specs_->type, internal::error_handler());\n       writer_.write(value, *specs_);\n     } else {\n       writer_.write(value);\n@@ -1435,7 +1835,7 @@ class arg_formatter_base {\n     return out();\n   }\n \n-  iterator operator()(const void *value) {\n+  iterator operator()(const void* value) {\n     if (specs_)\n       check_pointer_type_spec(specs_->type, internal::error_handler());\n     write_pointer(value);\n@@ -1443,16 +1843,15 @@ class arg_formatter_base {\n   }\n };\n \n-template <typename Char>\n-FMT_CONSTEXPR bool is_name_start(Char c) {\n+template <typename Char> FMT_CONSTEXPR bool is_name_start(Char c) {\n   return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;\n }\n \n // Parses the range [begin, end) as an unsigned integer. This function assumes\n // that the range is non-empty and the first character is a digit.\n template <typename Char, typename ErrorHandler>\n-FMT_CONSTEXPR unsigned parse_nonnegative_int(\n-    const Char *&begin, const Char *end, ErrorHandler &&eh) {\n+FMT_CONSTEXPR int parse_nonnegative_int(const Char*& begin, const Char* end,\n+                                        ErrorHandler&& eh) {\n   assert(begin != end && '0' <= *begin && *begin <= '9');\n   if (*begin == '0') {\n     ++begin;\n@@ -1460,7 +1859,7 @@ FMT_CONSTEXPR unsigned parse_nonnegative_int(\n   }\n   unsigned value = 0;\n   // Convert to unsigned to prevent a warning.\n-  unsigned max_int = (std::numeric_limits<int>::max)();\n+  constexpr unsigned max_int = (std::numeric_limits<int>::max)();\n   unsigned big = max_int / 10;\n   do {\n     // Check for overflow.\n@@ -1471,109 +1870,100 @@ FMT_CONSTEXPR unsigned parse_nonnegative_int(\n     value = value * 10 + unsigned(*begin - '0');\n     ++begin;\n   } while (begin != end && '0' <= *begin && *begin <= '9');\n-  if (value > max_int)\n-    eh.on_error(\"number is too big\");\n-  return value;\n+  if (value > max_int) eh.on_error(\"number is too big\");\n+  return static_cast<int>(value);\n }\n \n-template <typename Char, typename Context>\n-class custom_formatter: public function<bool> {\n+template <typename Context> class custom_formatter {\n  private:\n-  Context &ctx_;\n+  using char_type = typename Context::char_type;\n+\n+  basic_parse_context<char_type>& parse_ctx_;\n+  Context& ctx_;\n \n  public:\n-  explicit custom_formatter(Context &ctx): ctx_(ctx) {}\n+  explicit custom_formatter(basic_parse_context<char_type>& parse_ctx,\n+                            Context& ctx)\n+      : parse_ctx_(parse_ctx), ctx_(ctx) {}\n \n   bool operator()(typename basic_format_arg<Context>::handle h) const {\n-    h.format(ctx_);\n+    h.format(parse_ctx_, ctx_);\n     return true;\n   }\n \n-  template <typename T>\n-  bool operator()(T) const { return false; }\n+  template <typename T> bool operator()(T) const { return false; }\n };\n \n template <typename T>\n-struct is_integer {\n-  enum {\n-    value = std::is_integral<T>::value && !std::is_same<T, bool>::value &&\n-            !std::is_same<T, char>::value && !std::is_same<T, wchar_t>::value\n-  };\n-};\n+using is_integer =\n+    bool_constant<std::is_integral<T>::value && !std::is_same<T, bool>::value &&\n+                  !std::is_same<T, char>::value &&\n+                  !std::is_same<T, wchar_t>::value>;\n \n-template <typename ErrorHandler>\n-class width_checker: public function<unsigned long long> {\n+template <typename ErrorHandler> class width_checker {\n  public:\n-  explicit FMT_CONSTEXPR width_checker(ErrorHandler &eh) : handler_(eh) {}\n-\n-  template <typename T>\n-  FMT_CONSTEXPR\n-  typename std::enable_if<\n-      is_integer<T>::value, unsigned long long>::type operator()(T value) {\n-    if (is_negative(value))\n-      handler_.on_error(\"negative width\");\n+  explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}\n+\n+  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>\n+  FMT_CONSTEXPR unsigned long long operator()(T value) {\n+    if (is_negative(value)) handler_.on_error(\"negative width\");\n     return static_cast<unsigned long long>(value);\n   }\n \n-  template <typename T>\n-  FMT_CONSTEXPR typename std::enable_if<\n-      !is_integer<T>::value, unsigned long long>::type operator()(T) {\n+  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>\n+  FMT_CONSTEXPR unsigned long long operator()(T) {\n     handler_.on_error(\"width is not integer\");\n     return 0;\n   }\n \n  private:\n-  ErrorHandler &handler_;\n+  ErrorHandler& handler_;\n };\n \n-template <typename ErrorHandler>\n-class precision_checker: public function<unsigned long long> {\n+template <typename ErrorHandler> class precision_checker {\n  public:\n-  explicit FMT_CONSTEXPR precision_checker(ErrorHandler &eh) : handler_(eh) {}\n+  explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}\n \n-  template <typename T>\n-  FMT_CONSTEXPR typename std::enable_if<\n-      is_integer<T>::value, unsigned long long>::type operator()(T value) {\n-    if (is_negative(value))\n-      handler_.on_error(\"negative precision\");\n+  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>\n+  FMT_CONSTEXPR unsigned long long operator()(T value) {\n+    if (is_negative(value)) handler_.on_error(\"negative precision\");\n     return static_cast<unsigned long long>(value);\n   }\n \n-  template <typename T>\n-  FMT_CONSTEXPR typename std::enable_if<\n-      !is_integer<T>::value, unsigned long long>::type operator()(T) {\n+  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>\n+  FMT_CONSTEXPR unsigned long long operator()(T) {\n     handler_.on_error(\"precision is not integer\");\n     return 0;\n   }\n \n  private:\n-  ErrorHandler &handler_;\n+  ErrorHandler& handler_;\n };\n \n // A format specifier handler that sets fields in basic_format_specs.\n-template <typename Char>\n-class specs_setter {\n+template <typename Char> class specs_setter {\n  public:\n-  explicit FMT_CONSTEXPR specs_setter(basic_format_specs<Char> &specs):\n-    specs_(specs) {}\n+  explicit FMT_CONSTEXPR specs_setter(basic_format_specs<Char>& specs)\n+      : specs_(specs) {}\n \n-  FMT_CONSTEXPR specs_setter(const specs_setter &other): specs_(other.specs_) {}\n+  FMT_CONSTEXPR specs_setter(const specs_setter& other)\n+      : specs_(other.specs_) {}\n \n-  FMT_CONSTEXPR void on_align(alignment align) { specs_.align_ = align; }\n-  FMT_CONSTEXPR void on_fill(Char fill) { specs_.fill_ = fill; }\n-  FMT_CONSTEXPR void on_plus() { specs_.flags |= SIGN_FLAG | PLUS_FLAG; }\n-  FMT_CONSTEXPR void on_minus() { specs_.flags |= MINUS_FLAG; }\n-  FMT_CONSTEXPR void on_space() { specs_.flags |= SIGN_FLAG; }\n-  FMT_CONSTEXPR void on_hash() { specs_.flags |= HASH_FLAG; }\n+  FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }\n+  FMT_CONSTEXPR void on_fill(Char fill) { specs_.fill[0] = fill; }\n+  FMT_CONSTEXPR void on_plus() { specs_.sign = sign::plus; }\n+  FMT_CONSTEXPR void on_minus() { specs_.sign = sign::minus; }\n+  FMT_CONSTEXPR void on_space() { specs_.sign = sign::space; }\n+  FMT_CONSTEXPR void on_hash() { specs_.alt = true; }\n \n   FMT_CONSTEXPR void on_zero() {\n-    specs_.align_ = ALIGN_NUMERIC;\n-    specs_.fill_ = '0';\n+    specs_.align = align::numeric;\n+    specs_.fill[0] = Char('0');\n   }\n \n-  FMT_CONSTEXPR void on_width(unsigned width) { specs_.width_ = width; }\n-  FMT_CONSTEXPR void on_precision(unsigned precision) {\n-    specs_.precision = static_cast<int>(precision);\n+  FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }\n+  FMT_CONSTEXPR void on_precision(int precision) {\n+    specs_.precision = precision;\n   }\n   FMT_CONSTEXPR void end_precision() {}\n \n@@ -1582,77 +1972,86 @@ class specs_setter {\n   }\n \n  protected:\n-  basic_format_specs<Char> &specs_;\n+  basic_format_specs<Char>& specs_;\n+};\n+\n+template <typename ErrorHandler> class numeric_specs_checker {\n+ public:\n+  FMT_CONSTEXPR numeric_specs_checker(ErrorHandler& eh, internal::type arg_type)\n+      : error_handler_(eh), arg_type_(arg_type) {}\n+\n+  FMT_CONSTEXPR void require_numeric_argument() {\n+    if (!is_arithmetic(arg_type_))\n+      error_handler_.on_error(\"format specifier requires numeric argument\");\n+  }\n+\n+  FMT_CONSTEXPR void check_sign() {\n+    require_numeric_argument();\n+    if (is_integral(arg_type_) && arg_type_ != int_type &&\n+        arg_type_ != long_long_type && arg_type_ != internal::char_type) {\n+      error_handler_.on_error(\"format specifier requires signed argument\");\n+    }\n+  }\n+\n+  FMT_CONSTEXPR void check_precision() {\n+    if (is_integral(arg_type_) || arg_type_ == internal::pointer_type)\n+      error_handler_.on_error(\"precision not allowed for this argument type\");\n+  }\n+\n+ private:\n+  ErrorHandler& error_handler_;\n+  internal::type arg_type_;\n };\n \n // A format specifier handler that checks if specifiers are consistent with the\n // argument type.\n-template <typename Handler>\n-class specs_checker : public Handler {\n+template <typename Handler> class specs_checker : public Handler {\n  public:\n   FMT_CONSTEXPR specs_checker(const Handler& handler, internal::type arg_type)\n-    : Handler(handler), arg_type_(arg_type) {}\n+      : Handler(handler), checker_(*this, arg_type) {}\n \n-  FMT_CONSTEXPR specs_checker(const specs_checker &other)\n-    : Handler(other), arg_type_(other.arg_type_) {}\n+  FMT_CONSTEXPR specs_checker(const specs_checker& other)\n+      : Handler(other), checker_(*this, other.arg_type_) {}\n \n-  FMT_CONSTEXPR void on_align(alignment align) {\n-    if (align == ALIGN_NUMERIC)\n-      require_numeric_argument();\n+  FMT_CONSTEXPR void on_align(align_t align) {\n+    if (align == align::numeric) checker_.require_numeric_argument();\n     Handler::on_align(align);\n   }\n \n   FMT_CONSTEXPR void on_plus() {\n-    check_sign();\n+    checker_.check_sign();\n     Handler::on_plus();\n   }\n \n   FMT_CONSTEXPR void on_minus() {\n-    check_sign();\n+    checker_.check_sign();\n     Handler::on_minus();\n   }\n \n   FMT_CONSTEXPR void on_space() {\n-    check_sign();\n+    checker_.check_sign();\n     Handler::on_space();\n   }\n \n   FMT_CONSTEXPR void on_hash() {\n-    require_numeric_argument();\n+    checker_.require_numeric_argument();\n     Handler::on_hash();\n   }\n \n   FMT_CONSTEXPR void on_zero() {\n-    require_numeric_argument();\n+    checker_.require_numeric_argument();\n     Handler::on_zero();\n   }\n \n-  FMT_CONSTEXPR void end_precision() {\n-    if (is_integral(arg_type_) || arg_type_ == pointer_type)\n-      this->on_error(\"precision not allowed for this argument type\");\n-  }\n+  FMT_CONSTEXPR void end_precision() { checker_.check_precision(); }\n \n  private:\n-  FMT_CONSTEXPR void require_numeric_argument() {\n-    if (!is_arithmetic(arg_type_))\n-      this->on_error(\"format specifier requires numeric argument\");\n-  }\n-\n-  FMT_CONSTEXPR void check_sign() {\n-    require_numeric_argument();\n-    if (is_integral(arg_type_) && arg_type_ != int_type &&\n-        arg_type_ != long_long_type && arg_type_ != internal::char_type) {\n-      this->on_error(\"format specifier requires signed argument\");\n-    }\n-  }\n-\n-  internal::type arg_type_;\n+  numeric_specs_checker<Handler> checker_;\n };\n \n-template <template <typename> class Handler, typename T,\n-          typename Context, typename ErrorHandler>\n-FMT_CONSTEXPR void set_dynamic_spec(\n-    T &value, basic_format_arg<Context> arg, ErrorHandler eh) {\n+template <template <typename> class Handler, typename T, typename FormatArg,\n+          typename ErrorHandler>\n+FMT_CONSTEXPR void set_dynamic_spec(T& value, FormatArg arg, ErrorHandler eh) {\n   unsigned long long big_value =\n       visit_format_arg(Handler<ErrorHandler>(eh), arg);\n   if (big_value > to_unsigned((std::numeric_limits<int>::max)()))\n@@ -1662,73 +2061,107 @@ FMT_CONSTEXPR void set_dynamic_spec(\n \n struct auto_id {};\n \n-// The standard format specifier handler with checking.\n template <typename Context>\n-class specs_handler: public specs_setter<typename Context::char_type> {\n+FMT_CONSTEXPR typename Context::format_arg get_arg(Context& ctx, int id) {\n+  auto arg = ctx.arg(id);\n+  if (!arg) ctx.on_error(\"argument index out of range\");\n+  return arg;\n+}\n+\n+// The standard format specifier handler with checking.\n+template <typename ParseContext, typename Context>\n+class specs_handler : public specs_setter<typename Context::char_type> {\n  public:\n-  typedef typename Context::char_type char_type;\n+  using char_type = typename Context::char_type;\n \n-  FMT_CONSTEXPR specs_handler(\n-      basic_format_specs<char_type> &specs, Context &ctx)\n-    : specs_setter<char_type>(specs), context_(ctx) {}\n+  FMT_CONSTEXPR specs_handler(basic_format_specs<char_type>& specs,\n+                              ParseContext& parse_ctx, Context& ctx)\n+      : specs_setter<char_type>(specs),\n+        parse_context_(parse_ctx),\n+        context_(ctx) {}\n \n-  template <typename Id>\n-  FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {\n-    set_dynamic_spec<width_checker>(\n-          this->specs_.width_, get_arg(arg_id), context_.error_handler());\n+  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {\n+    set_dynamic_spec<width_checker>(this->specs_.width, get_arg(arg_id),\n+                                    context_.error_handler());\n   }\n \n-  template <typename Id>\n-  FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {\n-    set_dynamic_spec<precision_checker>(\n-          this->specs_.precision, get_arg(arg_id), context_.error_handler());\n+  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {\n+    set_dynamic_spec<precision_checker>(this->specs_.precision, get_arg(arg_id),\n+                                        context_.error_handler());\n   }\n \n-  void on_error(const char *message) {\n-    context_.on_error(message);\n-  }\n+  void on_error(const char* message) { context_.on_error(message); }\n \n  private:\n-  FMT_CONSTEXPR basic_format_arg<Context> get_arg(auto_id) {\n-    return context_.next_arg();\n+  // This is only needed for compatibility with gcc 4.4.\n+  using format_arg = typename Context::format_arg;\n+\n+  FMT_CONSTEXPR format_arg get_arg(auto_id) {\n+    return internal::get_arg(context_, parse_context_.next_arg_id());\n   }\n \n-  template <typename Id>\n-  FMT_CONSTEXPR basic_format_arg<Context> get_arg(Id arg_id) {\n-    context_.parse_context().check_arg_id(arg_id);\n-    return context_.get_arg(arg_id);\n+  FMT_CONSTEXPR format_arg get_arg(int arg_id) {\n+    parse_context_.check_arg_id(arg_id);\n+    return internal::get_arg(context_, arg_id);\n   }\n \n-  Context &context_;\n-};\n+  FMT_CONSTEXPR format_arg get_arg(basic_string_view<char_type> arg_id) {\n+    parse_context_.check_arg_id(arg_id);\n+    return context_.arg(arg_id);\n+  }\n \n-// An argument reference.\n-template <typename Char>\n-struct arg_ref {\n-  enum Kind { NONE, INDEX, NAME };\n+  ParseContext& parse_context_;\n+  Context& context_;\n+};\n \n-  FMT_CONSTEXPR arg_ref() : kind(NONE), index(0) {}\n-  FMT_CONSTEXPR explicit arg_ref(unsigned index) : kind(INDEX), index(index) {}\n-  explicit arg_ref(basic_string_view<Char> nm) : kind(NAME) {\n-    name = {nm.data(), nm.size()};\n+struct string_view_metadata {\n+  FMT_CONSTEXPR string_view_metadata() : offset_(0u), size_(0u) {}\n+  template <typename Char>\n+  FMT_CONSTEXPR string_view_metadata(basic_string_view<Char> primary_string,\n+                                     basic_string_view<Char> view)\n+      : offset_(to_unsigned(view.data() - primary_string.data())),\n+        size_(view.size()) {}\n+  FMT_CONSTEXPR string_view_metadata(std::size_t offset, std::size_t size)\n+      : offset_(offset), size_(size) {}\n+  template <typename Char>\n+  FMT_CONSTEXPR basic_string_view<Char> to_view(const Char* str) const {\n+    return {str + offset_, size_};\n   }\n \n-  FMT_CONSTEXPR arg_ref &operator=(unsigned idx) {\n-    kind = INDEX;\n-    index = idx;\n+  std::size_t offset_;\n+  std::size_t size_;\n+};\n+\n+enum class arg_id_kind { none, index, name };\n+\n+// An argument reference.\n+template <typename Char> struct arg_ref {\n+  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}\n+  FMT_CONSTEXPR explicit arg_ref(int index)\n+      : kind(arg_id_kind::index), val(index) {}\n+  FMT_CONSTEXPR explicit arg_ref(string_view_metadata name)\n+      : kind(arg_id_kind::name), val(name) {}\n+\n+  FMT_CONSTEXPR arg_ref& operator=(int idx) {\n+    kind = arg_id_kind::index;\n+    val.index = idx;\n     return *this;\n   }\n \n-  Kind kind;\n-  union {\n-    unsigned index;\n-    string_value<Char> name;  // This is not string_view because of gcc 4.4.\n-  };\n+  arg_id_kind kind;\n+  union value {\n+    FMT_CONSTEXPR value() : index(0u) {}\n+    FMT_CONSTEXPR value(int id) : index(id) {}\n+    FMT_CONSTEXPR value(string_view_metadata n) : name(n) {}\n+\n+    int index;\n+    string_view_metadata name;\n+  } val;\n };\n \n // Format specifiers with width and precision resolved at formatting rather\n // than parsing time to allow re-using the same parsed specifiers with\n-// differents sets of arguments (precompilation of format strings).\n+// different sets of arguments (precompilation of format strings).\n template <typename Char>\n struct dynamic_format_specs : basic_format_specs<Char> {\n   arg_ref<Char> width_ref;\n@@ -1738,38 +2171,36 @@ struct dynamic_format_specs : basic_format_specs<Char> {\n // Format spec handler that saves references to arguments representing dynamic\n // width and precision to be resolved at formatting time.\n template <typename ParseContext>\n-class dynamic_specs_handler :\n-    public specs_setter<typename ParseContext::char_type> {\n+class dynamic_specs_handler\n+    : public specs_setter<typename ParseContext::char_type> {\n  public:\n-  typedef typename ParseContext::char_type char_type;\n+  using char_type = typename ParseContext::char_type;\n \n-  FMT_CONSTEXPR dynamic_specs_handler(\n-      dynamic_format_specs<char_type> &specs, ParseContext &ctx)\n-    : specs_setter<char_type>(specs), specs_(specs), context_(ctx) {}\n+  FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs<char_type>& specs,\n+                                      ParseContext& ctx)\n+      : specs_setter<char_type>(specs), specs_(specs), context_(ctx) {}\n \n-  FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler &other)\n-    : specs_setter<char_type>(other),\n-      specs_(other.specs_), context_(other.context_) {}\n+  FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler& other)\n+      : specs_setter<char_type>(other),\n+        specs_(other.specs_),\n+        context_(other.context_) {}\n \n-  template <typename Id>\n-  FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {\n+  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {\n     specs_.width_ref = make_arg_ref(arg_id);\n   }\n \n-  template <typename Id>\n-  FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {\n+  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {\n     specs_.precision_ref = make_arg_ref(arg_id);\n   }\n \n-  FMT_CONSTEXPR void on_error(const char *message) {\n+  FMT_CONSTEXPR void on_error(const char* message) {\n     context_.on_error(message);\n   }\n \n  private:\n-  typedef arg_ref<char_type> arg_ref_type;\n+  using arg_ref_type = arg_ref<char_type>;\n \n-  template <typename Id>\n-  FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {\n+  FMT_CONSTEXPR arg_ref_type make_arg_ref(int arg_id) {\n     context_.check_arg_id(arg_id);\n     return arg_ref_type(arg_id);\n   }\n@@ -1778,19 +2209,26 @@ class dynamic_specs_handler :\n     return arg_ref_type(context_.next_arg_id());\n   }\n \n-  dynamic_format_specs<char_type> &specs_;\n-  ParseContext &context_;\n+  FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<char_type> arg_id) {\n+    context_.check_arg_id(arg_id);\n+    basic_string_view<char_type> format_str(\n+        context_.begin(), to_unsigned(context_.end() - context_.begin()));\n+    const auto id_metadata = string_view_metadata(format_str, arg_id);\n+    return arg_ref_type(id_metadata);\n+  }\n+\n+  dynamic_format_specs<char_type>& specs_;\n+  ParseContext& context_;\n };\n \n template <typename Char, typename IDHandler>\n-FMT_CONSTEXPR const Char *parse_arg_id(\n-    const Char *begin, const Char *end, IDHandler &&handler) {\n+FMT_CONSTEXPR const Char* parse_arg_id(const Char* begin, const Char* end,\n+                                       IDHandler&& handler) {\n   assert(begin != end);\n   Char c = *begin;\n-  if (c == '}' || c == ':')\n-    return handler(), begin;\n+  if (c == '}' || c == ':') return handler(), begin;\n   if (c >= '0' && c <= '9') {\n-    unsigned index = parse_nonnegative_int(begin, end, handler);\n+    int index = parse_nonnegative_int(begin, end, handler);\n     if (begin == end || (*begin != '}' && *begin != ':'))\n       return handler.on_error(\"invalid format string\"), begin;\n     handler(index);\n@@ -1807,72 +2245,71 @@ FMT_CONSTEXPR const Char *parse_arg_id(\n }\n \n // Adapts SpecHandler to IDHandler API for dynamic width.\n-template <typename SpecHandler, typename Char>\n-struct width_adapter {\n-  explicit FMT_CONSTEXPR width_adapter(SpecHandler &h) : handler(h) {}\n+template <typename SpecHandler, typename Char> struct width_adapter {\n+  explicit FMT_CONSTEXPR width_adapter(SpecHandler& h) : handler(h) {}\n \n   FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }\n-  FMT_CONSTEXPR void operator()(unsigned id) { handler.on_dynamic_width(id); }\n+  FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }\n   FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {\n     handler.on_dynamic_width(id);\n   }\n \n-  FMT_CONSTEXPR void on_error(const char *message) {\n+  FMT_CONSTEXPR void on_error(const char* message) {\n     handler.on_error(message);\n   }\n \n-  SpecHandler &handler;\n+  SpecHandler& handler;\n };\n \n // Adapts SpecHandler to IDHandler API for dynamic precision.\n-template <typename SpecHandler, typename Char>\n-struct precision_adapter {\n-  explicit FMT_CONSTEXPR precision_adapter(SpecHandler &h) : handler(h) {}\n+template <typename SpecHandler, typename Char> struct precision_adapter {\n+  explicit FMT_CONSTEXPR precision_adapter(SpecHandler& h) : handler(h) {}\n \n   FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }\n-  FMT_CONSTEXPR void operator()(unsigned id) {\n-    handler.on_dynamic_precision(id);\n-  }\n+  FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }\n   FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {\n     handler.on_dynamic_precision(id);\n   }\n \n-  FMT_CONSTEXPR void on_error(const char *message) { handler.on_error(message); }\n+  FMT_CONSTEXPR void on_error(const char* message) {\n+    handler.on_error(message);\n+  }\n \n-  SpecHandler &handler;\n+  SpecHandler& handler;\n };\n \n // Parses fill and alignment.\n template <typename Char, typename Handler>\n-FMT_CONSTEXPR const Char *parse_align(\n-    const Char *begin, const Char *end, Handler &&handler) {\n+FMT_CONSTEXPR const Char* parse_align(const Char* begin, const Char* end,\n+                                      Handler&& handler) {\n   FMT_ASSERT(begin != end, \"\");\n-  alignment align = ALIGN_DEFAULT;\n+  auto align = align::none;\n   int i = 0;\n   if (begin + 1 != end) ++i;\n   do {\n     switch (static_cast<char>(begin[i])) {\n     case '<':\n-      align = ALIGN_LEFT;\n+      align = align::left;\n       break;\n     case '>':\n-      align = ALIGN_RIGHT;\n+      align = align::right;\n       break;\n     case '=':\n-      align = ALIGN_NUMERIC;\n+      align = align::numeric;\n       break;\n     case '^':\n-      align = ALIGN_CENTER;\n+      align = align::center;\n       break;\n     }\n-    if (align != ALIGN_DEFAULT) {\n+    if (align != align::none) {\n       if (i > 0) {\n         auto c = *begin;\n         if (c == '{')\n           return handler.on_error(\"invalid fill character '{'\"), begin;\n         begin += 2;\n         handler.on_fill(c);\n-      } else ++begin;\n+      } else\n+        ++begin;\n       handler.on_align(align);\n       break;\n     }\n@@ -1881,8 +2318,8 @@ FMT_CONSTEXPR const Char *parse_align(\n }\n \n template <typename Char, typename Handler>\n-FMT_CONSTEXPR const Char *parse_width(\n-    const Char *begin, const Char *end, Handler &&handler) {\n+FMT_CONSTEXPR const Char* parse_width(const Char* begin, const Char* end,\n+                                      Handler&& handler) {\n   FMT_ASSERT(begin != end, \"\");\n   if ('0' <= *begin && *begin <= '9') {\n     handler.on_width(parse_nonnegative_int(begin, end, handler));\n@@ -1897,13 +2334,34 @@ FMT_CONSTEXPR const Char *parse_width(\n   return begin;\n }\n \n+template <typename Char, typename Handler>\n+FMT_CONSTEXPR const Char* parse_precision(const Char* begin, const Char* end,\n+                                          Handler&& handler) {\n+  ++begin;\n+  auto c = begin != end ? *begin : Char();\n+  if ('0' <= c && c <= '9') {\n+    handler.on_precision(parse_nonnegative_int(begin, end, handler));\n+  } else if (c == '{') {\n+    ++begin;\n+    if (begin != end) {\n+      begin =\n+          parse_arg_id(begin, end, precision_adapter<Handler, Char>(handler));\n+    }\n+    if (begin == end || *begin++ != '}')\n+      return handler.on_error(\"invalid format string\"), begin;\n+  } else {\n+    return handler.on_error(\"missing precision specifier\"), begin;\n+  }\n+  handler.end_precision();\n+  return begin;\n+}\n+\n // Parses standard format specifiers and sends notifications about parsed\n // components to handler.\n template <typename Char, typename SpecHandler>\n-FMT_CONSTEXPR const Char *parse_format_specs(\n-    const Char *begin, const Char *end, SpecHandler &&handler) {\n-  if (begin == end || *begin == '}')\n-    return begin;\n+FMT_CONSTEXPR const Char* parse_format_specs(const Char* begin, const Char* end,\n+                                             SpecHandler&& handler) {\n+  if (begin == end || *begin == '}') return begin;\n \n   begin = parse_align(begin, end, handler);\n   if (begin == end) return begin;\n@@ -1941,68 +2399,51 @@ FMT_CONSTEXPR const Char *parse_format_specs(\n \n   // Parse precision.\n   if (*begin == '.') {\n-    ++begin;\n-    auto c = begin != end ? *begin : 0;\n-    if ('0' <= c && c <= '9') {\n-      handler.on_precision(parse_nonnegative_int(begin, end, handler));\n-    } else if (c == '{') {\n-      ++begin;\n-      if (begin != end) {\n-        begin = parse_arg_id(\n-              begin, end, precision_adapter<SpecHandler, Char>(handler));\n-      }\n-      if (begin == end || *begin++ != '}')\n-        return handler.on_error(\"invalid format string\"), begin;\n-    } else {\n-      return handler.on_error(\"missing precision specifier\"), begin;\n-    }\n-    handler.end_precision();\n+    begin = parse_precision(begin, end, handler);\n   }\n \n   // Parse type.\n-  if (begin != end && *begin != '}')\n-    handler.on_type(*begin++);\n+  if (begin != end && *begin != '}') handler.on_type(*begin++);\n   return begin;\n }\n \n // Return the result via the out param to workaround gcc bug 77539.\n template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>\n-FMT_CONSTEXPR bool find(Ptr first, Ptr last, T value, Ptr &out) {\n+FMT_CONSTEXPR bool find(Ptr first, Ptr last, T value, Ptr& out) {\n   for (out = first; out != last; ++out) {\n-    if (*out == value)\n-      return true;\n+    if (*out == value) return true;\n   }\n   return false;\n }\n \n template <>\n-inline bool find<false, char>(\n-    const char *first, const char *last, char value, const char *&out) {\n-  out = static_cast<const char*>(std::memchr(first, value, internal::to_unsigned(last - first)));\n-  return out != FMT_NULL;\n+inline bool find<false, char>(const char* first, const char* last, char value,\n+                              const char*& out) {\n+  out = static_cast<const char*>(\n+      std::memchr(first, value, internal::to_unsigned(last - first)));\n+  return out != nullptr;\n }\n \n-template <typename Handler, typename Char>\n-struct id_adapter {\n+template <typename Handler, typename Char> struct id_adapter {\n   FMT_CONSTEXPR void operator()() { handler.on_arg_id(); }\n-  FMT_CONSTEXPR void operator()(unsigned id) { handler.on_arg_id(id); }\n+  FMT_CONSTEXPR void operator()(int id) { handler.on_arg_id(id); }\n   FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {\n     handler.on_arg_id(id);\n   }\n-  FMT_CONSTEXPR void on_error(const char *message) {\n+  FMT_CONSTEXPR void on_error(const char* message) {\n     handler.on_error(message);\n   }\n-  Handler &handler;\n+  Handler& handler;\n };\n \n template <bool IS_CONSTEXPR, typename Char, typename Handler>\n-FMT_CONSTEXPR void parse_format_string(\n-        basic_string_view<Char> format_str, Handler &&handler) {\n+FMT_CONSTEXPR void parse_format_string(basic_string_view<Char> format_str,\n+                                       Handler&& handler) {\n   struct writer {\n-    FMT_CONSTEXPR void operator()(const Char *begin, const Char *end) {\n+    FMT_CONSTEXPR void operator()(const Char* begin, const Char* end) {\n       if (begin == end) return;\n       for (;;) {\n-        const Char *p = FMT_NULL;\n+        const Char* p = nullptr;\n         if (!find<IS_CONSTEXPR>(begin, end, '}', p))\n           return handler_.on_text(begin, end);\n         ++p;\n@@ -2012,20 +2453,19 @@ FMT_CONSTEXPR void parse_format_string(\n         begin = p + 1;\n       }\n     }\n-    Handler &handler_;\n+    Handler& handler_;\n   } write{handler};\n   auto begin = format_str.data();\n   auto end = begin + format_str.size();\n   while (begin != end) {\n     // Doing two passes with memchr (one for '{' and another for '}') is up to\n     // 2.5x faster than the naive one-pass implementation on big format strings.\n-    const Char *p = begin;\n+    const Char* p = begin;\n     if (*begin != '{' && !find<IS_CONSTEXPR>(begin, end, '{', p))\n       return write(begin, end);\n     write(begin, p);\n     ++p;\n-    if (p == end)\n-      return handler.on_error(\"invalid format string\");\n+    if (p == end) return handler.on_error(\"invalid format string\");\n     if (static_cast<char>(*p) == '}') {\n       handler.on_arg_id();\n       handler.on_replacement_field(p);\n@@ -2049,10 +2489,18 @@ FMT_CONSTEXPR void parse_format_string(\n }\n \n template <typename T, typename ParseContext>\n-FMT_CONSTEXPR const typename ParseContext::char_type *\n-    parse_format_specs(ParseContext &ctx) {\n-  // GCC 7.2 requires initializer.\n-  formatter<T, typename ParseContext::char_type> f{};\n+FMT_CONSTEXPR const typename ParseContext::char_type* parse_format_specs(\n+    ParseContext& ctx) {\n+  using char_type = typename ParseContext::char_type;\n+  using context = buffer_context<char_type>;\n+  using mapped_type =\n+      conditional_t<internal::mapped_type_constant<T, context>::value !=\n+                        internal::custom_type,\n+                    decltype(arg_mapper<context>().map(std::declval<T>())), T>;\n+  conditional_t<has_formatter<mapped_type, context>::value,\n+                formatter<mapped_type, char_type>,\n+                internal::fallback_formatter<T, char_type>>\n+      f;\n   return f.parse(ctx);\n }\n \n@@ -2061,698 +2509,314 @@ class format_string_checker {\n  public:\n   explicit FMT_CONSTEXPR format_string_checker(\n       basic_string_view<Char> format_str, ErrorHandler eh)\n-    : arg_id_((std::numeric_limits<unsigned>::max)()), context_(format_str, eh),\n-      parse_funcs_{&parse_format_specs<Args, parse_context_type>...} {}\n+      : arg_id_((std::numeric_limits<unsigned>::max)()),\n+        context_(format_str, eh),\n+        parse_funcs_{&parse_format_specs<Args, parse_context_type>...} {}\n \n-  FMT_CONSTEXPR void on_text(const Char *, const Char *) {}\n+  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}\n \n   FMT_CONSTEXPR void on_arg_id() {\n     arg_id_ = context_.next_arg_id();\n     check_arg_id();\n   }\n-  FMT_CONSTEXPR void on_arg_id(unsigned id) {\n+  FMT_CONSTEXPR void on_arg_id(int id) {\n     arg_id_ = id;\n     context_.check_arg_id(id);\n     check_arg_id();\n   }\n-  FMT_CONSTEXPR void on_arg_id(basic_string_view<Char>) {}\n-\n-  FMT_CONSTEXPR void on_replacement_field(const Char *) {}\n-\n-  FMT_CONSTEXPR const Char *on_format_specs(const Char *begin, const Char *) {\n-    context_.advance_to(begin);\n-    return arg_id_ < NUM_ARGS ?\n-          parse_funcs_[arg_id_](context_) : begin;\n-  }\n-\n-  FMT_CONSTEXPR void on_error(const char *message) {\n-    context_.on_error(message);\n-  }\n-\n- private:\n-  typedef basic_parse_context<Char, ErrorHandler> parse_context_type;\n-  enum { NUM_ARGS = sizeof...(Args) };\n-\n-  FMT_CONSTEXPR void check_arg_id() {\n-    if (arg_id_ >= NUM_ARGS)\n-      context_.on_error(\"argument index out of range\");\n-  }\n-\n-  // Format specifier parsing function.\n-  typedef const Char *(*parse_func)(parse_context_type &);\n-\n-  unsigned arg_id_;\n-  parse_context_type context_;\n-  parse_func parse_funcs_[NUM_ARGS > 0 ? NUM_ARGS : 1];\n-};\n-\n-template <typename Char, typename ErrorHandler, typename... Args>\n-FMT_CONSTEXPR bool do_check_format_string(\n-    basic_string_view<Char> s, ErrorHandler eh = ErrorHandler()) {\n-  format_string_checker<Char, ErrorHandler, Args...> checker(s, eh);\n-  parse_format_string<true>(s, checker);\n-  return true;\n-}\n-\n-template <typename... Args, typename S>\n-typename std::enable_if<is_compile_string<S>::value>::type\n-    check_format_string(S format_str) {\n-  typedef typename S::char_type char_t;\n-  FMT_CONSTEXPR_DECL bool invalid_format = internal::do_check_format_string<\n-      char_t, internal::error_handler, Args...>(to_string_view(format_str));\n-  (void)invalid_format;\n-}\n-\n-// Specifies whether to format T using the standard formatter.\n-// It is not possible to use get_type in formatter specialization directly\n-// because of a bug in MSVC.\n-template <typename Context, typename T>\n-struct format_type :\n-  std::integral_constant<bool, get_type<Context, T>::value != custom_type> {};\n-\n-template <template <typename> class Handler, typename Spec, typename Context>\n-void handle_dynamic_spec(\n-    Spec &value, arg_ref<typename Context::char_type> ref, Context &ctx) {\n-  typedef typename Context::char_type char_type;\n-  switch (ref.kind) {\n-  case arg_ref<char_type>::NONE:\n-    break;\n-  case arg_ref<char_type>::INDEX:\n-    internal::set_dynamic_spec<Handler>(\n-          value, ctx.get_arg(ref.index), ctx.error_handler());\n-    break;\n-  case arg_ref<char_type>::NAME:\n-    internal::set_dynamic_spec<Handler>(\n-          value, ctx.get_arg({ref.name.value, ref.name.size}),\n-          ctx.error_handler());\n-    break;\n-  }\n-}\n-}  // namespace internal\n-\n-/** The default argument formatter. */\n-template <typename Range>\n-class arg_formatter:\n-  public internal::function<\n-    typename internal::arg_formatter_base<Range>::iterator>,\n-  public internal::arg_formatter_base<Range> {\n- private:\n-  typedef typename Range::value_type char_type;\n-  typedef internal::arg_formatter_base<Range> base;\n-  typedef basic_format_context<typename base::iterator, char_type> context_type;\n-\n-  context_type &ctx_;\n-\n- public:\n-  typedef Range range;\n-  typedef typename base::iterator iterator;\n-  typedef typename base::format_specs format_specs;\n-\n-  /**\n-    \\rst\n-    Constructs an argument formatter object.\n-    *ctx* is a reference to the formatting context,\n-    *spec* contains format specifier information for standard argument types.\n-    \\endrst\n-   */\n-  explicit arg_formatter(context_type &ctx, format_specs *spec = FMT_NULL)\n-  : base(Range(ctx.out()), spec, ctx.locale()), ctx_(ctx) {}\n-\n-  // Deprecated.\n-  arg_formatter(context_type &ctx, format_specs &spec)\n-  : base(Range(ctx.out()), &spec), ctx_(ctx) {}\n-\n-  using base::operator();\n-\n-  /** Formats an argument of a user-defined type. */\n-  iterator operator()(typename basic_format_arg<context_type>::handle handle) {\n-    handle.format(ctx_);\n-    return this->out();\n-  }\n-};\n-\n-/**\n- An error returned by an operating system or a language runtime,\n- for example a file opening error.\n-*/\n-class system_error : public std::runtime_error {\n- private:\n-  FMT_API void init(int err_code, string_view format_str, format_args args);\n-\n- protected:\n-  int error_code_;\n-\n-  system_error() : std::runtime_error(\"\") {}\n-\n- public:\n-  /**\n-   \\rst\n-   Constructs a :class:`fmt::system_error` object with a description\n-   formatted with `fmt::format_system_error`. *message* and additional\n-   arguments passed into the constructor are formatted similarly to\n-   `fmt::format`.\n-\n-   **Example**::\n-\n-     // This throws a system_error with the description\n-     //   cannot open file 'madeup': No such file or directory\n-     // or similar (system message may vary).\n-     const char *filename = \"madeup\";\n-     std::FILE *file = std::fopen(filename, \"r\");\n-     if (!file)\n-       throw fmt::system_error(errno, \"cannot open file '{}'\", filename);\n-   \\endrst\n-  */\n-  template <typename... Args>\n-  system_error(int error_code, string_view message, const Args &... args)\n-    : std::runtime_error(\"\") {\n-    init(error_code, message, make_format_args(args...));\n-  }\n-\n-  int error_code() const { return error_code_; }\n-};\n-\n-/**\n-  \\rst\n-  Formats an error returned by an operating system or a language runtime,\n-  for example a file opening error, and writes it to *out* in the following\n-  form:\n-\n-  .. parsed-literal::\n-     *<message>*: *<system-message>*\n-\n-  where *<message>* is the passed message and *<system-message>* is\n-  the system message corresponding to the error code.\n-  *error_code* is a system error code as given by ``errno``.\n-  If *error_code* is not a valid error code such as -1, the system message\n-  may look like \"Unknown error -1\" and is platform-dependent.\n-  \\endrst\n- */\n-FMT_API void format_system_error(internal::buffer &out, int error_code,\n-                                 fmt::string_view message) FMT_NOEXCEPT;\n-\n-/**\n-  This template provides operations for formatting and writing data into a\n-  character range.\n- */\n-template <typename Range>\n-class basic_writer {\n- public:\n-  typedef typename Range::value_type char_type;\n-  typedef decltype(internal::declval<Range>().begin()) iterator;\n-  typedef basic_format_specs<char_type> format_specs;\n-\n- private:\n-  iterator out_;  // Output iterator.\n-  internal::locale_ref locale_;\n-\n-  // Attempts to reserve space for n extra characters in the output range.\n-  // Returns a pointer to the reserved range or a reference to out_.\n-  auto reserve(std::size_t n) -> decltype(internal::reserve(out_, n)) {\n-    return internal::reserve(out_, n);\n-  }\n-\n-  // Writes a value in the format\n-  //   <left-padding><value><right-padding>\n-  // where <value> is written by f(it).\n-  template <typename F>\n-  void write_padded(const align_spec &spec, F &&f) {\n-    unsigned width = spec.width(); // User-perceived width (in code points).\n-    size_t size = f.size(); // The number of code units.\n-    size_t num_code_points = width != 0 ? f.width() : size;\n-    if (width <= num_code_points)\n-      return f(reserve(size));\n-    auto &&it = reserve(width + (size - num_code_points));\n-    char_type fill = static_cast<char_type>(spec.fill());\n-    std::size_t padding = width - num_code_points;\n-    if (spec.align() == ALIGN_RIGHT) {\n-      it = std::fill_n(it, padding, fill);\n-      f(it);\n-    } else if (spec.align() == ALIGN_CENTER) {\n-      std::size_t left_padding = padding / 2;\n-      it = std::fill_n(it, left_padding, fill);\n-      f(it);\n-      it = std::fill_n(it, padding - left_padding, fill);\n-    } else {\n-      f(it);\n-      it = std::fill_n(it, padding, fill);\n-    }\n-  }\n-\n-  template <typename F>\n-  struct padded_int_writer {\n-    size_t size_;\n-    string_view prefix;\n-    char_type fill;\n-    std::size_t padding;\n-    F f;\n-\n-    size_t size() const { return size_; }\n-    size_t width() const { return size_; }\n-\n-    template <typename It>\n-    void operator()(It &&it) const {\n-      if (prefix.size() != 0)\n-        it = internal::copy_str<char_type>(prefix.begin(), prefix.end(), it);\n-      it = std::fill_n(it, padding, fill);\n-      f(it);\n-    }\n-  };\n-\n-  // Writes an integer in the format\n-  //   <left-padding><prefix><numeric-padding><digits><right-padding>\n-  // where <digits> are written by f(it).\n-  template <typename Spec, typename F>\n-  void write_int(int num_digits, string_view prefix,\n-                 const Spec &spec, F f) {\n-    std::size_t size = prefix.size() + internal::to_unsigned(num_digits);\n-    char_type fill = static_cast<char_type>(spec.fill());\n-    std::size_t padding = 0;\n-    if (spec.align() == ALIGN_NUMERIC) {\n-      if (spec.width() > size) {\n-        padding = spec.width() - size;\n-        size = spec.width();\n-      }\n-    } else if (spec.precision > num_digits) {\n-      size = prefix.size() + internal::to_unsigned(spec.precision);\n-      padding = internal::to_unsigned(spec.precision - num_digits);\n-      fill = static_cast<char_type>('0');\n-    }\n-    align_spec as = spec;\n-    if (spec.align() == ALIGN_DEFAULT)\n-      as.align_ = ALIGN_RIGHT;\n-    write_padded(as, padded_int_writer<F>{size, prefix, fill, padding, f});\n-  }\n-\n-  // Writes a decimal integer.\n-  template <typename Int>\n-  void write_decimal(Int value) {\n-    typedef typename internal::int_traits<Int>::main_type main_type;\n-    main_type abs_value = static_cast<main_type>(value);\n-    bool is_negative = internal::is_negative(value);\n-    if (is_negative)\n-      abs_value = 0 - abs_value;\n-    int num_digits = internal::count_digits(abs_value);\n-    auto &&it = reserve((is_negative ? 1 : 0) + static_cast<size_t>(num_digits));\n-    if (is_negative)\n-      *it++ = static_cast<char_type>('-');\n-    it = internal::format_decimal<char_type>(it, abs_value, num_digits);\n-  }\n-\n-  // The handle_int_type_spec handler that writes an integer.\n-  template <typename Int, typename Spec>\n-  struct int_writer {\n-    typedef typename internal::int_traits<Int>::main_type unsigned_type;\n-\n-    basic_writer<Range> &writer;\n-    const Spec &spec;\n-    unsigned_type abs_value;\n-    char prefix[4];\n-    unsigned prefix_size;\n-\n-    string_view get_prefix() const { return string_view(prefix, prefix_size); }\n-\n-    // Counts the number of digits in abs_value. BITS = log2(radix).\n-    template <unsigned BITS>\n-    int count_digits() const {\n-      unsigned_type n = abs_value;\n-      int num_digits = 0;\n-      do {\n-        ++num_digits;\n-      } while ((n >>= BITS) != 0);\n-      return num_digits;\n-    }\n-\n-    int_writer(basic_writer<Range> &w, Int value, const Spec &s)\n-      : writer(w), spec(s), abs_value(static_cast<unsigned_type>(value)),\n-        prefix_size(0) {\n-      if (internal::is_negative(value)) {\n-        prefix[0] = '-';\n-        ++prefix_size;\n-        abs_value = 0 - abs_value;\n-      } else if (spec.has(SIGN_FLAG)) {\n-        prefix[0] = spec.has(PLUS_FLAG) ? '+' : ' ';\n-        ++prefix_size;\n-      }\n-    }\n-\n-    struct dec_writer {\n-      unsigned_type abs_value;\n-      int num_digits;\n-\n-      template <typename It>\n-      void operator()(It &&it) const {\n-        it = internal::format_decimal<char_type>(it, abs_value, num_digits);\n-      }\n-    };\n-\n-    void on_dec() {\n-      int num_digits = internal::count_digits(abs_value);\n-      writer.write_int(num_digits, get_prefix(), spec,\n-                       dec_writer{abs_value, num_digits});\n-    }\n-\n-    struct hex_writer {\n-      int_writer &self;\n-      int num_digits;\n-\n-      template <typename It>\n-      void operator()(It &&it) const {\n-        it = internal::format_uint<4, char_type>(\n-              it, self.abs_value, num_digits, self.spec.type != 'x');\n-      }\n-    };\n-\n-    void on_hex() {\n-      if (spec.has(HASH_FLAG)) {\n-        prefix[prefix_size++] = '0';\n-        prefix[prefix_size++] = static_cast<char>(spec.type);\n-      }\n-      int num_digits = count_digits<4>();\n-      writer.write_int(num_digits, get_prefix(), spec,\n-                       hex_writer{*this, num_digits});\n-    }\n-\n-    template <int BITS>\n-    struct bin_writer {\n-      unsigned_type abs_value;\n-      int num_digits;\n-\n-      template <typename It>\n-      void operator()(It &&it) const {\n-        it = internal::format_uint<BITS, char_type>(it, abs_value, num_digits);\n-      }\n-    };\n-\n-    void on_bin() {\n-      if (spec.has(HASH_FLAG)) {\n-        prefix[prefix_size++] = '0';\n-        prefix[prefix_size++] = static_cast<char>(spec.type);\n-      }\n-      int num_digits = count_digits<1>();\n-      writer.write_int(num_digits, get_prefix(), spec,\n-                       bin_writer<1>{abs_value, num_digits});\n-    }\n-\n-    void on_oct() {\n-      int num_digits = count_digits<3>();\n-      if (spec.has(HASH_FLAG) &&\n-          spec.precision <= num_digits) {\n-        // Octal prefix '0' is counted as a digit, so only add it if precision\n-        // is not greater than the number of digits.\n-        prefix[prefix_size++] = '0';\n-      }\n-      writer.write_int(num_digits, get_prefix(), spec,\n-                       bin_writer<3>{abs_value, num_digits});\n-    }\n-\n-    enum { SEP_SIZE = 1 };\n-\n-    struct num_writer {\n-      unsigned_type abs_value;\n-      int size;\n-      char_type sep;\n-\n-      template <typename It>\n-      void operator()(It &&it) const {\n-        basic_string_view<char_type> s(&sep, SEP_SIZE);\n-        it = internal::format_decimal<char_type>(\n-              it, abs_value, size, internal::add_thousands_sep<char_type>(s));\n-      }\n-    };\n-\n-    void on_num() {\n-      int num_digits = internal::count_digits(abs_value);\n-      char_type sep = internal::thousands_sep<char_type>(writer.locale_);\n-      int size = num_digits + SEP_SIZE * ((num_digits - 1) / 3);\n-      writer.write_int(size, get_prefix(), spec,\n-                       num_writer{abs_value, size, sep});\n-    }\n-\n-    void on_error() {\n-      FMT_THROW(format_error(\"invalid type specifier\"));\n-    }\n-  };\n-\n-  // Writes a formatted integer.\n-  template <typename T, typename Spec>\n-  void write_int(T value, const Spec &spec) {\n-    internal::handle_int_type_spec(spec.type,\n-                                   int_writer<T, Spec>(*this, value, spec));\n-  }\n-\n-  enum {INF_SIZE = 3}; // This is an enum to workaround a bug in MSVC.\n-\n-  struct inf_or_nan_writer {\n-    char sign;\n-    const char *str;\n+  FMT_CONSTEXPR void on_arg_id(basic_string_view<Char>) {\n+    on_error(\"compile-time checks don't support named arguments\");\n+  }\n \n-    size_t size() const {\n-      return static_cast<std::size_t>(INF_SIZE + (sign ? 1 : 0));\n-    }\n-    size_t width() const { return size(); }\n+  FMT_CONSTEXPR void on_replacement_field(const Char*) {}\n \n-    template <typename It>\n-    void operator()(It &&it) const {\n-      if (sign)\n-        *it++ = static_cast<char_type>(sign);\n-      it = internal::copy_str<char_type>(\n-            str, str + static_cast<std::size_t>(INF_SIZE), it);\n-    }\n-  };\n+  FMT_CONSTEXPR const Char* on_format_specs(const Char* begin, const Char*) {\n+    advance_to(context_, begin);\n+    return arg_id_ < num_args ? parse_funcs_[arg_id_](context_) : begin;\n+  }\n \n-  struct double_writer {\n-    size_t n;\n-    char sign;\n-    internal::buffer &buffer;\n+  FMT_CONSTEXPR void on_error(const char* message) {\n+    context_.on_error(message);\n+  }\n \n-    size_t size() const { return buffer.size() + (sign ? 1 : 0); }\n-    size_t width() const { return size(); }\n+ private:\n+  using parse_context_type = basic_parse_context<Char, ErrorHandler>;\n+  enum { num_args = sizeof...(Args) };\n \n-    template <typename It>\n-    void operator()(It &&it) {\n-      if (sign) {\n-        *it++ = static_cast<char_type>(sign);\n-        --n;\n-      }\n-      it = internal::copy_str<char_type>(buffer.begin(), buffer.end(), it);\n-    }\n-  };\n+  FMT_CONSTEXPR void check_arg_id() {\n+    if (arg_id_ >= num_args) context_.on_error(\"argument index out of range\");\n+  }\n \n-  // Formats a floating-point number (double or long double).\n-  template <typename T>\n-  void write_double(T value, const format_specs &spec);\n+  // Format specifier parsing function.\n+  using parse_func = const Char* (*)(parse_context_type&);\n \n-  template <typename Char>\n-  struct str_writer {\n-    const Char *s;\n-    size_t size_;\n+  unsigned arg_id_;\n+  parse_context_type context_;\n+  parse_func parse_funcs_[num_args > 0 ? num_args : 1];\n+};\n \n-    size_t size() const { return size_; }\n-    size_t width() const {\n-      return internal::count_code_points(basic_string_view<Char>(s, size_));\n-    }\n+template <typename Char, typename ErrorHandler, typename... Args>\n+FMT_CONSTEXPR bool do_check_format_string(basic_string_view<Char> s,\n+                                          ErrorHandler eh = ErrorHandler()) {\n+  format_string_checker<Char, ErrorHandler, Args...> checker(s, eh);\n+  parse_format_string<true>(s, checker);\n+  return true;\n+}\n \n-    template <typename It>\n-    void operator()(It &&it) const {\n-      it = internal::copy_str<char_type>(s, s + size_, it);\n-    }\n-  };\n+template <typename... Args, typename S,\n+          enable_if_t<(is_compile_string<S>::value), int>>\n+void check_format_string(S format_str) {\n+  FMT_CONSTEXPR_DECL bool invalid_format =\n+      internal::do_check_format_string<typename S::char_type,\n+                                       internal::error_handler, Args...>(\n+          to_string_view(format_str));\n+  (void)invalid_format;\n+}\n \n-  template <typename Char>\n-  friend class internal::arg_formatter_base;\n+template <template <typename> class Handler, typename Spec, typename Context>\n+void handle_dynamic_spec(Spec& value, arg_ref<typename Context::char_type> ref,\n+                         Context& ctx,\n+                         const typename Context::char_type* format_str) {\n+  switch (ref.kind) {\n+  case arg_id_kind::none:\n+    break;\n+  case arg_id_kind::index:\n+    internal::set_dynamic_spec<Handler>(value, ctx.arg(ref.val.index),\n+                                        ctx.error_handler());\n+    break;\n+  case arg_id_kind::name: {\n+    const auto arg_id = ref.val.name.to_view(format_str);\n+    internal::set_dynamic_spec<Handler>(value, ctx.arg(arg_id),\n+                                        ctx.error_handler());\n+    break;\n+  }\n+  }\n+}\n+}  // namespace internal\n \n- public:\n-  /** Constructs a ``basic_writer`` object. */\n-  explicit basic_writer(\n-      Range out, internal::locale_ref loc = internal::locale_ref())\n-    : out_(out.begin()), locale_(loc) {}\n+template <typename Range>\n+using basic_writer FMT_DEPRECATED = internal::basic_writer<Range>;\n+using writer FMT_DEPRECATED = internal::writer;\n+using wwriter FMT_DEPRECATED =\n+    internal::basic_writer<internal::buffer_range<wchar_t>>;\n \n-  iterator out() const { return out_; }\n+/** The default argument formatter. */\n+template <typename Range>\n+class arg_formatter : public internal::arg_formatter_base<Range> {\n+ private:\n+  using char_type = typename Range::value_type;\n+  using base = internal::arg_formatter_base<Range>;\n+  using context_type = basic_format_context<typename base::iterator, char_type>;\n \n-  void write(int value) { write_decimal(value); }\n-  void write(long value) { write_decimal(value); }\n-  void write(long long value) { write_decimal(value); }\n+  context_type& ctx_;\n+  basic_parse_context<char_type>* parse_ctx_;\n \n-  void write(unsigned value) { write_decimal(value); }\n-  void write(unsigned long value) { write_decimal(value); }\n-  void write(unsigned long long value) { write_decimal(value); }\n+ public:\n+  using range = Range;\n+  using iterator = typename base::iterator;\n+  using format_specs = typename base::format_specs;\n \n   /**\n     \\rst\n-    Formats *value* and writes it to the buffer.\n+    Constructs an argument formatter object.\n+    *ctx* is a reference to the formatting context,\n+    *specs* contains format specifier information for standard argument types.\n     \\endrst\n    */\n-  template <typename T, typename FormatSpec, typename... FormatSpecs>\n-  typename std::enable_if<std::is_integral<T>::value, void>::type\n-      write(T value, FormatSpec spec, FormatSpecs... specs) {\n-    format_specs s(spec, specs...);\n-    s.align_ = ALIGN_RIGHT;\n-    write_int(value, s);\n-  }\n+  explicit arg_formatter(context_type& ctx,\n+                         basic_parse_context<char_type>* parse_ctx = nullptr,\n+                         format_specs* specs = nullptr)\n+      : base(Range(ctx.out()), specs, ctx.locale()),\n+        ctx_(ctx),\n+        parse_ctx_(parse_ctx) {}\n \n-  void write(double value) {\n-    write_double(value, format_specs());\n-  }\n+  using base::operator();\n \n-  /**\n-    \\rst\n-    Formats *value* using the general format for floating-point numbers\n-    (``'g'``) and writes it to the buffer.\n-    \\endrst\n-   */\n-  void write(long double value) {\n-    write_double(value, format_specs());\n+  /** Formats an argument of a user-defined type. */\n+  iterator operator()(typename basic_format_arg<context_type>::handle handle) {\n+    handle.format(*parse_ctx_, ctx_);\n+    return this->out();\n   }\n+};\n \n-  /** Writes a character to the buffer. */\n-  void write(char value) {\n-    *reserve(1) = value;\n-  }\n-  void write(wchar_t value) {\n-    static_assert(std::is_same<char_type, wchar_t>::value, \"\");\n-    *reserve(1) = value;\n-  }\n+/**\n+ An error returned by an operating system or a language runtime,\n+ for example a file opening error.\n+*/\n+class FMT_API system_error : public std::runtime_error {\n+ private:\n+  void init(int err_code, string_view format_str, format_args args);\n+\n+ protected:\n+  int error_code_;\n+\n+  system_error() : std::runtime_error(\"\"), error_code_(0) {}\n \n+ public:\n   /**\n-    \\rst\n-    Writes *value* to the buffer.\n-    \\endrst\n-   */\n-  void write(string_view value) {\n-    auto &&it = reserve(value.size());\n-    it = internal::copy_str<char_type>(value.begin(), value.end(), it);\n-  }\n-  void write(wstring_view value) {\n-    static_assert(std::is_same<char_type, wchar_t>::value, \"\");\n-    auto &&it = reserve(value.size());\n-    it = std::copy(value.begin(), value.end(), it);\n-  }\n+   \\rst\n+   Constructs a :class:`fmt::system_error` object with a description\n+   formatted with `fmt::format_system_error`. *message* and additional\n+   arguments passed into the constructor are formatted similarly to\n+   `fmt::format`.\n \n-  // Writes a formatted string.\n-  template <typename Char>\n-  void write(const Char *s, std::size_t size, const align_spec &spec) {\n-    write_padded(spec, str_writer<Char>{s, size});\n-  }\n+   **Example**::\n \n-  template <typename Char>\n-  void write(basic_string_view<Char> s,\n-             const format_specs &spec = format_specs()) {\n-    const Char *data = s.data();\n-    std::size_t size = s.size();\n-    if (spec.precision >= 0 && internal::to_unsigned(spec.precision) < size)\n-      size = internal::to_unsigned(spec.precision);\n-    write(data, size, spec);\n+     // This throws a system_error with the description\n+     //   cannot open file 'madeup': No such file or directory\n+     // or similar (system message may vary).\n+     const char *filename = \"madeup\";\n+     std::FILE *file = std::fopen(filename, \"r\");\n+     if (!file)\n+       throw fmt::system_error(errno, \"cannot open file '{}'\", filename);\n+   \\endrst\n+  */\n+  template <typename... Args>\n+  system_error(int error_code, string_view message, const Args&... args)\n+      : std::runtime_error(\"\") {\n+    init(error_code, message, make_format_args(args...));\n   }\n+  ~system_error() FMT_NOEXCEPT;\n \n-  template <typename T>\n-  typename std::enable_if<std::is_same<T, void>::value>::type\n-      write(const T *p) {\n-    format_specs specs;\n-    specs.flags = HASH_FLAG;\n-    specs.type = 'x';\n-    write_int(reinterpret_cast<uintptr_t>(p), specs);\n-  }\n+  int error_code() const { return error_code_; }\n };\n \n+/**\n+  \\rst\n+  Formats an error returned by an operating system or a language runtime,\n+  for example a file opening error, and writes it to *out* in the following\n+  form:\n+\n+  .. parsed-literal::\n+     *<message>*: *<system-message>*\n+\n+  where *<message>* is the passed message and *<system-message>* is\n+  the system message corresponding to the error code.\n+  *error_code* is a system error code as given by ``errno``.\n+  If *error_code* is not a valid error code such as -1, the system message\n+  may look like \"Unknown error -1\" and is platform-dependent.\n+  \\endrst\n+ */\n+FMT_API void format_system_error(internal::buffer<char>& out, int error_code,\n+                                 fmt::string_view message) FMT_NOEXCEPT;\n+\n struct float_spec_handler {\n   char type;\n   bool upper;\n+  bool fixed;\n+  bool as_percentage;\n+  bool use_locale;\n \n-  explicit float_spec_handler(char t) : type(t), upper(false) {}\n+  explicit float_spec_handler(char t)\n+      : type(t),\n+        upper(false),\n+        fixed(false),\n+        as_percentage(false),\n+        use_locale(false) {}\n \n   void on_general() {\n-    if (type == 'G')\n-      upper = true;\n-    else\n-      type = 'g';\n+    if (type == 'G') upper = true;\n   }\n \n   void on_exp() {\n-    if (type == 'E')\n-      upper = true;\n+    if (type == 'E') upper = true;\n   }\n \n   void on_fixed() {\n-    if (type == 'F') {\n-      upper = true;\n-#if FMT_MSC_VER\n-      // MSVC's printf doesn't support 'F'.\n-      type = 'f';\n-#endif\n-    }\n+    fixed = true;\n+    if (type == 'F') upper = true;\n+  }\n+\n+  void on_percent() {\n+    fixed = true;\n+    as_percentage = true;\n   }\n \n   void on_hex() {\n-    if (type == 'A')\n-      upper = true;\n+    if (type == 'A') upper = true;\n   }\n \n-  void on_error() {\n+  void on_num() { use_locale = true; }\n+\n+  FMT_NORETURN void on_error() {\n     FMT_THROW(format_error(\"invalid type specifier\"));\n   }\n };\n \n template <typename Range>\n-template <typename T>\n-void basic_writer<Range>::write_double(T value, const format_specs &spec) {\n+template <typename T, bool USE_GRISU>\n+void internal::basic_writer<Range>::write_double(T value,\n+                                                 const format_specs& specs) {\n   // Check type.\n-  float_spec_handler handler(static_cast<char>(spec.type));\n+  float_spec_handler handler(static_cast<char>(specs.type));\n   internal::handle_float_type_spec(handler.type, handler);\n \n   char sign = 0;\n-  // Use signbit instead of value < 0 because the latter is always\n-  // false for NaN.\n+  // Use signbit instead of value < 0 since the latter is always false for NaN.\n   if (std::signbit(value)) {\n     sign = '-';\n     value = -value;\n-  } else if (spec.has(SIGN_FLAG)) {\n-    sign = spec.has(PLUS_FLAG) ? '+' : ' ';\n+  } else if (specs.sign != sign::none) {\n+    if (specs.sign == sign::plus)\n+      sign = '+';\n+    else if (specs.sign == sign::space)\n+      sign = ' ';\n   }\n \n-  struct write_inf_or_nan_t {\n-    basic_writer &writer;\n-    format_specs spec;\n-    char sign;\n-    void operator()(const char *str) const {\n-      writer.write_padded(spec, inf_or_nan_writer{sign, str});\n-    }\n-  } write_inf_or_nan = {*this, spec, sign};\n+  if (!std::isfinite(value)) {\n+    // Format infinity and NaN ourselves because sprintf's output is not\n+    // consistent across platforms.\n+    const char* str = std::isinf(value) ? (handler.upper ? \"INF\" : \"inf\")\n+                                        : (handler.upper ? \"NAN\" : \"nan\");\n+    return write_padded(specs,\n+                        inf_or_nan_writer{sign, handler.as_percentage, str});\n+  }\n \n-  // Format NaN and ininity ourselves because sprintf's output is not consistent\n-  // across platforms.\n-  if (internal::fputil::isnotanumber(value))\n-    return write_inf_or_nan(handler.upper ? \"NAN\" : \"nan\");\n-  if (internal::fputil::isinfinity(value))\n-    return write_inf_or_nan(handler.upper ? \"INF\" : \"inf\");\n+  if (handler.as_percentage) value *= 100;\n \n   memory_buffer buffer;\n-  bool use_grisu = FMT_USE_GRISU && sizeof(T) <= sizeof(double) &&\n-      spec.type != 'a' && spec.type != 'A' &&\n-      internal::grisu2_format(static_cast<double>(value), buffer, spec);\n-  if (!use_grisu) {\n-    format_specs normalized_spec(spec);\n-    normalized_spec.type = handler.type;\n-    internal::sprintf_format(value, buffer, normalized_spec);\n-  }\n-  size_t n = buffer.size();\n-  align_spec as = spec;\n-  if (spec.align() == ALIGN_NUMERIC) {\n+  int exp = 0;\n+  int precision = specs.precision >= 0 || !specs.type ? specs.precision : 6;\n+  unsigned options = handler.fixed ? internal::grisu_options::fixed : 0;\n+  bool use_grisu = USE_GRISU &&\n+                   (specs.type != 'a' && specs.type != 'A' &&\n+                    specs.type != 'e' && specs.type != 'E') &&\n+                   internal::grisu_format(static_cast<double>(value), buffer,\n+                                          precision, options, exp);\n+  char* decimal_point_pos = nullptr;\n+  if (!use_grisu)\n+    decimal_point_pos = internal::sprintf_format(value, buffer, specs);\n+\n+  if (handler.as_percentage) {\n+    buffer.push_back('%');\n+    --exp;  // Adjust decimal place position.\n+  }\n+  format_specs as = specs;\n+  if (specs.align == align::numeric) {\n     if (sign) {\n-      auto &&it = reserve(1);\n+      auto&& it = reserve(1);\n       *it++ = static_cast<char_type>(sign);\n       sign = 0;\n-      if (as.width_)\n-        --as.width_;\n+      if (as.width) --as.width;\n     }\n-    as.align_ = ALIGN_RIGHT;\n+    as.align = align::right;\n+  } else if (specs.align == align::none) {\n+    as.align = align::right;\n+  }\n+  char_type decimal_point = handler.use_locale\n+                                ? internal::decimal_point<char_type>(locale_)\n+                                : static_cast<char_type>('.');\n+  if (use_grisu) {\n+    auto params = internal::gen_digits_params();\n+    params.fixed = handler.fixed;\n+    params.num_digits = precision;\n+    params.trailing_zeros =\n+        (precision != 0 && (handler.fixed || !specs.type)) || specs.alt;\n+    write_padded(as, grisu_writer(sign, buffer, exp, params, decimal_point));\n   } else {\n-    if (spec.align() == ALIGN_DEFAULT)\n-      as.align_ = ALIGN_RIGHT;\n-    if (sign)\n-      ++n;\n+    write_padded(as,\n+                 double_writer{sign, buffer, decimal_point_pos, decimal_point});\n   }\n-  write_padded(as, double_writer{n, sign, buffer});\n }\n \n // Reports a system error without throwing an exception.\n@@ -2797,7 +2861,7 @@ class windows_error : public system_error {\n    \\endrst\n   */\n   template <typename... Args>\n-  windows_error(int error_code, string_view message, const Args &... args) {\n+  windows_error(int error_code, string_view message, const Args&... args) {\n     init(error_code, message, make_format_args(args...));\n   }\n };\n@@ -2814,40 +2878,38 @@ class format_int {\n  private:\n   // Buffer should be large enough to hold all digits (digits10 + 1),\n   // a sign and a null character.\n-  enum {BUFFER_SIZE = std::numeric_limits<unsigned long long>::digits10 + 3};\n-  mutable char buffer_[BUFFER_SIZE];\n-  char *str_;\n+  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };\n+  mutable char buffer_[buffer_size];\n+  char* str_;\n \n   // Formats value in reverse and returns a pointer to the beginning.\n-  char *format_decimal(unsigned long long value) {\n-    char *ptr = buffer_ + (BUFFER_SIZE - 1);  // Parens to workaround MSVC bug.\n+  char* format_decimal(unsigned long long value) {\n+    char* ptr = buffer_ + (buffer_size - 1);  // Parens to workaround MSVC bug.\n     while (value >= 100) {\n       // Integer division is slow so do it for a group of two digits instead\n       // of for every digit. The idea comes from the talk by Alexandrescu\n       // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n       unsigned index = static_cast<unsigned>((value % 100) * 2);\n       value /= 100;\n-      *--ptr = internal::data::DIGITS[index + 1];\n-      *--ptr = internal::data::DIGITS[index];\n+      *--ptr = internal::data::digits[index + 1];\n+      *--ptr = internal::data::digits[index];\n     }\n     if (value < 10) {\n       *--ptr = static_cast<char>('0' + value);\n       return ptr;\n     }\n     unsigned index = static_cast<unsigned>(value * 2);\n-    *--ptr = internal::data::DIGITS[index + 1];\n-    *--ptr = internal::data::DIGITS[index];\n+    *--ptr = internal::data::digits[index + 1];\n+    *--ptr = internal::data::digits[index];\n     return ptr;\n   }\n \n   void format_signed(long long value) {\n     unsigned long long abs_value = static_cast<unsigned long long>(value);\n     bool negative = value < 0;\n-    if (negative)\n-      abs_value = 0 - abs_value;\n+    if (negative) abs_value = 0 - abs_value;\n     str_ = format_decimal(abs_value);\n-    if (negative)\n-      *--str_ = '-';\n+    if (negative) *--str_ = '-';\n   }\n \n  public:\n@@ -2860,21 +2922,21 @@ class format_int {\n \n   /** Returns the number of characters written to the output buffer. */\n   std::size_t size() const {\n-    return internal::to_unsigned(buffer_ - str_ + BUFFER_SIZE - 1);\n+    return internal::to_unsigned(buffer_ - str_ + buffer_size - 1);\n   }\n \n   /**\n     Returns a pointer to the output buffer content. No terminating null\n     character is appended.\n    */\n-  const char *data() const { return str_; }\n+  const char* data() const { return str_; }\n \n   /**\n     Returns a pointer to the output buffer content with terminating null\n     character appended.\n    */\n-  const char *c_str() const {\n-    buffer_[BUFFER_SIZE - 1] = '\\0';\n+  const char* c_str() const {\n+    buffer_[buffer_size - 1] = '\\0';\n     return str_;\n   }\n \n@@ -2886,52 +2948,24 @@ class format_int {\n   std::string str() const { return std::string(str_, size()); }\n };\n \n-// DEPRECATED!\n-// Formats a decimal integer value writing into buffer and returns\n-// a pointer to the end of the formatted string. This function doesn't\n-// write a terminating null character.\n-template <typename T>\n-inline void format_decimal(char *&buffer, T value) {\n-  typedef typename internal::int_traits<T>::main_type main_type;\n-  main_type abs_value = static_cast<main_type>(value);\n-  if (internal::is_negative(value)) {\n-    *buffer++ = '-';\n-    abs_value = 0 - abs_value;\n-  }\n-  if (abs_value < 100) {\n-    if (abs_value < 10) {\n-      *buffer++ = static_cast<char>('0' + abs_value);\n-      return;\n-    }\n-    unsigned index = static_cast<unsigned>(abs_value * 2);\n-    *buffer++ = internal::data::DIGITS[index];\n-    *buffer++ = internal::data::DIGITS[index + 1];\n-    return;\n-  }\n-  int num_digits = internal::count_digits(abs_value);\n-  internal::format_decimal<char>(\n-        internal::make_checked(buffer, internal::to_unsigned(num_digits)), abs_value, num_digits);\n-  buffer += num_digits;\n-}\n-\n-// Formatter of objects of type T.\n+// A formatter specialization for the core types corresponding to internal::type\n+// constants.\n template <typename T, typename Char>\n-struct formatter<\n-    T, Char,\n-    typename std::enable_if<internal::format_type<\n-        typename buffer_context<Char>::type, T>::value>::type> {\n+struct formatter<T, Char,\n+                 enable_if_t<internal::type_constant<T, Char>::value !=\n+                             internal::custom_type>> {\n+  FMT_CONSTEXPR formatter() : format_str_(nullptr) {}\n \n   // Parses format specifiers stopping either at the end of the range or at the\n   // terminating '}'.\n   template <typename ParseContext>\n-  FMT_CONSTEXPR typename ParseContext::iterator parse(ParseContext &ctx) {\n-    typedef internal::dynamic_specs_handler<ParseContext> handler_type;\n-    auto type = internal::get_type<\n-      typename buffer_context<Char>::type, T>::value;\n-    internal::specs_checker<handler_type>\n-        handler(handler_type(specs_, ctx), type);\n+  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n+    format_str_ = ctx.begin();\n+    using handler_type = internal::dynamic_specs_handler<ParseContext>;\n+    auto type = internal::type_constant<T, Char>::value;\n+    internal::specs_checker<handler_type> handler(handler_type(specs_, ctx),\n+                                                  type);\n     auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);\n-    auto type_spec = specs_.type;\n     auto eh = ctx.error_handler();\n     switch (type) {\n     case internal::none_type:\n@@ -2943,28 +2977,27 @@ struct formatter<\n     case internal::long_long_type:\n     case internal::ulong_long_type:\n     case internal::bool_type:\n-      handle_int_type_spec(\n-            type_spec, internal::int_type_checker<decltype(eh)>(eh));\n+      handle_int_type_spec(specs_.type,\n+                           internal::int_type_checker<decltype(eh)>(eh));\n       break;\n     case internal::char_type:\n       handle_char_specs(\n-          &specs_,\n-          internal::char_specs_checker<decltype(eh)>(type_spec, eh));\n+          &specs_, internal::char_specs_checker<decltype(eh)>(specs_.type, eh));\n       break;\n     case internal::double_type:\n     case internal::long_double_type:\n-      handle_float_type_spec(\n-            type_spec, internal::float_type_checker<decltype(eh)>(eh));\n+      handle_float_type_spec(specs_.type,\n+                             internal::float_type_checker<decltype(eh)>(eh));\n       break;\n     case internal::cstring_type:\n       internal::handle_cstring_type_spec(\n-            type_spec, internal::cstring_type_checker<decltype(eh)>(eh));\n+          specs_.type, internal::cstring_type_checker<decltype(eh)>(eh));\n       break;\n     case internal::string_type:\n-      internal::check_string_type_spec(type_spec, eh);\n+      internal::check_string_type_spec(specs_.type, eh);\n       break;\n     case internal::pointer_type:\n-      internal::check_pointer_type_spec(type_spec, eh);\n+      internal::check_pointer_type_spec(specs_.type, eh);\n       break;\n     case internal::custom_type:\n       // Custom format specifiers should be checked in parse functions of\n@@ -2975,36 +3008,74 @@ struct formatter<\n   }\n \n   template <typename FormatContext>\n-  auto format(const T &val, FormatContext &ctx) -> decltype(ctx.out()) {\n+  auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {\n     internal::handle_dynamic_spec<internal::width_checker>(\n-      specs_.width_, specs_.width_ref, ctx);\n+        specs_.width, specs_.width_ref, ctx, format_str_);\n     internal::handle_dynamic_spec<internal::precision_checker>(\n-      specs_.precision, specs_.precision_ref, ctx);\n-    typedef output_range<typename FormatContext::iterator,\n-                         typename FormatContext::char_type> range_type;\n-    return visit_format_arg(arg_formatter<range_type>(ctx, &specs_),\n-                      internal::make_arg<FormatContext>(val));\n+        specs_.precision, specs_.precision_ref, ctx, format_str_);\n+    using range_type =\n+        internal::output_range<typename FormatContext::iterator,\n+                               typename FormatContext::char_type>;\n+    return visit_format_arg(arg_formatter<range_type>(ctx, nullptr, &specs_),\n+                            internal::make_arg<FormatContext>(val));\n   }\n \n  private:\n   internal::dynamic_format_specs<Char> specs_;\n+  const Char* format_str_;\n+};\n+\n+#define FMT_FORMAT_AS(Type, Base)                                             \\\n+  template <typename Char>                                                    \\\n+  struct formatter<Type, Char> : formatter<Base, Char> {                      \\\n+    template <typename FormatContext>                                         \\\n+    auto format(const Type& val, FormatContext& ctx) -> decltype(ctx.out()) { \\\n+      return formatter<Base, Char>::format(val, ctx);                         \\\n+    }                                                                         \\\n+  }\n+\n+FMT_FORMAT_AS(signed char, int);\n+FMT_FORMAT_AS(unsigned char, unsigned);\n+FMT_FORMAT_AS(short, int);\n+FMT_FORMAT_AS(unsigned short, unsigned);\n+FMT_FORMAT_AS(long, long long);\n+FMT_FORMAT_AS(unsigned long, unsigned long long);\n+FMT_FORMAT_AS(float, double);\n+FMT_FORMAT_AS(Char*, const Char*);\n+FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);\n+FMT_FORMAT_AS(std::nullptr_t, const void*);\n+FMT_FORMAT_AS(internal::std_string_view<Char>, basic_string_view<Char>);\n+\n+template <typename Char>\n+struct formatter<void*, Char> : formatter<const void*, Char> {\n+  template <typename FormatContext>\n+  auto format(void* val, FormatContext& ctx) -> decltype(ctx.out()) {\n+    return formatter<const void*, Char>::format(val, ctx);\n+  }\n+};\n+\n+template <typename Char, size_t N>\n+struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {\n+  template <typename FormatContext>\n+  auto format(const Char* val, FormatContext& ctx) -> decltype(ctx.out()) {\n+    return formatter<basic_string_view<Char>, Char>::format(val, ctx);\n+  }\n };\n \n // A formatter for types known only at run time such as variant alternatives.\n //\n // Usage:\n-//   typedef std::variant<int, std::string> variant;\n+//   using variant = std::variant<int, std::string>;\n //   template <>\n //   struct formatter<variant>: dynamic_formatter<> {\n //     void format(buffer &buf, const variant &v, context &ctx) {\n //       visit([&](const auto &val) { format(buf, val, ctx); }, v);\n //     }\n //   };\n-template <typename Char = char>\n-class dynamic_formatter {\n+template <typename Char = char> class dynamic_formatter {\n  private:\n-  struct null_handler: internal::error_handler {\n-    void on_align(alignment) {}\n+  struct null_handler : internal::error_handler {\n+    void on_align(align_t) {}\n     void on_plus() {}\n     void on_minus() {}\n     void on_space() {}\n@@ -3013,108 +3084,122 @@ class dynamic_formatter {\n \n  public:\n   template <typename ParseContext>\n-  auto parse(ParseContext &ctx) -> decltype(ctx.begin()) {\n+  auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n+    format_str_ = ctx.begin();\n     // Checks are deferred to formatting time when the argument type is known.\n     internal::dynamic_specs_handler<ParseContext> handler(specs_, ctx);\n     return parse_format_specs(ctx.begin(), ctx.end(), handler);\n   }\n \n   template <typename T, typename FormatContext>\n-  auto format(const T &val, FormatContext &ctx) -> decltype(ctx.out()) {\n+  auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {\n     handle_specs(ctx);\n-    internal::specs_checker<null_handler>\n-        checker(null_handler(), internal::get_type<FormatContext, T>::value);\n-    checker.on_align(specs_.align());\n-    if (specs_.flags == 0);  // Do nothing.\n-    else if (specs_.has(SIGN_FLAG))\n-      specs_.has(PLUS_FLAG) ? checker.on_plus() : checker.on_space();\n-    else if (specs_.has(MINUS_FLAG))\n+    internal::specs_checker<null_handler> checker(\n+        null_handler(),\n+        internal::mapped_type_constant<T, FormatContext>::value);\n+    checker.on_align(specs_.align);\n+    switch (specs_.sign) {\n+    case sign::none:\n+      break;\n+    case sign::plus:\n+      checker.on_plus();\n+      break;\n+    case sign::minus:\n       checker.on_minus();\n-    else if (specs_.has(HASH_FLAG))\n-      checker.on_hash();\n-    if (specs_.precision != -1)\n-      checker.end_precision();\n-    typedef output_range<typename FormatContext::iterator,\n-                         typename FormatContext::char_type> range;\n-    visit_format_arg(arg_formatter<range>(ctx, &specs_),\n-               internal::make_arg<FormatContext>(val));\n+      break;\n+    case sign::space:\n+      checker.on_space();\n+      break;\n+    }\n+    if (specs_.alt) checker.on_hash();\n+    if (specs_.precision >= 0) checker.end_precision();\n+    using range = internal::output_range<typename FormatContext::iterator,\n+                                         typename FormatContext::char_type>;\n+    visit_format_arg(arg_formatter<range>(ctx, nullptr, &specs_),\n+                     internal::make_arg<FormatContext>(val));\n     return ctx.out();\n   }\n \n  private:\n-  template <typename Context>\n-  void handle_specs(Context &ctx) {\n+  template <typename Context> void handle_specs(Context& ctx) {\n     internal::handle_dynamic_spec<internal::width_checker>(\n-      specs_.width_, specs_.width_ref, ctx);\n+        specs_.width, specs_.width_ref, ctx, format_str_);\n     internal::handle_dynamic_spec<internal::precision_checker>(\n-      specs_.precision, specs_.precision_ref, ctx);\n+        specs_.precision, specs_.precision_ref, ctx, format_str_);\n   }\n \n   internal::dynamic_format_specs<Char> specs_;\n+  const Char* format_str_;\n };\n \n template <typename Range, typename Char>\n typename basic_format_context<Range, Char>::format_arg\n-  basic_format_context<Range, Char>::get_arg(\n-    basic_string_view<char_type> name) {\n-  map_.init(this->args());\n+basic_format_context<Range, Char>::arg(basic_string_view<char_type> name) {\n+  map_.init(args_);\n   format_arg arg = map_.find(name);\n-  if (arg.type() == internal::none_type)\n-    this->on_error(\"argument not found\");\n+  if (arg.type() == internal::none_type) this->on_error(\"argument not found\");\n   return arg;\n }\n \n+template <typename Char, typename ErrorHandler>\n+FMT_CONSTEXPR void advance_to(basic_parse_context<Char, ErrorHandler>& ctx,\n+                              const Char* p) {\n+  ctx.advance_to(ctx.begin() + (p - &*ctx.begin()));\n+}\n+\n template <typename ArgFormatter, typename Char, typename Context>\n struct format_handler : internal::error_handler {\n-  typedef typename ArgFormatter::range range;\n+  using range = typename ArgFormatter::range;\n \n   format_handler(range r, basic_string_view<Char> str,\n                  basic_format_args<Context> format_args,\n                  internal::locale_ref loc)\n-    : context(r.begin(), str, format_args, loc) {}\n+      : parse_context(str), context(r.begin(), format_args, loc) {}\n \n-  void on_text(const Char *begin, const Char *end) {\n+  void on_text(const Char* begin, const Char* end) {\n     auto size = internal::to_unsigned(end - begin);\n     auto out = context.out();\n-    auto &&it = internal::reserve(out, size);\n+    auto&& it = internal::reserve(out, size);\n     it = std::copy_n(begin, size, it);\n     context.advance_to(out);\n   }\n \n-  void on_arg_id() { arg = context.next_arg(); }\n-  void on_arg_id(unsigned id) {\n-    context.parse_context().check_arg_id(id);\n-    arg = context.get_arg(id);\n-  }\n-  void on_arg_id(basic_string_view<Char> id) {\n-    arg = context.get_arg(id);\n+  void get_arg(int id) { arg = internal::get_arg(context, id); }\n+\n+  void on_arg_id() { get_arg(parse_context.next_arg_id()); }\n+  void on_arg_id(int id) {\n+    parse_context.check_arg_id(id);\n+    get_arg(id);\n   }\n+  void on_arg_id(basic_string_view<Char> id) { arg = context.arg(id); }\n \n-  void on_replacement_field(const Char *p) {\n-    context.parse_context().advance_to(p);\n-    internal::custom_formatter<Char, Context> f(context);\n+  void on_replacement_field(const Char* p) {\n+    advance_to(parse_context, p);\n+    internal::custom_formatter<Context> f(parse_context, context);\n     if (!visit_format_arg(f, arg))\n-      context.advance_to(visit_format_arg(ArgFormatter(context), arg));\n+      context.advance_to(\n+          visit_format_arg(ArgFormatter(context, &parse_context), arg));\n   }\n \n-  const Char *on_format_specs(const Char *begin, const Char *end) {\n-    auto &parse_ctx = context.parse_context();\n-    parse_ctx.advance_to(begin);\n-    internal::custom_formatter<Char, Context> f(context);\n-    if (visit_format_arg(f, arg))\n-      return parse_ctx.begin();\n+  const Char* on_format_specs(const Char* begin, const Char* end) {\n+    advance_to(parse_context, begin);\n+    internal::custom_formatter<Context> f(parse_context, context);\n+    if (visit_format_arg(f, arg)) return parse_context.begin();\n     basic_format_specs<Char> specs;\n     using internal::specs_handler;\n-    internal::specs_checker<specs_handler<Context>>\n-        handler(specs_handler<Context>(specs, context), arg.type());\n+    using parse_context_t = basic_parse_context<Char>;\n+    internal::specs_checker<specs_handler<parse_context_t, Context>> handler(\n+        specs_handler<parse_context_t, Context>(specs, parse_context, context),\n+        arg.type());\n     begin = parse_format_specs(begin, end, handler);\n-    if (begin == end || *begin != '}')\n-      on_error(\"missing '}' in format string\");\n-    parse_ctx.advance_to(begin);\n-    context.advance_to(visit_format_arg(ArgFormatter(context, &specs), arg));\n+    if (begin == end || *begin != '}') on_error(\"missing '}' in format string\");\n+    advance_to(parse_context, begin);\n+    context.advance_to(\n+        visit_format_arg(ArgFormatter(context, &parse_context, &specs), arg));\n     return begin;\n   }\n \n+  basic_parse_context<Char> parse_context;\n   Context context;\n   basic_format_arg<Context> arg;\n };\n@@ -3122,8 +3207,7 @@ struct format_handler : internal::error_handler {\n /** Formats arguments and writes the output to the range. */\n template <typename ArgFormatter, typename Char, typename Context>\n typename Context::iterator vformat_to(\n-    typename ArgFormatter::range out,\n-    basic_string_view<Char> format_str,\n+    typename ArgFormatter::range out, basic_string_view<Char> format_str,\n     basic_format_args<Context> args,\n     internal::locale_ref loc = internal::locale_ref()) {\n   format_handler<ArgFormatter, Char, Context> h(out, format_str, args, loc);\n@@ -3134,26 +3218,29 @@ typename Context::iterator vformat_to(\n // Casts ``p`` to ``const void*`` for pointer formatting.\n // Example:\n //   auto s = format(\"{}\", ptr(p));\n-template <typename T>\n-inline const void *ptr(const T *p) { return p; }\n+template <typename T> inline const void* ptr(const T* p) { return p; }\n+template <typename T> inline const void* ptr(const std::unique_ptr<T>& p) {\n+  return p.get();\n+}\n+template <typename T> inline const void* ptr(const std::shared_ptr<T>& p) {\n+  return p.get();\n+}\n \n-template <typename It, typename Char>\n-struct arg_join {\n+template <typename It, typename Char> struct arg_join : internal::view {\n   It begin;\n   It end;\n   basic_string_view<Char> sep;\n \n-  arg_join(It begin, It end, basic_string_view<Char> sep)\n-    : begin(begin), end(end), sep(sep) {}\n+  arg_join(It b, It e, basic_string_view<Char> s) : begin(b), end(e), sep(s) {}\n };\n \n template <typename It, typename Char>\n-struct formatter<arg_join<It, Char>, Char>:\n-    formatter<typename std::iterator_traits<It>::value_type, Char> {\n+struct formatter<arg_join<It, Char>, Char>\n+    : formatter<typename std::iterator_traits<It>::value_type, Char> {\n   template <typename FormatContext>\n-  auto format(const arg_join<It, Char> &value, FormatContext &ctx)\n+  auto format(const arg_join<It, Char>& value, FormatContext& ctx)\n       -> decltype(ctx.out()) {\n-    typedef formatter<typename std::iterator_traits<It>::value_type, Char> base;\n+    using base = formatter<typename std::iterator_traits<It>::value_type, Char>;\n     auto it = value.begin;\n     auto out = ctx.out();\n     if (it != value.end) {\n@@ -3168,30 +3255,42 @@ struct formatter<arg_join<It, Char>, Char>:\n   }\n };\n \n+/**\n+  Returns an object that formats the iterator range `[begin, end)` with elements\n+  separated by `sep`.\n+ */\n template <typename It>\n arg_join<It, char> join(It begin, It end, string_view sep) {\n-  return arg_join<It, char>(begin, end, sep);\n+  return {begin, end, sep};\n }\n \n template <typename It>\n arg_join<It, wchar_t> join(It begin, It end, wstring_view sep) {\n-  return arg_join<It, wchar_t>(begin, end, sep);\n+  return {begin, end, sep};\n }\n \n-// The following causes ICE in gcc 4.4.\n-#if FMT_USE_TRAILING_RETURN && (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 405)\n+/**\n+  \\rst\n+  Returns an object that formats `range` with elements separated by `sep`.\n+\n+  **Example**::\n+\n+    std::vector<int> v = {1, 2, 3};\n+    fmt::print(\"{}\", fmt::join(v, \", \"));\n+    // Output: \"1, 2, 3\"\n+  \\endrst\n+ */\n template <typename Range>\n-auto join(const Range &range, string_view sep)\n-    -> arg_join<decltype(internal::begin(range)), char> {\n-  return join(internal::begin(range), internal::end(range), sep);\n+arg_join<internal::iterator_t<const Range>, char> join(const Range& range,\n+                                                       string_view sep) {\n+  return join(std::begin(range), std::end(range), sep);\n }\n \n template <typename Range>\n-auto join(const Range &range, wstring_view sep)\n-    -> arg_join<decltype(internal::begin(range)), wchar_t> {\n-  return join(internal::begin(range), internal::end(range), sep);\n+arg_join<internal::iterator_t<const Range>, wchar_t> join(const Range& range,\n+                                                          wstring_view sep) {\n+  return join(std::begin(range), std::end(range), sep);\n }\n-#endif\n \n /**\n   \\rst\n@@ -3205,121 +3304,62 @@ auto join(const Range &range, wstring_view sep)\n     std::string answer = fmt::to_string(42);\n   \\endrst\n  */\n-template <typename T>\n-std::string to_string(const T &value) {\n-  std::string str;\n-  internal::container_buffer<std::string> buf(str);\n-  writer(buf).write(value);\n-  return str;\n+template <typename T> inline std::string to_string(const T& value) {\n+  return format(\"{}\", value);\n }\n \n /**\n   Converts *value* to ``std::wstring`` using the default format for type *T*.\n  */\n-template <typename T>\n-std::wstring to_wstring(const T &value) {\n-  std::wstring str;\n-  internal::container_buffer<std::wstring> buf(str);\n-  wwriter(buf).write(value);\n-  return str;\n+template <typename T> inline std::wstring to_wstring(const T& value) {\n+  return format(L\"{}\", value);\n }\n \n template <typename Char, std::size_t SIZE>\n-std::basic_string<Char> to_string(const basic_memory_buffer<Char, SIZE> &buf) {\n+std::basic_string<Char> to_string(const basic_memory_buffer<Char, SIZE>& buf) {\n   return std::basic_string<Char>(buf.data(), buf.size());\n }\n \n template <typename Char>\n-typename buffer_context<Char>::type::iterator internal::vformat_to(\n-    internal::basic_buffer<Char> &buf, basic_string_view<Char> format_str,\n-    basic_format_args<typename buffer_context<Char>::type> args) {\n-  typedef back_insert_range<internal::basic_buffer<Char> > range;\n-  return vformat_to<arg_formatter<range>>(\n-    buf, to_string_view(format_str), args);\n-}\n-\n-template <typename S, typename Char = FMT_CHAR(S)>\n-inline typename buffer_context<Char>::type::iterator vformat_to(\n-    internal::basic_buffer<Char> &buf, const S &format_str,\n-    basic_format_args<typename buffer_context<Char>::type> args) {\n+typename buffer_context<Char>::iterator internal::vformat_to(\n+    internal::buffer<Char>& buf, basic_string_view<Char> format_str,\n+    basic_format_args<buffer_context<Char>> args) {\n+  using range = buffer_range<Char>;\n+  return vformat_to<arg_formatter<range>>(buf, to_string_view(format_str),\n+                                          args);\n+}\n+\n+template <typename S, typename Char = char_t<S>,\n+          FMT_ENABLE_IF(internal::is_string<S>::value)>\n+inline typename buffer_context<Char>::iterator vformat_to(\n+    internal::buffer<Char>& buf, const S& format_str,\n+    basic_format_args<buffer_context<Char>> args) {\n   return internal::vformat_to(buf, to_string_view(format_str), args);\n }\n \n-template <\n-    typename S, typename... Args,\n-    std::size_t SIZE = inline_buffer_size,\n-    typename Char = typename internal::char_t<S>::type>\n-inline typename buffer_context<Char>::type::iterator format_to(\n-    basic_memory_buffer<Char, SIZE> &buf, const S &format_str,\n-    const Args &... args) {\n+template <typename S, typename... Args, std::size_t SIZE = inline_buffer_size,\n+          typename Char = enable_if_t<internal::is_string<S>::value, char_t<S>>>\n+inline typename buffer_context<Char>::iterator format_to(\n+    basic_memory_buffer<Char, SIZE>& buf, const S& format_str, Args&&... args) {\n   internal::check_format_string<Args...>(format_str);\n-  typedef typename buffer_context<Char>::type context;\n-  format_arg_store<context, Args...> as{args...};\n+  using context = buffer_context<Char>;\n   return internal::vformat_to(buf, to_string_view(format_str),\n-                              basic_format_args<context>(as));\n+                              {make_format_args<context>(args...)});\n }\n \n-namespace internal {\n-\n-// Detect the iterator category of *any* given type in a SFINAE-friendly way.\n-// Unfortunately, older implementations of std::iterator_traits are not safe\n-// for use in a SFINAE-context.\n-\n-// the gist of C++17's void_t magic\n-template<typename... Ts>\n-struct void_ { typedef void type; };\n-\n-template <typename T, typename Enable = void>\n-struct it_category : std::false_type {};\n-\n-template <typename T>\n-struct it_category<T*> { typedef std::random_access_iterator_tag type; };\n-\n-template <typename T>\n-struct it_category<T, typename void_<typename T::iterator_category>::type> {\n-  typedef typename T::iterator_category type;\n-};\n-\n-// Detect if *any* given type models the OutputIterator concept.\n-template <typename It>\n-class is_output_iterator {\n-  // Check for mutability because all iterator categories derived from\n-  // std::input_iterator_tag *may* also meet the requirements of an\n-  // OutputIterator, thereby falling into the category of 'mutable iterators'\n-  // [iterator.requirements.general] clause 4.\n-  // The compiler reveals this property only at the point of *actually\n-  // dereferencing* the iterator!\n-  template <typename U>\n-  static decltype(*(internal::declval<U>())) test(std::input_iterator_tag);\n-  template <typename U>\n-  static char& test(std::output_iterator_tag);\n-  template <typename U>\n-  static const char& test(...);\n-\n-  typedef decltype(test<It>(typename it_category<It>::type{})) type;\n-  typedef typename std::remove_reference<type>::type result;\n- public:\n-  static const bool value = !std::is_const<result>::value;\n-};\n-} // internal\n-\n template <typename OutputIt, typename Char = char>\n-//using format_context_t = basic_format_context<OutputIt, Char>;\n-struct format_context_t { typedef basic_format_context<OutputIt, Char> type; };\n+using format_context_t = basic_format_context<OutputIt, Char>;\n \n template <typename OutputIt, typename Char = char>\n-//using format_args_t = basic_format_args<format_context_t<OutputIt, Char>>;\n-struct format_args_t {\n-  typedef basic_format_args<\n-    typename format_context_t<OutputIt, Char>::type> type;\n-};\n-\n-template <typename String, typename OutputIt, typename... Args>\n-inline typename std::enable_if<internal::is_output_iterator<OutputIt>::value,\n-                               OutputIt>::type\n-    vformat_to(OutputIt out, const String &format_str,\n-               typename format_args_t<OutputIt, FMT_CHAR(String)>::type args) {\n-  typedef output_range<OutputIt, FMT_CHAR(String)> range;\n+using format_args_t = basic_format_args<format_context_t<OutputIt, Char>>;\n+\n+template <typename S, typename OutputIt, typename... Args,\n+          FMT_ENABLE_IF(\n+              internal::is_output_iterator<OutputIt>::value &&\n+              !internal::is_contiguous_back_insert_iterator<OutputIt>::value)>\n+inline OutputIt vformat_to(OutputIt out, const S& format_str,\n+                           format_args_t<OutputIt, char_t<S>> args) {\n+  using range = internal::output_range<OutputIt, char_t<S>>;\n   return vformat_to<arg_formatter<range>>(range(out),\n                                           to_string_view(format_str), args);\n }\n@@ -3335,20 +3375,19 @@ inline typename std::enable_if<internal::is_output_iterator<OutputIt>::value,\n    fmt::format_to(std::back_inserter(out), \"{}\", 42);\n  \\endrst\n  */\n-template <typename OutputIt, typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(\n-    internal::is_string<S>::value &&\n-    internal::is_output_iterator<OutputIt>::value, OutputIt)\n-    format_to(OutputIt out, const S &format_str, const Args &... args) {\n+template <typename OutputIt, typename S, typename... Args,\n+          FMT_ENABLE_IF(\n+              internal::is_output_iterator<OutputIt>::value &&\n+              !internal::is_contiguous_back_insert_iterator<OutputIt>::value &&\n+              internal::is_string<S>::value)>\n+inline OutputIt format_to(OutputIt out, const S& format_str, Args&&... args) {\n   internal::check_format_string<Args...>(format_str);\n-  typedef typename format_context_t<OutputIt, FMT_CHAR(S)>::type context;\n-  format_arg_store<context, Args...> as{args...};\n+  using context = format_context_t<OutputIt, char_t<S>>;\n   return vformat_to(out, to_string_view(format_str),\n-                    basic_format_args<context>(as));\n+                    {make_format_args<context>(args...)});\n }\n \n-template <typename OutputIt>\n-struct format_to_n_result {\n+template <typename OutputIt> struct format_to_n_result {\n   /** Iterator past the end of the output range. */\n   OutputIt out;\n   /** Total (not truncated) output size. */\n@@ -3356,31 +3395,26 @@ struct format_to_n_result {\n };\n \n template <typename OutputIt, typename Char = typename OutputIt::value_type>\n-struct format_to_n_context :\n-  format_context_t<fmt::internal::truncating_iterator<OutputIt>, Char> {};\n+using format_to_n_context =\n+    format_context_t<fmt::internal::truncating_iterator<OutputIt>, Char>;\n \n template <typename OutputIt, typename Char = typename OutputIt::value_type>\n-struct format_to_n_args {\n-  typedef basic_format_args<\n-    typename format_to_n_context<OutputIt, Char>::type> type;\n-};\n+using format_to_n_args = basic_format_args<format_to_n_context<OutputIt, Char>>;\n \n-template <typename OutputIt, typename Char, typename ...Args>\n-inline format_arg_store<\n-  typename format_to_n_context<OutputIt, Char>::type, Args...>\n-    make_format_to_n_args(const Args &... args) {\n-  return format_arg_store<\n-    typename format_to_n_context<OutputIt, Char>::type, Args...>(args...);\n+template <typename OutputIt, typename Char, typename... Args>\n+inline format_arg_store<format_to_n_context<OutputIt, Char>, Args...>\n+make_format_to_n_args(const Args&... args) {\n+  return format_arg_store<format_to_n_context<OutputIt, Char>, Args...>(\n+      args...);\n }\n \n-template <typename OutputIt, typename Char, typename... Args>\n-inline typename std::enable_if<\n-    internal::is_output_iterator<OutputIt>::value,\n-    format_to_n_result<OutputIt>>::type vformat_to_n(\n+template <typename OutputIt, typename Char, typename... Args,\n+          FMT_ENABLE_IF(internal::is_output_iterator<OutputIt>::value)>\n+inline format_to_n_result<OutputIt> vformat_to_n(\n     OutputIt out, std::size_t n, basic_string_view<Char> format_str,\n-    typename format_to_n_args<OutputIt, Char>::type args) {\n-  typedef internal::truncating_iterator<OutputIt> It;\n-  auto it = vformat_to(It(out, n), format_str, args);\n+    format_to_n_args<OutputIt, Char> args) {\n+  auto it = vformat_to(internal::truncating_iterator<OutputIt>(out, n),\n+                       format_str, args);\n   return {it.base(), it.count()};\n }\n \n@@ -3391,25 +3425,22 @@ inline typename std::enable_if<\n  end of the output range.\n  \\endrst\n  */\n-template <typename OutputIt, typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(\n-    internal::is_string<S>::value &&\n-    internal::is_output_iterator<OutputIt>::value,\n-    format_to_n_result<OutputIt>)\n-    format_to_n(OutputIt out, std::size_t n, const S &format_str,\n-                const Args &... args) {\n+template <typename OutputIt, typename S, typename... Args,\n+          FMT_ENABLE_IF(internal::is_string<S>::value&&\n+                            internal::is_output_iterator<OutputIt>::value)>\n+inline format_to_n_result<OutputIt> format_to_n(OutputIt out, std::size_t n,\n+                                                const S& format_str,\n+                                                const Args&... args) {\n   internal::check_format_string<Args...>(format_str);\n-  typedef FMT_CHAR(S) Char;\n-  format_arg_store<\n-      typename format_to_n_context<OutputIt, Char>::type, Args...> as(args...);\n+  using context = format_to_n_context<OutputIt, char_t<S>>;\n   return vformat_to_n(out, n, to_string_view(format_str),\n-                      typename format_to_n_args<OutputIt, Char>::type(as));\n+                      {make_format_args<context>(args...)});\n }\n \n template <typename Char>\n inline std::basic_string<Char> internal::vformat(\n     basic_string_view<Char> format_str,\n-    basic_format_args<typename buffer_context<Char>::type> args) {\n+    basic_format_args<buffer_context<Char>> args) {\n   basic_memory_buffer<Char> buffer;\n   internal::vformat_to(buffer, format_str, args);\n   return fmt::to_string(buffer);\n@@ -3420,8 +3451,7 @@ inline std::basic_string<Char> internal::vformat(\n   ``format(format_str, args...)``.\n  */\n template <typename... Args>\n-inline std::size_t formatted_size(string_view format_str,\n-                                  const Args &... args) {\n+inline std::size_t formatted_size(string_view format_str, const Args&... args) {\n   auto it = format_to(internal::counting_iterator<char>(), format_str, args...);\n   return it.count();\n }\n@@ -3429,53 +3459,52 @@ inline std::size_t formatted_size(string_view format_str,\n #if FMT_USE_USER_DEFINED_LITERALS\n namespace internal {\n \n-# if FMT_UDL_TEMPLATE\n-template <typename Char, Char... CHARS>\n-class udl_formatter {\n+#  if FMT_USE_UDL_TEMPLATE\n+template <typename Char, Char... CHARS> class udl_formatter {\n  public:\n   template <typename... Args>\n-  std::basic_string<Char> operator()(const Args &... args) const {\n+  std::basic_string<Char> operator()(Args&&... args) const {\n     FMT_CONSTEXPR_DECL Char s[] = {CHARS..., '\\0'};\n     FMT_CONSTEXPR_DECL bool invalid_format =\n         do_check_format_string<Char, error_handler, Args...>(\n-          basic_string_view<Char>(s, sizeof...(CHARS)));\n+            basic_string_view<Char>(s, sizeof...(CHARS)));\n     (void)invalid_format;\n-    return format(s, args...);\n+    return format(s, std::forward<Args>(args)...);\n   }\n };\n-# else\n-template <typename Char>\n-struct udl_formatter {\n-  const Char *str;\n+#  else\n+template <typename Char> struct udl_formatter {\n+  basic_string_view<Char> str;\n \n   template <typename... Args>\n-  auto operator()(Args &&... args) const\n-                  -> decltype(format(str, std::forward<Args>(args)...)) {\n+  std::basic_string<Char> operator()(Args&&... args) const {\n     return format(str, std::forward<Args>(args)...);\n   }\n };\n-# endif // FMT_UDL_TEMPLATE\n+#  endif  // FMT_USE_UDL_TEMPLATE\n \n-template <typename Char>\n-struct udl_arg {\n-  const Char *str;\n+template <typename Char> struct udl_arg {\n+  basic_string_view<Char> str;\n \n-  template <typename T>\n-  named_arg<T, Char> operator=(T &&value) const {\n+  template <typename T> named_arg<T, Char> operator=(T&& value) const {\n     return {str, std::forward<T>(value)};\n   }\n };\n \n-} // namespace internal\n+}  // namespace internal\n \n inline namespace literals {\n-\n-# if FMT_UDL_TEMPLATE\n+#  if FMT_USE_UDL_TEMPLATE\n+#    pragma GCC diagnostic push\n+#    if FMT_CLANG_VERSION\n+#      pragma GCC diagnostic ignored \"-Wgnu-string-literal-operator-template\"\n+#    endif\n template <typename Char, Char... CHARS>\n FMT_CONSTEXPR internal::udl_formatter<Char, CHARS...> operator\"\"_format() {\n   return {};\n }\n-# else\n+#    pragma GCC diagnostic pop\n+#  else\n /**\n   \\rst\n   User-defined literal equivalent of :func:`fmt::format`.\n@@ -3486,11 +3515,15 @@ FMT_CONSTEXPR internal::udl_formatter<Char, CHARS...> operator\"\"_format() {\n     std::string message = \"The answer is {}\"_format(42);\n   \\endrst\n  */\n-inline internal::udl_formatter<char>\n-operator\"\" _format(const char *s, std::size_t) { return {s}; }\n-inline internal::udl_formatter<wchar_t>\n-operator\"\" _format(const wchar_t *s, std::size_t) { return {s}; }\n-# endif // FMT_UDL_TEMPLATE\n+FMT_CONSTEXPR internal::udl_formatter<char> operator\"\" _format(const char* s,\n+                                                               std::size_t n) {\n+  return {{s, n}};\n+}\n+FMT_CONSTEXPR internal::udl_formatter<wchar_t> operator\"\" _format(\n+    const wchar_t* s, std::size_t n) {\n+  return {{s, n}};\n+}\n+#  endif  // FMT_USE_UDL_TEMPLATE\n \n /**\n   \\rst\n@@ -3502,24 +3535,41 @@ operator\"\" _format(const wchar_t *s, std::size_t) { return {s}; }\n     fmt::print(\"Elapsed time: {s:.2f} seconds\", \"s\"_a=1.23);\n   \\endrst\n  */\n-inline internal::udl_arg<char>\n-operator\"\" _a(const char *s, std::size_t) { return {s}; }\n-inline internal::udl_arg<wchar_t>\n-operator\"\" _a(const wchar_t *s, std::size_t) { return {s}; }\n-} // inline namespace literals\n-#endif // FMT_USE_USER_DEFINED_LITERALS\n+FMT_CONSTEXPR internal::udl_arg<char> operator\"\" _a(const char* s,\n+                                                    std::size_t n) {\n+  return {{s, n}};\n+}\n+FMT_CONSTEXPR internal::udl_arg<wchar_t> operator\"\" _a(const wchar_t* s,\n+                                                       std::size_t n) {\n+  return {{s, n}};\n+}\n+}  // namespace literals\n+#endif  // FMT_USE_USER_DEFINED_LITERALS\n FMT_END_NAMESPACE\n \n-#define FMT_STRING(s) [] { \\\n-    typedef typename std::remove_cv<std::remove_pointer< \\\n-      typename std::decay<decltype(s)>::type>::type>::type ct; \\\n-    struct str : fmt::compile_string { \\\n-      typedef ct char_type; \\\n-      FMT_CONSTEXPR operator fmt::basic_string_view<ct>() const { \\\n-        return {s, sizeof(s) / sizeof(ct) - 1}; \\\n-      } \\\n-    }; \\\n-    return str{}; \\\n+/**\n+  \\rst\n+  Constructs a compile-time format string.\n+\n+  **Example**::\n+\n+    // A compile-time error because 'd' is an invalid specifier for strings.\n+    std::string s = format(FMT_STRING(\"{:d}\"), \"foo\");\n+  \\endrst\n+ */\n+#define FMT_STRING(s)                                                    \\\n+  [] {                                                                   \\\n+    struct str : fmt::compile_string {                                   \\\n+      using char_type = typename std::remove_cv<std::remove_pointer<     \\\n+          typename std::decay<decltype(s)>::type>::type>::type;          \\\n+      FMT_CONSTEXPR operator fmt::basic_string_view<char_type>() const { \\\n+        return {s, sizeof(s) / sizeof(char_type) - 1};                   \\\n+      }                                                                  \\\n+    } result;                                                            \\\n+    /* Suppress Qt Creator warning about unused operator. */             \\\n+    (void)static_cast<fmt::basic_string_view<typename str::char_type>>(  \\\n+        result);                                                         \\\n+    return result;                                                       \\\n   }()\n \n #if defined(FMT_STRING_ALIAS) && FMT_STRING_ALIAS\n@@ -3537,19 +3587,14 @@ FMT_END_NAMESPACE\n     std::string s = format(fmt(\"{:d}\"), \"foo\");\n   \\endrst\n  */\n-# define fmt(s) FMT_STRING(s)\n+#  define fmt(s) FMT_STRING(s)\n #endif\n \n #ifdef FMT_HEADER_ONLY\n-# define FMT_FUNC inline\n-# include \"format-inl.h\"\n+#  define FMT_FUNC inline\n+#  include \"format-inl.h\"\n #else\n-# define FMT_FUNC\n-#endif\n-\n-// Restore warnings.\n-#if FMT_GCC_VERSION >= 406 || FMT_CLANG_VERSION\n-# pragma GCC diagnostic pop\n+#  define FMT_FUNC\n #endif\n \n #endif  // FMT_FORMAT_H_\ndiff --git a/include/spdlog/fmt/bundled/locale.h b/include/spdlog/fmt/bundled/locale.h\n--- a/include/spdlog/fmt/bundled/locale.h\n+++ b/include/spdlog/fmt/bundled/locale.h\n@@ -8,65 +8,65 @@\n #ifndef FMT_LOCALE_H_\n #define FMT_LOCALE_H_\n \n-#include \"format.h\"\n #include <locale>\n+#include \"format.h\"\n \n FMT_BEGIN_NAMESPACE\n \n namespace internal {\n template <typename Char>\n-typename buffer_context<Char>::type::iterator vformat_to(\n-    const std::locale &loc, basic_buffer<Char> &buf,\n+typename buffer_context<Char>::iterator vformat_to(\n+    const std::locale& loc, buffer<Char>& buf,\n     basic_string_view<Char> format_str,\n-    basic_format_args<typename buffer_context<Char>::type> args) {\n-  typedef back_insert_range<basic_buffer<Char> > range;\n-  return vformat_to<arg_formatter<range>>(\n-    buf, to_string_view(format_str), args, internal::locale_ref(loc));\n+    basic_format_args<buffer_context<Char>> args) {\n+  using range = buffer_range<Char>;\n+  return vformat_to<arg_formatter<range>>(buf, to_string_view(format_str), args,\n+                                          internal::locale_ref(loc));\n }\n \n template <typename Char>\n-std::basic_string<Char> vformat(\n-    const std::locale &loc, basic_string_view<Char> format_str,\n-    basic_format_args<typename buffer_context<Char>::type> args) {\n+std::basic_string<Char> vformat(const std::locale& loc,\n+                                basic_string_view<Char> format_str,\n+                                basic_format_args<buffer_context<Char>> args) {\n   basic_memory_buffer<Char> buffer;\n   internal::vformat_to(loc, buffer, format_str, args);\n   return fmt::to_string(buffer);\n }\n-}\n+}  // namespace internal\n \n-template <typename S, typename Char = FMT_CHAR(S)>\n+template <typename S, typename Char = char_t<S>>\n inline std::basic_string<Char> vformat(\n-    const std::locale &loc, const S &format_str,\n-    basic_format_args<typename buffer_context<Char>::type> args) {\n+    const std::locale& loc, const S& format_str,\n+    basic_format_args<buffer_context<Char>> args) {\n   return internal::vformat(loc, to_string_view(format_str), args);\n }\n \n-template <typename S, typename... Args>\n-inline std::basic_string<FMT_CHAR(S)> format(\n-    const std::locale &loc, const S &format_str, const Args &... args) {\n+template <typename S, typename... Args, typename Char = char_t<S>>\n+inline std::basic_string<Char> format(const std::locale& loc,\n+                                      const S& format_str, Args&&... args) {\n   return internal::vformat(\n-    loc, to_string_view(format_str),\n-    *internal::checked_args<S, Args...>(format_str, args...));\n+      loc, to_string_view(format_str),\n+      {internal::make_args_checked<Args...>(format_str, args...)});\n }\n \n-template <typename String, typename OutputIt, typename... Args>\n-inline typename std::enable_if<internal::is_output_iterator<OutputIt>::value,\n-                               OutputIt>::type\n-    vformat_to(OutputIt out, const std::locale &loc, const String &format_str,\n-               typename format_args_t<OutputIt, FMT_CHAR(String)>::type args) {\n-  typedef output_range<OutputIt, FMT_CHAR(String)> range;\n+template <typename S, typename OutputIt, typename... Args,\n+          typename Char = enable_if_t<\n+              internal::is_output_iterator<OutputIt>::value, char_t<S>>>\n+inline OutputIt vformat_to(OutputIt out, const std::locale& loc,\n+                           const S& format_str,\n+                           format_args_t<OutputIt, Char> args) {\n+  using range = internal::output_range<OutputIt, Char>;\n   return vformat_to<arg_formatter<range>>(\n-    range(out), to_string_view(format_str), args, internal::locale_ref(loc));\n+      range(out), to_string_view(format_str), args, internal::locale_ref(loc));\n }\n \n-template <typename OutputIt, typename S, typename... Args>\n-inline typename std::enable_if<\n-    internal::is_string<S>::value &&\n-    internal::is_output_iterator<OutputIt>::value, OutputIt>::type\n-    format_to(OutputIt out, const std::locale &loc, const S &format_str,\n-              const Args &... args) {\n+template <typename OutputIt, typename S, typename... Args,\n+          FMT_ENABLE_IF(internal::is_output_iterator<OutputIt>::value&&\n+                            internal::is_string<S>::value)>\n+inline OutputIt format_to(OutputIt out, const std::locale& loc,\n+                          const S& format_str, Args&&... args) {\n   internal::check_format_string<Args...>(format_str);\n-  typedef typename format_context_t<OutputIt, FMT_CHAR(S)>::type context;\n+  using context = format_context_t<OutputIt, char_t<S>>;\n   format_arg_store<context, Args...> as{args...};\n   return vformat_to(out, loc, to_string_view(format_str),\n                     basic_format_args<context>(as));\ndiff --git a/include/spdlog/fmt/bundled/ostream.h b/include/spdlog/fmt/bundled/ostream.h\n--- a/include/spdlog/fmt/bundled/ostream.h\n+++ b/include/spdlog/fmt/bundled/ostream.h\n@@ -8,22 +8,21 @@\n #ifndef FMT_OSTREAM_H_\n #define FMT_OSTREAM_H_\n \n-#include \"format.h\"\n #include <ostream>\n+#include \"format.h\"\n \n FMT_BEGIN_NAMESPACE\n namespace internal {\n \n-template <class Char>\n-class formatbuf : public std::basic_streambuf<Char> {\n+template <class Char> class formatbuf : public std::basic_streambuf<Char> {\n  private:\n-  typedef typename std::basic_streambuf<Char>::int_type int_type;\n-  typedef typename std::basic_streambuf<Char>::traits_type traits_type;\n+  using int_type = typename std::basic_streambuf<Char>::int_type;\n+  using traits_type = typename std::basic_streambuf<Char>::traits_type;\n \n-  basic_buffer<Char> &buffer_;\n+  buffer<Char>& buffer_;\n \n  public:\n-  formatbuf(basic_buffer<Char> &buffer) : buffer_(buffer) {}\n+  formatbuf(buffer<Char>& buf) : buffer_(buf) {}\n \n  protected:\n   // The put-area is actually always empty. This makes the implementation\n@@ -39,33 +38,32 @@ class formatbuf : public std::basic_streambuf<Char> {\n     return ch;\n   }\n \n-  std::streamsize xsputn(const Char *s, std::streamsize count) FMT_OVERRIDE {\n+  std::streamsize xsputn(const Char* s, std::streamsize count) FMT_OVERRIDE {\n     buffer_.append(s, s + count);\n     return count;\n   }\n };\n \n-template <typename Char>\n-struct test_stream : std::basic_ostream<Char> {\n+template <typename Char> struct test_stream : std::basic_ostream<Char> {\n  private:\n   struct null;\n   // Hide all operator<< from std::basic_ostream<Char>.\n   void operator<<(null);\n };\n \n-// Checks if T has a user-defined operator<< (e.g. not a member of std::ostream).\n-template <typename T, typename Char>\n-class is_streamable {\n+// Checks if T has a user-defined operator<< (e.g. not a member of\n+// std::ostream).\n+template <typename T, typename Char> class is_streamable {\n  private:\n   template <typename U>\n-  static decltype(\n-    internal::declval<test_stream<Char>&>()\n-      << internal::declval<U>(), std::true_type()) test(int);\n+  static decltype((void)(std::declval<test_stream<Char>&>()\n+                         << std::declval<U>()),\n+                  std::true_type())\n+  test(int);\n \n-  template <typename>\n-  static std::false_type test(...);\n+  template <typename> static std::false_type test(...);\n \n-  typedef decltype(test<T>(0)) result;\n+  using result = decltype(test<T>(0));\n \n  public:\n   static const bool value = result::value;\n@@ -73,65 +71,51 @@ class is_streamable {\n \n // Write the content of buf to os.\n template <typename Char>\n-void write(std::basic_ostream<Char> &os, basic_buffer<Char> &buf) {\n-  const Char *data = buf.data();\n-  typedef std::make_unsigned<std::streamsize>::type UnsignedStreamSize;\n-  UnsignedStreamSize size = buf.size();\n-  UnsignedStreamSize max_size =\n-      internal::to_unsigned((std::numeric_limits<std::streamsize>::max)());\n+void write(std::basic_ostream<Char>& os, buffer<Char>& buf) {\n+  const Char* buf_data = buf.data();\n+  using unsigned_streamsize = std::make_unsigned<std::streamsize>::type;\n+  unsigned_streamsize size = buf.size();\n+  unsigned_streamsize max_size =\n+      to_unsigned((std::numeric_limits<std::streamsize>::max)());\n   do {\n-    UnsignedStreamSize n = size <= max_size ? size : max_size;\n-    os.write(data, static_cast<std::streamsize>(n));\n-    data += n;\n+    unsigned_streamsize n = size <= max_size ? size : max_size;\n+    os.write(buf_data, static_cast<std::streamsize>(n));\n+    buf_data += n;\n     size -= n;\n   } while (size != 0);\n }\n \n template <typename Char, typename T>\n-void format_value(basic_buffer<Char> &buffer, const T &value) {\n-  internal::formatbuf<Char> format_buf(buffer);\n+void format_value(buffer<Char>& buf, const T& value) {\n+  formatbuf<Char> format_buf(buf);\n   std::basic_ostream<Char> output(&format_buf);\n   output.exceptions(std::ios_base::failbit | std::ios_base::badbit);\n   output << value;\n-  buffer.resize(buffer.size());\n+  buf.resize(buf.size());\n }\n-}  // namespace internal\n-\n-// Disable conversion to int if T has an overloaded operator<< which is a free\n-// function (not a member of std::ostream).\n-template <typename T, typename Char>\n-struct convert_to_int<T, Char, void> {\n-  static const bool value =\n-    convert_to_int<T, Char, int>::value &&\n-    !internal::is_streamable<T, Char>::value;\n-};\n \n // Formats an object of type T that has an overloaded ostream operator<<.\n template <typename T, typename Char>\n-struct formatter<T, Char,\n-    typename std::enable_if<\n-      internal::is_streamable<T, Char>::value &&\n-      !internal::format_type<\n-        typename buffer_context<Char>::type, T>::value>::type>\n+struct fallback_formatter<T, Char, enable_if_t<is_streamable<T, Char>::value>>\n     : formatter<basic_string_view<Char>, Char> {\n-\n   template <typename Context>\n-  auto format(const T &value, Context &ctx) -> decltype(ctx.out()) {\n+  auto format(const T& value, Context& ctx) -> decltype(ctx.out()) {\n     basic_memory_buffer<Char> buffer;\n-    internal::format_value(buffer, value);\n+    format_value(buffer, value);\n     basic_string_view<Char> str(buffer.data(), buffer.size());\n     return formatter<basic_string_view<Char>, Char>::format(str, ctx);\n   }\n };\n+}  // namespace internal\n \n template <typename Char>\n-inline void vprint(std::basic_ostream<Char> &os,\n-                   basic_string_view<Char> format_str,\n-                   basic_format_args<typename buffer_context<Char>::type> args) {\n+void vprint(std::basic_ostream<Char>& os, basic_string_view<Char> format_str,\n+            basic_format_args<buffer_context<Char>> args) {\n   basic_memory_buffer<Char> buffer;\n   internal::vformat_to(buffer, format_str, args);\n   internal::write(os, buffer);\n }\n+\n /**\n   \\rst\n   Prints formatted data to the stream *os*.\n@@ -141,12 +125,11 @@ inline void vprint(std::basic_ostream<Char> &os,\n     fmt::print(cerr, \"Don't {}!\", \"panic\");\n   \\endrst\n  */\n-template <typename S, typename... Args>\n-inline typename std::enable_if<internal::is_string<S>::value>::type\n-print(std::basic_ostream<FMT_CHAR(S)> &os, const S &format_str,\n-      const Args & ... args) {\n-  internal::checked_args<S, Args...> ca(format_str, args...);\n-  vprint(os, to_string_view(format_str), *ca);\n+template <typename S, typename... Args,\n+          typename Char = enable_if_t<internal::is_string<S>::value, char_t<S>>>\n+void print(std::basic_ostream<Char>& os, const S& format_str, Args&&... args) {\n+  vprint(os, to_string_view(format_str),\n+         {internal::make_args_checked<Args...>(format_str, args...)});\n }\n FMT_END_NAMESPACE\n \ndiff --git a/include/spdlog/fmt/bundled/posix.h b/include/spdlog/fmt/bundled/posix.h\n--- a/include/spdlog/fmt/bundled/posix.h\n+++ b/include/spdlog/fmt/bundled/posix.h\n@@ -10,7 +10,7 @@\n \n #if defined(__MINGW32__) || defined(__CYGWIN__)\n // Workaround MinGW bug https://sourceforge.net/p/mingw/bugs/2024/.\n-# undef __STRICT_ANSI__\n+#  undef __STRICT_ANSI__\n #endif\n \n #include <errno.h>\n@@ -22,42 +22,42 @@\n #include <cstddef>\n \n #if defined __APPLE__ || defined(__FreeBSD__)\n-# include <xlocale.h>  // for LC_NUMERIC_MASK on OS X\n+#  include <xlocale.h>  // for LC_NUMERIC_MASK on OS X\n #endif\n \n #include \"format.h\"\n \n #ifndef FMT_POSIX\n-# if defined(_WIN32) && !defined(__MINGW32__)\n+#  if defined(_WIN32) && !defined(__MINGW32__)\n // Fix warnings about deprecated symbols.\n-#  define FMT_POSIX(call) _##call\n-# else\n-#  define FMT_POSIX(call) call\n-# endif\n+#    define FMT_POSIX(call) _##call\n+#  else\n+#    define FMT_POSIX(call) call\n+#  endif\n #endif\n \n // Calls to system functions are wrapped in FMT_SYSTEM for testability.\n #ifdef FMT_SYSTEM\n-# define FMT_POSIX_CALL(call) FMT_SYSTEM(call)\n+#  define FMT_POSIX_CALL(call) FMT_SYSTEM(call)\n #else\n-# define FMT_SYSTEM(call) call\n-# ifdef _WIN32\n+#  define FMT_SYSTEM(call) call\n+#  ifdef _WIN32\n // Fix warnings about deprecated symbols.\n-#  define FMT_POSIX_CALL(call) ::_##call\n-# else\n-#  define FMT_POSIX_CALL(call) ::call\n-# endif\n+#    define FMT_POSIX_CALL(call) ::_##call\n+#  else\n+#    define FMT_POSIX_CALL(call) ::call\n+#  endif\n #endif\n \n // Retries the expression while it evaluates to error_result and errno\n // equals to EINTR.\n #ifndef _WIN32\n-# define FMT_RETRY_VAL(result, expression, error_result) \\\n-  do { \\\n-    result = (expression); \\\n-  } while (result == error_result && errno == EINTR)\n+#  define FMT_RETRY_VAL(result, expression, error_result) \\\n+    do {                                                  \\\n+      result = (expression);                              \\\n+    } while (result == error_result && errno == EINTR)\n #else\n-# define FMT_RETRY_VAL(result, expression, error_result) result = (expression)\n+#  define FMT_RETRY_VAL(result, expression, error_result) result = (expression)\n #endif\n \n #define FMT_RETRY(result, expression) FMT_RETRY_VAL(result, expression, -1)\n@@ -69,7 +69,7 @@ FMT_BEGIN_NAMESPACE\n   A reference to a null-terminated string. It can be constructed from a C\n   string or ``std::string``.\n \n-  You can use one of the following typedefs for common character types:\n+  You can use one of the following type aliases for common character types:\n \n   +---------------+-----------------------------+\n   | Type          | Definition                  |\n@@ -89,28 +89,27 @@ FMT_BEGIN_NAMESPACE\n     format(std::string(\"{}\"), 42);\n   \\endrst\n  */\n-template <typename Char>\n-class basic_cstring_view {\n+template <typename Char> class basic_cstring_view {\n  private:\n-  const Char *data_;\n+  const Char* data_;\n \n  public:\n   /** Constructs a string reference object from a C string. */\n-  basic_cstring_view(const Char *s) : data_(s) {}\n+  basic_cstring_view(const Char* s) : data_(s) {}\n \n   /**\n     \\rst\n     Constructs a string reference from an ``std::string`` object.\n     \\endrst\n    */\n-  basic_cstring_view(const std::basic_string<Char> &s) : data_(s.c_str()) {}\n+  basic_cstring_view(const std::basic_string<Char>& s) : data_(s.c_str()) {}\n \n   /** Returns the pointer to a C string. */\n-  const Char *c_str() const { return data_; }\n+  const Char* c_str() const { return data_; }\n };\n \n-typedef basic_cstring_view<char> cstring_view;\n-typedef basic_cstring_view<wchar_t> wcstring_view;\n+using cstring_view = basic_cstring_view<char>;\n+using wcstring_view = basic_cstring_view<wchar_t>;\n \n // An error code.\n class error_code {\n@@ -126,33 +125,32 @@ class error_code {\n // A buffered file.\n class buffered_file {\n  private:\n-  FILE *file_;\n+  FILE* file_;\n \n   friend class file;\n \n-  explicit buffered_file(FILE *f) : file_(f) {}\n+  explicit buffered_file(FILE* f) : file_(f) {}\n \n  public:\n   // Constructs a buffered_file object which doesn't represent any file.\n-  buffered_file() FMT_NOEXCEPT : file_(FMT_NULL) {}\n+  buffered_file() FMT_NOEXCEPT : file_(nullptr) {}\n \n   // Destroys the object closing the file it represents if any.\n   FMT_API ~buffered_file() FMT_NOEXCEPT;\n \n  private:\n-  buffered_file(const buffered_file &) = delete;\n-  void operator=(const buffered_file &) = delete;\n-\n+  buffered_file(const buffered_file&) = delete;\n+  void operator=(const buffered_file&) = delete;\n \n  public:\n-  buffered_file(buffered_file &&other) FMT_NOEXCEPT : file_(other.file_) {\n-    other.file_ = FMT_NULL;\n+  buffered_file(buffered_file&& other) FMT_NOEXCEPT : file_(other.file_) {\n+    other.file_ = nullptr;\n   }\n \n-  buffered_file& operator=(buffered_file &&other) {\n+  buffered_file& operator=(buffered_file&& other) {\n     close();\n     file_ = other.file_;\n-    other.file_ = FMT_NULL;\n+    other.file_ = nullptr;\n     return *this;\n   }\n \n@@ -163,18 +161,18 @@ class buffered_file {\n   FMT_API void close();\n \n   // Returns the pointer to a FILE object representing this file.\n-  FILE *get() const FMT_NOEXCEPT { return file_; }\n+  FILE* get() const FMT_NOEXCEPT { return file_; }\n \n   // We place parentheses around fileno to workaround a bug in some versions\n   // of MinGW that define fileno as a macro.\n-  FMT_API int (fileno)() const;\n+  FMT_API int(fileno)() const;\n \n   void vprint(string_view format_str, format_args args) {\n     fmt::vprint(file_, format_str, args);\n   }\n \n   template <typename... Args>\n-  inline void print(string_view format_str, const Args & ... args) {\n+  inline void print(string_view format_str, const Args&... args) {\n     vprint(format_str, make_format_args(args...));\n   }\n };\n@@ -195,9 +193,9 @@ class file {\n  public:\n   // Possible values for the oflag argument to the constructor.\n   enum {\n-    RDONLY = FMT_POSIX(O_RDONLY), // Open for reading only.\n-    WRONLY = FMT_POSIX(O_WRONLY), // Open for writing only.\n-    RDWR   = FMT_POSIX(O_RDWR)    // Open for reading and writing.\n+    RDONLY = FMT_POSIX(O_RDONLY),  // Open for reading only.\n+    WRONLY = FMT_POSIX(O_WRONLY),  // Open for writing only.\n+    RDWR = FMT_POSIX(O_RDWR)       // Open for reading and writing.\n   };\n \n   // Constructs a file object which doesn't represent any file.\n@@ -207,15 +205,13 @@ class file {\n   FMT_API file(cstring_view path, int oflag);\n \n  private:\n-  file(const file &) = delete;\n-  void operator=(const file &) = delete;\n+  file(const file&) = delete;\n+  void operator=(const file&) = delete;\n \n  public:\n-  file(file &&other) FMT_NOEXCEPT : fd_(other.fd_) {\n-    other.fd_ = -1;\n-  }\n+  file(file&& other) FMT_NOEXCEPT : fd_(other.fd_) { other.fd_ = -1; }\n \n-  file& operator=(file &&other) {\n+  file& operator=(file&& other) {\n     close();\n     fd_ = other.fd_;\n     other.fd_ = -1;\n@@ -236,10 +232,10 @@ class file {\n   FMT_API long long size() const;\n \n   // Attempts to read count bytes from the file into the specified buffer.\n-  FMT_API std::size_t read(void *buffer, std::size_t count);\n+  FMT_API std::size_t read(void* buffer, std::size_t count);\n \n   // Attempts to write count bytes from the specified buffer to the file.\n-  FMT_API std::size_t write(const void *buffer, std::size_t count);\n+  FMT_API std::size_t write(const void* buffer, std::size_t count);\n \n   // Duplicates a file descriptor with the dup function and returns\n   // the duplicate as a file object.\n@@ -251,68 +247,59 @@ class file {\n \n   // Makes fd be the copy of this file descriptor, closing fd first if\n   // necessary.\n-  FMT_API void dup2(int fd, error_code &ec) FMT_NOEXCEPT;\n+  FMT_API void dup2(int fd, error_code& ec) FMT_NOEXCEPT;\n \n   // Creates a pipe setting up read_end and write_end file objects for reading\n   // and writing respectively.\n-  FMT_API static void pipe(file &read_end, file &write_end);\n+  FMT_API static void pipe(file& read_end, file& write_end);\n \n   // Creates a buffered_file object associated with this file and detaches\n   // this file object from the file.\n-  FMT_API buffered_file fdopen(const char *mode);\n+  FMT_API buffered_file fdopen(const char* mode);\n };\n \n // Returns the memory page size.\n long getpagesize();\n \n-#if (defined(LC_NUMERIC_MASK) || defined(_MSC_VER)) && \\\n-    !defined(__ANDROID__) && !defined(__CYGWIN__) && !defined(__OpenBSD__) && \\\n-    !defined(__NEWLIB_H__)\n-# define FMT_LOCALE\n-#endif\n-\n #ifdef FMT_LOCALE\n // A \"C\" numeric locale.\n class Locale {\n  private:\n-# ifdef _MSC_VER\n-  typedef _locale_t locale_t;\n+#  ifdef _WIN32\n+  using locale_t = _locale_t;\n \n   enum { LC_NUMERIC_MASK = LC_NUMERIC };\n \n-  static locale_t newlocale(int category_mask, const char *locale, locale_t) {\n+  static locale_t newlocale(int category_mask, const char* locale, locale_t) {\n     return _create_locale(category_mask, locale);\n   }\n \n-  static void freelocale(locale_t locale) {\n-    _free_locale(locale);\n-  }\n+  static void freelocale(locale_t locale) { _free_locale(locale); }\n \n-  static double strtod_l(const char *nptr, char **endptr, _locale_t locale) {\n+  static double strtod_l(const char* nptr, char** endptr, _locale_t locale) {\n     return _strtod_l(nptr, endptr, locale);\n   }\n-# endif\n+#  endif\n \n   locale_t locale_;\n \n-  Locale(const Locale &) = delete;\n-  void operator=(const Locale &) = delete;\n+  Locale(const Locale&) = delete;\n+  void operator=(const Locale&) = delete;\n \n  public:\n-  typedef locale_t Type;\n+  using type = locale_t;\n \n-  Locale() : locale_(newlocale(LC_NUMERIC_MASK, \"C\", FMT_NULL)) {\n-    if (!locale_)\n-      FMT_THROW(system_error(errno, \"cannot create locale\"));\n+  Locale() : locale_(newlocale(LC_NUMERIC_MASK, \"C\", nullptr)) {\n+    if (!locale_) FMT_THROW(system_error(errno, \"cannot create locale\"));\n   }\n   ~Locale() { freelocale(locale_); }\n \n-  Type get() const { return locale_; }\n+  type get() const { return locale_; }\n \n   // Converts string to floating-point number and advances str past the end\n   // of the parsed input.\n-  double strtod(const char *&str) const {\n-    char *end = FMT_NULL;\n+  double strtod(const char*& str) const {\n+    char* end = nullptr;\n     double result = strtod_l(str, &end, locale_);\n     str = end;\n     return result;\ndiff --git a/include/spdlog/fmt/bundled/printf.h b/include/spdlog/fmt/bundled/printf.h\n--- a/include/spdlog/fmt/bundled/printf.h\n+++ b/include/spdlog/fmt/bundled/printf.h\n@@ -16,221 +16,90 @@\n FMT_BEGIN_NAMESPACE\n namespace internal {\n \n-// An iterator that produces a null terminator on *end. This simplifies parsing\n-// and allows comparing the performance of processing a null-terminated string\n-// vs string_view.\n-template <typename Char>\n-class null_terminating_iterator {\n- public:\n-  typedef std::ptrdiff_t difference_type;\n-  typedef Char value_type;\n-  typedef const Char* pointer;\n-  typedef const Char& reference;\n-  typedef std::random_access_iterator_tag iterator_category;\n-\n-  null_terminating_iterator() : ptr_(0), end_(0) {}\n-\n-  FMT_CONSTEXPR null_terminating_iterator(const Char *ptr, const Char *end)\n-    : ptr_(ptr), end_(end) {}\n-\n-  template <typename Range>\n-  FMT_CONSTEXPR explicit null_terminating_iterator(const Range &r)\n-    : ptr_(r.begin()), end_(r.end()) {}\n-\n-  FMT_CONSTEXPR null_terminating_iterator &operator=(const Char *ptr) {\n-    assert(ptr <= end_);\n-    ptr_ = ptr;\n-    return *this;\n-  }\n-\n-  FMT_CONSTEXPR Char operator*() const {\n-    return ptr_ != end_ ? *ptr_ : Char();\n-  }\n-\n-  FMT_CONSTEXPR null_terminating_iterator operator++() {\n-    ++ptr_;\n-    return *this;\n-  }\n-\n-  FMT_CONSTEXPR null_terminating_iterator operator++(int) {\n-    null_terminating_iterator result(*this);\n-    ++ptr_;\n-    return result;\n-  }\n-\n-  FMT_CONSTEXPR null_terminating_iterator operator--() {\n-    --ptr_;\n-    return *this;\n-  }\n-\n-  FMT_CONSTEXPR null_terminating_iterator operator+(difference_type n) {\n-    return null_terminating_iterator(ptr_ + n, end_);\n-  }\n-\n-  FMT_CONSTEXPR null_terminating_iterator operator-(difference_type n) {\n-    return null_terminating_iterator(ptr_ - n, end_);\n-  }\n-\n-  FMT_CONSTEXPR null_terminating_iterator operator+=(difference_type n) {\n-    ptr_ += n;\n-    return *this;\n-  }\n-\n-  FMT_CONSTEXPR difference_type operator-(\n-      null_terminating_iterator other) const {\n-    return ptr_ - other.ptr_;\n-  }\n-\n-  FMT_CONSTEXPR bool operator!=(null_terminating_iterator other) const {\n-    return ptr_ != other.ptr_;\n-  }\n-\n-  bool operator>=(null_terminating_iterator other) const {\n-    return ptr_ >= other.ptr_;\n-  }\n-\n-  // This should be a friend specialization pointer_from<Char> but the latter\n-  // doesn't compile by gcc 5.1 due to a compiler bug.\n-  template <typename CharT>\n-  friend FMT_CONSTEXPR_DECL const CharT *pointer_from(\n-      null_terminating_iterator<CharT> it);\n-\n- private:\n-  const Char *ptr_;\n-  const Char *end_;\n-};\n-\n-template <typename T>\n-FMT_CONSTEXPR const T *pointer_from(const T *p) { return p; }\n-\n-template <typename Char>\n-FMT_CONSTEXPR const Char *pointer_from(null_terminating_iterator<Char> it) {\n-  return it.ptr_;\n-}\n-\n-// DEPRECATED: Parses the input as an unsigned integer. This function assumes\n-// that the first character is a digit and presence of a non-digit character at\n-// the end.\n-// it: an iterator pointing to the beginning of the input range.\n-template <typename Iterator, typename ErrorHandler>\n-FMT_CONSTEXPR unsigned parse_nonnegative_int(Iterator &it, ErrorHandler &&eh) {\n-  assert('0' <= *it && *it <= '9');\n-  if (*it == '0') {\n-    ++it;\n-    return 0;\n-  }\n-  unsigned value = 0;\n-  // Convert to unsigned to prevent a warning.\n-  unsigned max_int = (std::numeric_limits<int>::max)();\n-  unsigned big = max_int / 10;\n-  do {\n-    // Check for overflow.\n-    if (value > big) {\n-      value = max_int + 1;\n-      break;\n-    }\n-    value = value * 10 + unsigned(*it - '0');\n-    // Workaround for MSVC \"setup_exception stack overflow\" error:\n-    auto next = it;\n-    ++next;\n-    it = next;\n-  } while ('0' <= *it && *it <= '9');\n-  if (value > max_int)\n-    eh.on_error(\"number is too big\");\n-  return value;\n-}\n+// A helper function to suppress bogus \"conditional expression is constant\"\n+// warnings.\n+template <typename T> inline T const_check(T value) { return value; }\n \n // Checks if a value fits in int - used to avoid warnings about comparing\n // signed and unsigned integers.\n-template <bool IsSigned>\n-struct int_checker {\n-  template <typename T>\n-  static bool fits_in_int(T value) {\n+template <bool IsSigned> struct int_checker {\n+  template <typename T> static bool fits_in_int(T value) {\n     unsigned max = std::numeric_limits<int>::max();\n     return value <= max;\n   }\n   static bool fits_in_int(bool) { return true; }\n };\n \n-template <>\n-struct int_checker<true> {\n-  template <typename T>\n-  static bool fits_in_int(T value) {\n+template <> struct int_checker<true> {\n+  template <typename T> static bool fits_in_int(T value) {\n     return value >= std::numeric_limits<int>::min() &&\n            value <= std::numeric_limits<int>::max();\n   }\n   static bool fits_in_int(int) { return true; }\n };\n \n-class printf_precision_handler: public function<int> {\n+class printf_precision_handler {\n  public:\n-  template <typename T>\n-  typename std::enable_if<std::is_integral<T>::value, int>::type\n-      operator()(T value) {\n+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+  int operator()(T value) {\n     if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))\n       FMT_THROW(format_error(\"number is too big\"));\n-    return static_cast<int>(value);\n+    return (std::max)(static_cast<int>(value), 0);\n   }\n \n-  template <typename T>\n-  typename std::enable_if<!std::is_integral<T>::value, int>::type operator()(T) {\n+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>\n+  int operator()(T) {\n     FMT_THROW(format_error(\"precision is not integer\"));\n     return 0;\n   }\n };\n \n // An argument visitor that returns true iff arg is a zero integer.\n-class is_zero_int: public function<bool> {\n+class is_zero_int {\n  public:\n-  template <typename T>\n-  typename std::enable_if<std::is_integral<T>::value, bool>::type\n-      operator()(T value) { return value == 0; }\n+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+  bool operator()(T value) {\n+    return value == 0;\n+  }\n \n-  template <typename T>\n-  typename std::enable_if<!std::is_integral<T>::value, bool>::type\n-      operator()(T) { return false; }\n+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>\n+  bool operator()(T) {\n+    return false;\n+  }\n };\n \n-template <typename T>\n-struct make_unsigned_or_bool : std::make_unsigned<T> {};\n+template <typename T> struct make_unsigned_or_bool : std::make_unsigned<T> {};\n \n-template <>\n-struct make_unsigned_or_bool<bool> {\n-  typedef bool type;\n-};\n+template <> struct make_unsigned_or_bool<bool> { using type = bool; };\n \n-template <typename T, typename Context>\n-class arg_converter: public function<void> {\n+template <typename T, typename Context> class arg_converter {\n  private:\n-  typedef typename Context::char_type Char;\n+  using char_type = typename Context::char_type;\n \n-  basic_format_arg<Context> &arg_;\n-  typename Context::char_type type_;\n+  basic_format_arg<Context>& arg_;\n+  char_type type_;\n \n  public:\n-  arg_converter(basic_format_arg<Context> &arg, Char type)\n-    : arg_(arg), type_(type) {}\n+  arg_converter(basic_format_arg<Context>& arg, char_type type)\n+      : arg_(arg), type_(type) {}\n \n   void operator()(bool value) {\n-    if (type_ != 's')\n-      operator()<bool>(value);\n+    if (type_ != 's') operator()<bool>(value);\n   }\n \n-  template <typename U>\n-  typename std::enable_if<std::is_integral<U>::value>::type\n-      operator()(U value) {\n+  template <typename U, FMT_ENABLE_IF(std::is_integral<U>::value)>\n+  void operator()(U value) {\n     bool is_signed = type_ == 'd' || type_ == 'i';\n-    typedef typename std::conditional<\n-        std::is_same<T, void>::value, U, T>::type TargetType;\n-    if (const_check(sizeof(TargetType) <= sizeof(int))) {\n+    using target_type = conditional_t<std::is_same<T, void>::value, U, T>;\n+    if (const_check(sizeof(target_type) <= sizeof(int))) {\n       // Extra casts are used to silence warnings.\n       if (is_signed) {\n         arg_ = internal::make_arg<Context>(\n-          static_cast<int>(static_cast<TargetType>(value)));\n+            static_cast<int>(static_cast<target_type>(value)));\n       } else {\n-        typedef typename make_unsigned_or_bool<TargetType>::type Unsigned;\n+        using unsigned_type = typename make_unsigned_or_bool<target_type>::type;\n         arg_ = internal::make_arg<Context>(\n-          static_cast<unsigned>(static_cast<Unsigned>(value)));\n+            static_cast<unsigned>(static_cast<unsigned_type>(value)));\n       }\n     } else {\n       if (is_signed) {\n@@ -240,15 +109,13 @@ class arg_converter: public function<void> {\n         arg_ = internal::make_arg<Context>(static_cast<long long>(value));\n       } else {\n         arg_ = internal::make_arg<Context>(\n-          static_cast<typename make_unsigned_or_bool<U>::type>(value));\n+            static_cast<typename make_unsigned_or_bool<U>::type>(value));\n       }\n     }\n   }\n \n-  template <typename U>\n-  typename std::enable_if<!std::is_integral<U>::value>::type operator()(U) {\n-    // No coversion needed for non-integral types.\n-  }\n+  template <typename U, FMT_ENABLE_IF(!std::is_integral<U>::value)>\n+  void operator()(U) {}  // No conversion needed for non-integral types.\n };\n \n // Converts an integer argument to T for printf, if T is an integral type.\n@@ -256,84 +123,77 @@ class arg_converter: public function<void> {\n // type depending on the type specifier: 'd' and 'i' - signed, other -\n // unsigned).\n template <typename T, typename Context, typename Char>\n-void convert_arg(basic_format_arg<Context> &arg, Char type) {\n+void convert_arg(basic_format_arg<Context>& arg, Char type) {\n   visit_format_arg(arg_converter<T, Context>(arg, type), arg);\n }\n \n // Converts an integer argument to char for printf.\n-template <typename Context>\n-class char_converter: public function<void> {\n+template <typename Context> class char_converter {\n  private:\n-  basic_format_arg<Context> &arg_;\n+  basic_format_arg<Context>& arg_;\n \n  public:\n-  explicit char_converter(basic_format_arg<Context> &arg) : arg_(arg) {}\n+  explicit char_converter(basic_format_arg<Context>& arg) : arg_(arg) {}\n \n-  template <typename T>\n-  typename std::enable_if<std::is_integral<T>::value>::type\n-      operator()(T value) {\n-    typedef typename Context::char_type Char;\n-    arg_ = internal::make_arg<Context>(static_cast<Char>(value));\n+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+  void operator()(T value) {\n+    arg_ = internal::make_arg<Context>(\n+        static_cast<typename Context::char_type>(value));\n   }\n \n-  template <typename T>\n-  typename std::enable_if<!std::is_integral<T>::value>::type operator()(T) {\n-    // No coversion needed for non-integral types.\n-  }\n+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>\n+  void operator()(T) {}  // No conversion needed for non-integral types.\n };\n \n // Checks if an argument is a valid printf width specifier and sets\n // left alignment if it is negative.\n-template <typename Char>\n-class printf_width_handler: public function<unsigned> {\n+template <typename Char> class printf_width_handler {\n  private:\n-  typedef basic_format_specs<Char> format_specs;\n+  using format_specs = basic_format_specs<Char>;\n \n-  format_specs &spec_;\n+  format_specs& specs_;\n \n  public:\n-  explicit printf_width_handler(format_specs &spec) : spec_(spec) {}\n+  explicit printf_width_handler(format_specs& specs) : specs_(specs) {}\n \n-  template <typename T>\n-  typename std::enable_if<std::is_integral<T>::value, unsigned>::type\n-      operator()(T value) {\n-    typedef typename internal::int_traits<T>::main_type UnsignedType;\n-    UnsignedType width = static_cast<UnsignedType>(value);\n+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+  unsigned operator()(T value) {\n+    auto width = static_cast<uint32_or_64_t<T>>(value);\n     if (internal::is_negative(value)) {\n-      spec_.align_ = ALIGN_LEFT;\n+      specs_.align = align::left;\n       width = 0 - width;\n     }\n     unsigned int_max = std::numeric_limits<int>::max();\n-    if (width > int_max)\n-      FMT_THROW(format_error(\"number is too big\"));\n+    if (width > int_max) FMT_THROW(format_error(\"number is too big\"));\n     return static_cast<unsigned>(width);\n   }\n \n-  template <typename T>\n-  typename std::enable_if<!std::is_integral<T>::value, unsigned>::type\n-      operator()(T) {\n+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>\n+  unsigned operator()(T) {\n     FMT_THROW(format_error(\"width is not integer\"));\n     return 0;\n   }\n };\n \n template <typename Char, typename Context>\n-void printf(basic_buffer<Char> &buf, basic_string_view<Char> format,\n+void printf(buffer<Char>& buf, basic_string_view<Char> format,\n             basic_format_args<Context> args) {\n   Context(std::back_inserter(buf), format, args).format();\n }\n+\n+template <typename OutputIt, typename Char, typename Context>\n+internal::truncating_iterator<OutputIt> printf(\n+    internal::truncating_iterator<OutputIt> it, basic_string_view<Char> format,\n+    basic_format_args<Context> args) {\n+  return Context(it, format, args).format();\n+}\n }  // namespace internal\n \n using internal::printf;  // For printing into memory_buffer.\n \n-template <typename Range>\n-class printf_arg_formatter;\n+template <typename Range> class printf_arg_formatter;\n \n-template <\n-    typename OutputIt, typename Char,\n-    typename ArgFormatter =\n-      printf_arg_formatter<back_insert_range<internal::basic_buffer<Char>>>>\n-class basic_printf_context;\n+template <typename OutputIt, typename Char> class basic_printf_context;\n \n /**\n   \\rst\n@@ -341,61 +201,56 @@ class basic_printf_context;\n   \\endrst\n  */\n template <typename Range>\n-class printf_arg_formatter:\n-  public internal::function<\n-    typename internal::arg_formatter_base<Range>::iterator>,\n-  public internal::arg_formatter_base<Range> {\n+class printf_arg_formatter : public internal::arg_formatter_base<Range> {\n+ public:\n+  using iterator = typename Range::iterator;\n+\n  private:\n-  typedef typename Range::value_type char_type;\n-  typedef decltype(internal::declval<Range>().begin()) iterator;\n-  typedef internal::arg_formatter_base<Range> base;\n-  typedef basic_printf_context<iterator, char_type> context_type;\n+  using char_type = typename Range::value_type;\n+  using base = internal::arg_formatter_base<Range>;\n+  using context_type = basic_printf_context<iterator, char_type>;\n \n-  context_type &context_;\n+  context_type& context_;\n \n   void write_null_pointer(char) {\n-    this->spec()->type = 0;\n+    this->specs()->type = 0;\n     this->write(\"(nil)\");\n   }\n \n   void write_null_pointer(wchar_t) {\n-    this->spec()->type = 0;\n+    this->specs()->type = 0;\n     this->write(L\"(nil)\");\n   }\n \n  public:\n-  typedef typename base::format_specs format_specs;\n+  using format_specs = typename base::format_specs;\n \n   /**\n     \\rst\n     Constructs an argument formatter object.\n-    *buffer* is a reference to the output buffer and *spec* contains format\n+    *buffer* is a reference to the output buffer and *specs* contains format\n     specifier information for standard argument types.\n     \\endrst\n    */\n-  printf_arg_formatter(internal::basic_buffer<char_type> &buffer,\n-                       format_specs &spec, context_type &ctx)\n-    : base(back_insert_range<internal::basic_buffer<char_type>>(buffer), &spec,\n-           ctx.locale()),\n-      context_(ctx) {}\n-\n-  template <typename T>\n-  typename std::enable_if<std::is_integral<T>::value, iterator>::type\n-      operator()(T value) {\n+  printf_arg_formatter(iterator iter, format_specs& specs, context_type& ctx)\n+      : base(Range(iter), &specs, internal::locale_ref()), context_(ctx) {}\n+\n+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\n+  iterator operator()(T value) {\n     // MSVC2013 fails to compile separate overloads for bool and char_type so\n     // use std::is_same instead.\n     if (std::is_same<T, bool>::value) {\n-      format_specs &fmt_spec = *this->spec();\n-      if (fmt_spec.type != 's')\n-        return base::operator()(value ? 1 : 0);\n-      fmt_spec.type = 0;\n+      format_specs& fmt_specs = *this->specs();\n+      if (fmt_specs.type != 's') return base::operator()(value ? 1 : 0);\n+      fmt_specs.type = 0;\n       this->write(value != 0);\n     } else if (std::is_same<T, char_type>::value) {\n-      format_specs &fmt_spec = *this->spec();\n-      if (fmt_spec.type && fmt_spec.type != 'c')\n+      format_specs& fmt_specs = *this->specs();\n+      if (fmt_specs.type && fmt_specs.type != 'c')\n         return (*this)(static_cast<int>(value));\n-      fmt_spec.flags = 0;\n-      fmt_spec.align_ = ALIGN_RIGHT;\n+      fmt_specs.sign = sign::none;\n+      fmt_specs.alt = false;\n+      fmt_specs.align = align::right;\n       return base::operator()(value);\n     } else {\n       return base::operator()(value);\n@@ -403,17 +258,16 @@ class printf_arg_formatter:\n     return this->out();\n   }\n \n-  template <typename T>\n-  typename std::enable_if<std::is_floating_point<T>::value, iterator>::type\n-      operator()(T value) {\n+  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n+  iterator operator()(T value) {\n     return base::operator()(value);\n   }\n \n   /** Formats a null-terminated C string. */\n-  iterator operator()(const char *value) {\n+  iterator operator()(const char* value) {\n     if (value)\n       base::operator()(value);\n-    else if (this->spec()->type == 'p')\n+    else if (this->specs()->type == 'p')\n       write_null_pointer(char_type());\n     else\n       this->write(\"(null)\");\n@@ -421,10 +275,10 @@ class printf_arg_formatter:\n   }\n \n   /** Formats a null-terminated wide C string. */\n-  iterator operator()(const wchar_t *value) {\n+  iterator operator()(const wchar_t* value) {\n     if (value)\n       base::operator()(value);\n-    else if (this->spec()->type == 'p')\n+    else if (this->specs()->type == 'p')\n       write_null_pointer(char_type());\n     else\n       this->write(L\"(null)\");\n@@ -435,68 +289,60 @@ class printf_arg_formatter:\n     return base::operator()(value);\n   }\n \n-  iterator operator()(monostate value) {\n-    return base::operator()(value);\n-  }\n+  iterator operator()(monostate value) { return base::operator()(value); }\n \n   /** Formats a pointer. */\n-  iterator operator()(const void *value) {\n-    if (value)\n-      return base::operator()(value);\n-    this->spec()->type = 0;\n+  iterator operator()(const void* value) {\n+    if (value) return base::operator()(value);\n+    this->specs()->type = 0;\n     write_null_pointer(char_type());\n     return this->out();\n   }\n \n   /** Formats an argument of a custom (user-defined) type. */\n   iterator operator()(typename basic_format_arg<context_type>::handle handle) {\n-    handle.format(context_);\n+    handle.format(context_.parse_context(), context_);\n     return this->out();\n   }\n };\n \n-template <typename T>\n-struct printf_formatter {\n+template <typename T> struct printf_formatter {\n   template <typename ParseContext>\n-  auto parse(ParseContext &ctx) -> decltype(ctx.begin()) { return ctx.begin(); }\n+  auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n+    return ctx.begin();\n+  }\n \n   template <typename FormatContext>\n-  auto format(const T &value, FormatContext &ctx) -> decltype(ctx.out()) {\n+  auto format(const T& value, FormatContext& ctx) -> decltype(ctx.out()) {\n     internal::format_value(internal::get_container(ctx.out()), value);\n     return ctx.out();\n   }\n };\n \n /** This template formats data and writes the output to a writer. */\n-template <typename OutputIt, typename Char, typename ArgFormatter>\n-class basic_printf_context :\n-  // Inherit publicly as a workaround for the icc bug\n-  // https://software.intel.com/en-us/forums/intel-c-compiler/topic/783476.\n-  public internal::context_base<\n-    OutputIt, basic_printf_context<OutputIt, Char, ArgFormatter>, Char> {\n+template <typename OutputIt, typename Char> class basic_printf_context {\n  public:\n   /** The character type for the output. */\n-  typedef Char char_type;\n-\n-  template <typename T>\n-  struct formatter_type { typedef printf_formatter<T> type; };\n+  using char_type = Char;\n+  using format_arg = basic_format_arg<basic_printf_context>;\n+  template <typename T> using formatter_type = printf_formatter<T>;\n \n  private:\n-  typedef internal::context_base<OutputIt, basic_printf_context, Char> base;\n-  typedef typename base::format_arg format_arg;\n-  typedef basic_format_specs<char_type> format_specs;\n-  typedef internal::null_terminating_iterator<char_type> iterator;\n+  using format_specs = basic_format_specs<char_type>;\n+\n+  OutputIt out_;\n+  basic_format_args<basic_printf_context> args_;\n+  basic_parse_context<Char> parse_ctx_;\n \n-  void parse_flags(format_specs &spec, iterator &it);\n+  static void parse_flags(format_specs& specs, const Char*& it,\n+                          const Char* end);\n \n   // Returns the argument with specified index or, if arg_index is equal\n   // to the maximum unsigned value, the next argument.\n-  format_arg get_arg(\n-      iterator it,\n-      unsigned arg_index = (std::numeric_limits<unsigned>::max)());\n+  format_arg get_arg(unsigned arg_index = std::numeric_limits<unsigned>::max());\n \n   // Parses argument index, flags and width and returns the argument index.\n-  unsigned parse_header(iterator &it, format_specs &spec);\n+  unsigned parse_header(const Char*& it, const Char* end, format_specs& specs);\n \n  public:\n   /**\n@@ -508,160 +354,180 @@ class basic_printf_context :\n    */\n   basic_printf_context(OutputIt out, basic_string_view<char_type> format_str,\n                        basic_format_args<basic_printf_context> args)\n-    : base(out, format_str, args) {}\n+      : out_(out), args_(args), parse_ctx_(format_str) {}\n+\n+  OutputIt out() { return out_; }\n+  void advance_to(OutputIt it) { out_ = it; }\n \n-  using base::parse_context;\n-  using base::out;\n-  using base::advance_to;\n+  format_arg arg(unsigned id) const { return args_.get(id); }\n+\n+  basic_parse_context<Char>& parse_context() { return parse_ctx_; }\n+\n+  FMT_CONSTEXPR void on_error(const char* message) {\n+    parse_ctx_.on_error(message);\n+  }\n \n   /** Formats stored arguments and writes the output to the range. */\n-  void format();\n+  template <typename ArgFormatter =\n+                printf_arg_formatter<internal::buffer_range<Char>>>\n+  OutputIt format();\n };\n \n-template <typename OutputIt, typename Char, typename AF>\n-void basic_printf_context<OutputIt, Char, AF>::parse_flags(\n-    format_specs &spec, iterator &it) {\n-  for (;;) {\n-    switch (*it++) {\n-      case '-':\n-        spec.align_ = ALIGN_LEFT;\n-        break;\n-      case '+':\n-        spec.flags |= SIGN_FLAG | PLUS_FLAG;\n-        break;\n-      case '0':\n-        spec.fill_ = '0';\n-        break;\n-      case ' ':\n-        spec.flags |= SIGN_FLAG;\n-        break;\n-      case '#':\n-        spec.flags |= HASH_FLAG;\n-        break;\n-      default:\n-        --it;\n-        return;\n+template <typename OutputIt, typename Char>\n+void basic_printf_context<OutputIt, Char>::parse_flags(format_specs& specs,\n+                                                       const Char*& it,\n+                                                       const Char* end) {\n+  for (; it != end; ++it) {\n+    switch (*it) {\n+    case '-':\n+      specs.align = align::left;\n+      break;\n+    case '+':\n+      specs.sign = sign::plus;\n+      break;\n+    case '0':\n+      specs.fill[0] = '0';\n+      break;\n+    case ' ':\n+      specs.sign = sign::space;\n+      break;\n+    case '#':\n+      specs.alt = true;\n+      break;\n+    default:\n+      return;\n     }\n   }\n }\n \n-template <typename OutputIt, typename Char, typename AF>\n-typename basic_printf_context<OutputIt, Char, AF>::format_arg\n-  basic_printf_context<OutputIt, Char, AF>::get_arg(\n-    iterator it, unsigned arg_index) {\n-  (void)it;\n+template <typename OutputIt, typename Char>\n+typename basic_printf_context<OutputIt, Char>::format_arg\n+basic_printf_context<OutputIt, Char>::get_arg(unsigned arg_index) {\n   if (arg_index == std::numeric_limits<unsigned>::max())\n-    return this->do_get_arg(this->parse_context().next_arg_id());\n-  return base::get_arg(arg_index - 1);\n+    arg_index = parse_ctx_.next_arg_id();\n+  else\n+    parse_ctx_.check_arg_id(--arg_index);\n+  return internal::get_arg(*this, arg_index);\n }\n \n-template <typename OutputIt, typename Char, typename AF>\n-unsigned basic_printf_context<OutputIt, Char, AF>::parse_header(\n-  iterator &it, format_specs &spec) {\n+template <typename OutputIt, typename Char>\n+unsigned basic_printf_context<OutputIt, Char>::parse_header(\n+    const Char*& it, const Char* end, format_specs& specs) {\n   unsigned arg_index = std::numeric_limits<unsigned>::max();\n   char_type c = *it;\n   if (c >= '0' && c <= '9') {\n     // Parse an argument index (if followed by '$') or a width possibly\n     // preceded with '0' flag(s).\n     internal::error_handler eh;\n-    unsigned value = parse_nonnegative_int(it, eh);\n-    if (*it == '$') {  // value is an argument index\n+    unsigned value = parse_nonnegative_int(it, end, eh);\n+    if (it != end && *it == '$') {  // value is an argument index\n       ++it;\n       arg_index = value;\n     } else {\n-      if (c == '0')\n-        spec.fill_ = '0';\n+      if (c == '0') specs.fill[0] = '0';\n       if (value != 0) {\n         // Nonzero value means that we parsed width and don't need to\n         // parse it or flags again, so return now.\n-        spec.width_ = value;\n+        specs.width = value;\n         return arg_index;\n       }\n     }\n   }\n-  parse_flags(spec, it);\n+  parse_flags(specs, it, end);\n   // Parse width.\n-  if (*it >= '0' && *it <= '9') {\n-    internal::error_handler eh;\n-    spec.width_ = parse_nonnegative_int(it, eh);\n-  } else if (*it == '*') {\n-    ++it;\n-    spec.width_ = visit_format_arg(\n-          internal::printf_width_handler<char_type>(spec), get_arg(it));\n+  if (it != end) {\n+    if (*it >= '0' && *it <= '9') {\n+      internal::error_handler eh;\n+      specs.width = parse_nonnegative_int(it, end, eh);\n+    } else if (*it == '*') {\n+      ++it;\n+      specs.width = visit_format_arg(\n+          internal::printf_width_handler<char_type>(specs), get_arg());\n+    }\n   }\n   return arg_index;\n }\n \n-template <typename OutputIt, typename Char, typename AF>\n-void basic_printf_context<OutputIt, Char, AF>::format() {\n-  auto &buffer = internal::get_container(this->out());\n-  auto start = iterator(this->parse_context());\n+template <typename OutputIt, typename Char>\n+template <typename ArgFormatter>\n+OutputIt basic_printf_context<OutputIt, Char>::format() {\n+  auto out = this->out();\n+  const Char* start = parse_ctx_.begin();\n+  const Char* end = parse_ctx_.end();\n   auto it = start;\n-  using internal::pointer_from;\n-  while (*it) {\n+  while (it != end) {\n     char_type c = *it++;\n     if (c != '%') continue;\n-    if (*it == c) {\n-      buffer.append(pointer_from(start), pointer_from(it));\n+    if (it != end && *it == c) {\n+      out = std::copy(start, it, out);\n       start = ++it;\n       continue;\n     }\n-    buffer.append(pointer_from(start), pointer_from(it) - 1);\n+    out = std::copy(start, it - 1, out);\n \n-    format_specs spec;\n-    spec.align_ = ALIGN_RIGHT;\n+    format_specs specs;\n+    specs.align = align::right;\n \n     // Parse argument index, flags and width.\n-    unsigned arg_index = parse_header(it, spec);\n+    unsigned arg_index = parse_header(it, end, specs);\n \n     // Parse precision.\n-    if (*it == '.') {\n+    if (it != end && *it == '.') {\n       ++it;\n-      if ('0' <= *it && *it <= '9') {\n+      c = it != end ? *it : 0;\n+      if ('0' <= c && c <= '9') {\n         internal::error_handler eh;\n-        spec.precision = static_cast<int>(parse_nonnegative_int(it, eh));\n-      } else if (*it == '*') {\n+        specs.precision = static_cast<int>(parse_nonnegative_int(it, end, eh));\n+      } else if (c == '*') {\n         ++it;\n-        spec.precision =\n-            visit_format_arg(internal::printf_precision_handler(), get_arg(it));\n+        specs.precision =\n+            visit_format_arg(internal::printf_precision_handler(), get_arg());\n       } else {\n-        spec.precision = 0;\n+        specs.precision = 0;\n       }\n     }\n \n-    format_arg arg = get_arg(it, arg_index);\n-    if (spec.has(HASH_FLAG) && visit_format_arg(internal::is_zero_int(), arg))\n-      spec.flags = static_cast<uint_least8_t>(spec.flags & (~internal::to_unsigned<int>(HASH_FLAG)));\n-    if (spec.fill_ == '0') {\n+    format_arg arg = get_arg(arg_index);\n+    if (specs.alt && visit_format_arg(internal::is_zero_int(), arg))\n+      specs.alt = false;\n+    if (specs.fill[0] == '0') {\n       if (arg.is_arithmetic())\n-        spec.align_ = ALIGN_NUMERIC;\n+        specs.align = align::numeric;\n       else\n-        spec.fill_ = ' ';  // Ignore '0' flag for non-numeric types.\n+        specs.fill[0] = ' ';  // Ignore '0' flag for non-numeric types.\n     }\n \n     // Parse length and convert the argument to the required type.\n+    c = it != end ? *it++ : 0;\n+    char_type t = it != end ? *it : 0;\n     using internal::convert_arg;\n-    switch (*it++) {\n+    switch (c) {\n     case 'h':\n-      if (*it == 'h')\n-        convert_arg<signed char>(arg, *++it);\n-      else\n-        convert_arg<short>(arg, *it);\n+      if (t == 'h') {\n+        ++it;\n+        t = it != end ? *it : 0;\n+        convert_arg<signed char>(arg, t);\n+      } else {\n+        convert_arg<short>(arg, t);\n+      }\n       break;\n     case 'l':\n-      if (*it == 'l')\n-        convert_arg<long long>(arg, *++it);\n-      else\n-        convert_arg<long>(arg, *it);\n+      if (t == 'l') {\n+        ++it;\n+        t = it != end ? *it : 0;\n+        convert_arg<long long>(arg, t);\n+      } else {\n+        convert_arg<long>(arg, t);\n+      }\n       break;\n     case 'j':\n-      convert_arg<intmax_t>(arg, *it);\n+      convert_arg<intmax_t>(arg, t);\n       break;\n     case 'z':\n-      convert_arg<std::size_t>(arg, *it);\n+      convert_arg<std::size_t>(arg, t);\n       break;\n     case 't':\n-      convert_arg<std::ptrdiff_t>(arg, *it);\n+      convert_arg<std::ptrdiff_t>(arg, t);\n       break;\n     case 'L':\n       // printf produces garbage when 'L' is omitted for long double, no\n@@ -669,23 +535,22 @@ void basic_printf_context<OutputIt, Char, AF>::format() {\n       break;\n     default:\n       --it;\n-      convert_arg<void>(arg, *it);\n+      convert_arg<void>(arg, c);\n     }\n \n     // Parse type.\n-    if (!*it)\n-      FMT_THROW(format_error(\"invalid format string\"));\n-    spec.type = static_cast<char>(*it++);\n+    if (it == end) FMT_THROW(format_error(\"invalid format string\"));\n+    specs.type = static_cast<char>(*it++);\n     if (arg.is_integral()) {\n       // Normalize type.\n-      switch (spec.type) {\n-      case 'i': case 'u':\n-        spec.type = 'd';\n+      switch (specs.type) {\n+      case 'i':\n+      case 'u':\n+        specs.type = 'd';\n         break;\n       case 'c':\n-        // TODO: handle wchar_t better?\n-        visit_format_arg(\n-              internal::char_converter<basic_printf_context>(arg), arg);\n+        visit_format_arg(internal::char_converter<basic_printf_context>(arg),\n+                         arg);\n         break;\n       }\n     }\n@@ -693,48 +558,49 @@ void basic_printf_context<OutputIt, Char, AF>::format() {\n     start = it;\n \n     // Format argument.\n-    visit_format_arg(AF(buffer, spec, *this), arg);\n+    visit_format_arg(ArgFormatter(out, specs, *this), arg);\n   }\n-  buffer.append(pointer_from(start), pointer_from(it));\n+  return std::copy(start, it, out);\n }\n \n-template <typename Buffer>\n-struct basic_printf_context_t {\n-  typedef basic_printf_context<\n-    std::back_insert_iterator<Buffer>, typename Buffer::value_type> type;\n-};\n+template <typename Char>\n+using basic_printf_context_t =\n+    basic_printf_context<std::back_insert_iterator<internal::buffer<Char>>,\n+                         Char>;\n \n-typedef basic_printf_context_t<internal::buffer>::type printf_context;\n-typedef basic_printf_context_t<internal::wbuffer>::type wprintf_context;\n+using printf_context = basic_printf_context_t<char>;\n+using wprintf_context = basic_printf_context_t<wchar_t>;\n \n-typedef basic_format_args<printf_context> printf_args;\n-typedef basic_format_args<wprintf_context> wprintf_args;\n+using printf_args = basic_format_args<printf_context>;\n+using wprintf_args = basic_format_args<wprintf_context>;\n \n /**\n   \\rst\n   Constructs an `~fmt::format_arg_store` object that contains references to\n-  arguments and can be implicitly converted to `~fmt::printf_args`. \n+  arguments and can be implicitly converted to `~fmt::printf_args`.\n   \\endrst\n  */\n-template<typename... Args>\n-inline format_arg_store<printf_context, Args...>\n-  make_printf_args(const Args &... args) { return {args...}; }\n+template <typename... Args>\n+inline format_arg_store<printf_context, Args...> make_printf_args(\n+    const Args&... args) {\n+  return {args...};\n+}\n \n /**\n   \\rst\n   Constructs an `~fmt::format_arg_store` object that contains references to\n-  arguments and can be implicitly converted to `~fmt::wprintf_args`. \n+  arguments and can be implicitly converted to `~fmt::wprintf_args`.\n   \\endrst\n  */\n-template<typename... Args>\n-inline format_arg_store<wprintf_context, Args...>\n-  make_wprintf_args(const Args &... args) { return {args...}; }\n-\n-template <typename S, typename Char = FMT_CHAR(S)>\n-inline std::basic_string<Char>\n-vsprintf(const S &format,\n-         basic_format_args<typename basic_printf_context_t<\n-           internal::basic_buffer<Char>>::type> args) {\n+template <typename... Args>\n+inline format_arg_store<wprintf_context, Args...> make_wprintf_args(\n+    const Args&... args) {\n+  return {args...};\n+}\n+\n+template <typename S, typename Char = char_t<S>>\n+inline std::basic_string<Char> vsprintf(\n+    const S& format, basic_format_args<basic_printf_context_t<Char>> args) {\n   basic_memory_buffer<Char> buffer;\n   printf(buffer, to_string_view(format), args);\n   return to_string(buffer);\n@@ -749,27 +615,22 @@ vsprintf(const S &format,\n     std::string message = fmt::sprintf(\"The answer is %d\", 42);\n   \\endrst\n */\n-template <typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(\n-    internal::is_string<S>::value, std::basic_string<FMT_CHAR(S)>)\n-    sprintf(const S &format, const Args & ... args) {\n-  internal::check_format_string<Args...>(format);\n-  typedef internal::basic_buffer<FMT_CHAR(S)> buffer;\n-  typedef typename basic_printf_context_t<buffer>::type context;\n-  format_arg_store<context, Args...> as{ args... };\n-  return vsprintf(to_string_view(format),\n-                  basic_format_args<context>(as));\n+template <typename S, typename... Args,\n+          typename Char = enable_if_t<internal::is_string<S>::value, char_t<S>>>\n+inline std::basic_string<Char> sprintf(const S& format, const Args&... args) {\n+  using context = basic_printf_context_t<Char>;\n+  return vsprintf(to_string_view(format), {make_format_args<context>(args...)});\n }\n \n-template <typename S, typename Char = FMT_CHAR(S)>\n-inline int vfprintf(std::FILE *f, const S &format,\n-                    basic_format_args<typename basic_printf_context_t<\n-                      internal::basic_buffer<Char>>::type> args) {\n+template <typename S, typename Char = char_t<S>>\n+inline int vfprintf(std::FILE* f, const S& format,\n+                    basic_format_args<basic_printf_context_t<Char>> args) {\n   basic_memory_buffer<Char> buffer;\n   printf(buffer, to_string_view(format), args);\n   std::size_t size = buffer.size();\n-  return std::fwrite(\n-    buffer.data(), sizeof(Char), size, f) < size ? -1 : static_cast<int>(size);\n+  return std::fwrite(buffer.data(), sizeof(Char), size, f) < size\n+             ? -1\n+             : static_cast<int>(size);\n }\n \n /**\n@@ -781,21 +642,17 @@ inline int vfprintf(std::FILE *f, const S &format,\n     fmt::fprintf(stderr, \"Don't %s!\", \"panic\");\n   \\endrst\n  */\n-template <typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(internal::is_string<S>::value, int)\n-    fprintf(std::FILE *f, const S &format, const Args & ... args) {\n-  internal::check_format_string<Args...>(format);\n-  typedef internal::basic_buffer<FMT_CHAR(S)> buffer;\n-  typedef typename basic_printf_context_t<buffer>::type context;\n-  format_arg_store<context, Args...> as{ args... };\n+template <typename S, typename... Args,\n+          typename Char = enable_if_t<internal::is_string<S>::value, char_t<S>>>\n+inline int fprintf(std::FILE* f, const S& format, const Args&... args) {\n+  using context = basic_printf_context_t<Char>;\n   return vfprintf(f, to_string_view(format),\n-                  basic_format_args<context>(as));\n+                  {make_format_args<context>(args...)});\n }\n \n-template <typename S, typename Char = FMT_CHAR(S)>\n-inline int vprintf(const S &format,\n-                   basic_format_args<typename basic_printf_context_t<\n-                    internal::basic_buffer<Char>>::type> args) {\n+template <typename S, typename Char = char_t<S>>\n+inline int vprintf(const S& format,\n+                   basic_format_args<basic_printf_context_t<Char>> args) {\n   return vfprintf(stdout, to_string_view(format), args);\n }\n \n@@ -808,28 +665,35 @@ inline int vprintf(const S &format,\n     fmt::printf(\"Elapsed time: %.2f seconds\", 1.23);\n   \\endrst\n  */\n-template <typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(internal::is_string<S>::value, int)\n-    printf(const S &format_str, const Args & ... args) {\n-  internal::check_format_string<Args...>(format_str);\n-  typedef internal::basic_buffer<FMT_CHAR(S)> buffer;\n-  typedef typename basic_printf_context_t<buffer>::type context;\n-  format_arg_store<context, Args...> as{ args... };\n+template <typename S, typename... Args,\n+          FMT_ENABLE_IF(internal::is_string<S>::value)>\n+inline int printf(const S& format_str, const Args&... args) {\n+  using context = basic_printf_context_t<char_t<S>>;\n   return vprintf(to_string_view(format_str),\n-                 basic_format_args<context>(as));\n+                 {make_format_args<context>(args...)});\n }\n \n-template <typename S, typename Char = FMT_CHAR(S)>\n-inline int vfprintf(std::basic_ostream<Char> &os,\n-                    const S &format,\n-                    basic_format_args<typename basic_printf_context_t<\n-                      internal::basic_buffer<Char>>::type> args) {\n+template <typename S, typename Char = char_t<S>>\n+inline int vfprintf(std::basic_ostream<Char>& os, const S& format,\n+                    basic_format_args<basic_printf_context_t<Char>> args) {\n   basic_memory_buffer<Char> buffer;\n   printf(buffer, to_string_view(format), args);\n   internal::write(os, buffer);\n   return static_cast<int>(buffer.size());\n }\n \n+/** Formats arguments and writes the output to the range. */\n+template <typename ArgFormatter, typename Char,\n+          typename Context =\n+              basic_printf_context<typename ArgFormatter::iterator, Char>>\n+typename ArgFormatter::iterator vprintf(internal::buffer<Char>& out,\n+                                        basic_string_view<Char> format_str,\n+                                        basic_format_args<Context> args) {\n+  typename ArgFormatter::iterator iter(out);\n+  Context(iter, format_str, args).template format<ArgFormatter>();\n+  return iter;\n+}\n+\n /**\n   \\rst\n   Prints formatted data to the stream *os*.\n@@ -839,16 +703,12 @@ inline int vfprintf(std::basic_ostream<Char> &os,\n     fmt::fprintf(cerr, \"Don't %s!\", \"panic\");\n   \\endrst\n  */\n-template <typename S, typename... Args>\n-inline FMT_ENABLE_IF_T(internal::is_string<S>::value, int)\n-    fprintf(std::basic_ostream<FMT_CHAR(S)> &os,\n-            const S &format_str, const Args & ... args) {\n-  internal::check_format_string<Args...>(format_str);\n-  typedef internal::basic_buffer<FMT_CHAR(S)> buffer;\n-  typedef typename basic_printf_context_t<buffer>::type context;\n-  format_arg_store<context, Args...> as{ args... };\n+template <typename S, typename... Args, typename Char = char_t<S>>\n+inline int fprintf(std::basic_ostream<Char>& os, const S& format_str,\n+                   const Args&... args) {\n+  using context = basic_printf_context_t<Char>;\n   return vfprintf(os, to_string_view(format_str),\n-                  basic_format_args<context>(as));\n+                  {make_format_args<context>(args...)});\n }\n FMT_END_NAMESPACE\n \ndiff --git a/include/spdlog/fmt/bundled/ranges.h b/include/spdlog/fmt/bundled/ranges.h\n--- a/include/spdlog/fmt/bundled/ranges.h\n+++ b/include/spdlog/fmt/bundled/ranges.h\n@@ -1,4 +1,4 @@\n-// Formatting library for C++ - the core API\n+// Formatting library for C++ - experimental range support\n //\n // Copyright (c) 2012 - present, Victor Zverovich\n // All rights reserved.\n@@ -12,20 +12,19 @@\n #ifndef FMT_RANGES_H_\n #define FMT_RANGES_H_\n \n-#include \"format.h\"\n #include <type_traits>\n+#include \"format.h\"\n \n // output only up to N items from the range.\n #ifndef FMT_RANGE_OUTPUT_LENGTH_LIMIT\n-# define FMT_RANGE_OUTPUT_LENGTH_LIMIT 256\n+#  define FMT_RANGE_OUTPUT_LENGTH_LIMIT 256\n #endif\n \n FMT_BEGIN_NAMESPACE\n \n-template <typename Char>\n-struct formatting_base {\n+template <typename Char> struct formatting_base {\n   template <typename ParseContext>\n-  FMT_CONSTEXPR auto parse(ParseContext &ctx) -> decltype(ctx.begin()) {\n+  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n     return ctx.begin();\n   }\n };\n@@ -33,7 +32,8 @@ struct formatting_base {\n template <typename Char, typename Enable = void>\n struct formatting_range : formatting_base<Char> {\n   static FMT_CONSTEXPR_DECL const std::size_t range_length_limit =\n-      FMT_RANGE_OUTPUT_LENGTH_LIMIT; // output only up to N items from the range.\n+      FMT_RANGE_OUTPUT_LENGTH_LIMIT;  // output only up to N items from the\n+                                      // range.\n   Char prefix;\n   Char delimiter;\n   Char postfix;\n@@ -55,87 +55,78 @@ struct formatting_tuple : formatting_base<Char> {\n namespace internal {\n \n template <typename RangeT, typename OutputIterator>\n-void copy(const RangeT &range, OutputIterator out) {\n+OutputIterator copy(const RangeT& range, OutputIterator out) {\n   for (auto it = range.begin(), end = range.end(); it != end; ++it)\n     *out++ = *it;\n+  return out;\n }\n \n template <typename OutputIterator>\n-void copy(const char *str, OutputIterator out) {\n-  const char *p_curr = str;\n-  while (*p_curr) {\n-    *out++ = *p_curr++;\n-  }\n+OutputIterator copy(const char* str, OutputIterator out) {\n+  while (*str) *out++ = *str++;\n+  return out;\n }\n \n template <typename OutputIterator>\n-void copy(char ch, OutputIterator out) {\n+OutputIterator copy(char ch, OutputIterator out) {\n   *out++ = ch;\n+  return out;\n }\n \n /// Return true value if T has std::string interface, like std::string_view.\n-template <typename T>\n-class is_like_std_string {\n+template <typename T> class is_like_std_string {\n   template <typename U>\n-  static auto check(U *p) ->\n-    decltype(p->find('a'), p->length(), p->data(), int());\n-  template <typename>\n-  static void check(...);\n+  static auto check(U* p)\n+      -> decltype((void)p->find('a'), p->length(), (void)p->data(), int());\n+  template <typename> static void check(...);\n \n  public:\n   static FMT_CONSTEXPR_DECL const bool value =\n-    !std::is_void<decltype(check<T>(FMT_NULL))>::value;\n+      is_string<T>::value || !std::is_void<decltype(check<T>(nullptr))>::value;\n };\n \n template <typename Char>\n struct is_like_std_string<fmt::basic_string_view<Char>> : std::true_type {};\n \n-template <typename... Ts>\n-struct conditional_helper {};\n+template <typename... Ts> struct conditional_helper {};\n \n-template <typename T, typename _ = void>\n-struct is_range_ : std::false_type {};\n+template <typename T, typename _ = void> struct is_range_ : std::false_type {};\n \n #if !FMT_MSC_VER || FMT_MSC_VER > 1800\n template <typename T>\n-struct is_range_<T, typename std::conditional<\n-                    false,\n-                    conditional_helper<decltype(internal::declval<T>().begin()),\n-                                       decltype(internal::declval<T>().end())>,\n-                    void>::type> : std::true_type {};\n+struct is_range_<\n+    T, conditional_t<false,\n+                     conditional_helper<decltype(std::declval<T>().begin()),\n+                                        decltype(std::declval<T>().end())>,\n+                     void>> : std::true_type {};\n #endif\n \n /// tuple_size and tuple_element check.\n-template <typename T>\n-class is_tuple_like_ {\n+template <typename T> class is_tuple_like_ {\n   template <typename U>\n-  static auto check(U *p) ->\n-    decltype(std::tuple_size<U>::value,\n-      internal::declval<typename std::tuple_element<0, U>::type>(), int());\n-  template <typename>\n-  static void check(...);\n+  static auto check(U* p)\n+      -> decltype(std::tuple_size<U>::value,\n+                  (void)std::declval<typename std::tuple_element<0, U>::type>(),\n+                  int());\n+  template <typename> static void check(...);\n \n  public:\n   static FMT_CONSTEXPR_DECL const bool value =\n-    !std::is_void<decltype(check<T>(FMT_NULL))>::value;\n+      !std::is_void<decltype(check<T>(nullptr))>::value;\n };\n \n // Check for integer_sequence\n #if defined(__cpp_lib_integer_sequence) || FMT_MSC_VER >= 1900\n template <typename T, T... N>\n using integer_sequence = std::integer_sequence<T, N...>;\n-template <std::size_t... N>\n-using index_sequence = std::index_sequence<N...>;\n+template <std::size_t... N> using index_sequence = std::index_sequence<N...>;\n template <std::size_t N>\n using make_index_sequence = std::make_index_sequence<N>;\n #else\n-template <typename T, T... N>\n-struct integer_sequence {\n-  typedef T value_type;\n+template <typename T, T... N> struct integer_sequence {\n+  using value_type = T;\n \n-  static FMT_CONSTEXPR std::size_t size() {\n-    return sizeof...(N);\n-  }\n+  static FMT_CONSTEXPR std::size_t size() { return sizeof...(N); }\n };\n \n template <std::size_t... N>\n@@ -151,7 +142,7 @@ using make_index_sequence = make_integer_sequence<std::size_t, N>;\n #endif\n \n template <class Tuple, class F, size_t... Is>\n-void for_each(index_sequence<Is...>, Tuple &&tup, F &&f) FMT_NOEXCEPT {\n+void for_each(index_sequence<Is...>, Tuple&& tup, F&& f) FMT_NOEXCEPT {\n   using std::get;\n   // using free function get<I>(T) now.\n   const int _[] = {0, ((void)f(get<Is>(tup)), 0)...};\n@@ -159,26 +150,25 @@ void for_each(index_sequence<Is...>, Tuple &&tup, F &&f) FMT_NOEXCEPT {\n }\n \n template <class T>\n-FMT_CONSTEXPR make_index_sequence<std::tuple_size<T>::value> \n-get_indexes(T const &) { return {}; }\n+FMT_CONSTEXPR make_index_sequence<std::tuple_size<T>::value> get_indexes(\n+    T const&) {\n+  return {};\n+}\n \n-template <class Tuple, class F>\n-void for_each(Tuple &&tup, F &&f) {\n+template <class Tuple, class F> void for_each(Tuple&& tup, F&& f) {\n   const auto indexes = get_indexes(tup);\n   for_each(indexes, std::forward<Tuple>(tup), std::forward<F>(f));\n }\n \n-template<typename Arg>\n-FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const Arg&, \n-  typename std::enable_if<\n-    !is_like_std_string<typename std::decay<Arg>::type>::value>::type* = nullptr) {\n+template <typename Arg, FMT_ENABLE_IF(!is_like_std_string<\n+                                      typename std::decay<Arg>::type>::value)>\n+FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const Arg&) {\n   return add_space ? \" {}\" : \"{}\";\n }\n \n-template<typename Arg>\n-FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const Arg&, \n-  typename std::enable_if<\n-    is_like_std_string<typename std::decay<Arg>::type>::value>::type* = nullptr) {\n+template <typename Arg, FMT_ENABLE_IF(is_like_std_string<\n+                                      typename std::decay<Arg>::type>::value)>\n+FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const Arg&) {\n   return add_space ? \" \\\"{}\\\"\" : \"\\\"{}\\\"\";\n }\n \n@@ -186,61 +176,58 @@ FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const char*) {\n   return add_space ? \" \\\"{}\\\"\" : \"\\\"{}\\\"\";\n }\n FMT_CONSTEXPR const wchar_t* format_str_quoted(bool add_space, const wchar_t*) {\n-    return add_space ? L\" \\\"{}\\\"\" : L\"\\\"{}\\\"\";\n+  return add_space ? L\" \\\"{}\\\"\" : L\"\\\"{}\\\"\";\n }\n \n FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const char) {\n-    return add_space ? \" '{}'\" : \"'{}'\";\n+  return add_space ? \" '{}'\" : \"'{}'\";\n }\n FMT_CONSTEXPR const wchar_t* format_str_quoted(bool add_space, const wchar_t) {\n-    return add_space ? L\" '{}'\" : L\"'{}'\";\n+  return add_space ? L\" '{}'\" : L\"'{}'\";\n }\n \n }  // namespace internal\n \n-template <typename T>\n-struct is_tuple_like {\n+template <typename T> struct is_tuple_like {\n   static FMT_CONSTEXPR_DECL const bool value =\n-    internal::is_tuple_like_<T>::value && !internal::is_range_<T>::value;\n+      internal::is_tuple_like_<T>::value && !internal::is_range_<T>::value;\n };\n \n template <typename TupleT, typename Char>\n-struct formatter<TupleT, Char, \n-    typename std::enable_if<fmt::is_tuple_like<TupleT>::value>::type> {\n-private:\n+struct formatter<TupleT, Char, enable_if_t<fmt::is_tuple_like<TupleT>::value>> {\n+ private:\n   // C++11 generic lambda for format()\n-  template <typename FormatContext>\n-  struct format_each {\n-    template <typename T>\n-    void operator()(const T& v) {\n+  template <typename FormatContext> struct format_each {\n+    template <typename T> void operator()(const T& v) {\n       if (i > 0) {\n         if (formatting.add_prepostfix_space) {\n           *out++ = ' ';\n         }\n-        internal::copy(formatting.delimiter, out);\n+        out = internal::copy(formatting.delimiter, out);\n       }\n-      format_to(out,\n-                internal::format_str_quoted(\n-                    (formatting.add_delimiter_spaces && i > 0), v),\n-                v);\n+      out = format_to(out,\n+                      internal::format_str_quoted(\n+                          (formatting.add_delimiter_spaces && i > 0), v),\n+                      v);\n       ++i;\n     }\n \n     formatting_tuple<Char>& formatting;\n     std::size_t& i;\n-    typename std::add_lvalue_reference<decltype(std::declval<FormatContext>().out())>::type out;\n+    typename std::add_lvalue_reference<decltype(\n+        std::declval<FormatContext>().out())>::type out;\n   };\n \n-public:\n+ public:\n   formatting_tuple<Char> formatting;\n \n   template <typename ParseContext>\n-  FMT_CONSTEXPR auto parse(ParseContext &ctx) -> decltype(ctx.begin()) {\n+  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n     return formatting.parse(ctx);\n   }\n \n   template <typename FormatContext = format_context>\n-  auto format(const TupleT &values, FormatContext &ctx) -> decltype(ctx.out()) {\n+  auto format(const TupleT& values, FormatContext& ctx) -> decltype(ctx.out()) {\n     auto out = ctx.out();\n     std::size_t i = 0;\n     internal::copy(formatting.prefix, out);\n@@ -255,54 +242,47 @@ struct formatter<TupleT, Char,\n   }\n };\n \n-template <typename T>\n-struct is_range {\n+template <typename T, typename Char> struct is_range {\n   static FMT_CONSTEXPR_DECL const bool value =\n-    internal::is_range_<T>::value && !internal::is_like_std_string<T>::value;\n+      internal::is_range_<T>::value &&\n+      !internal::is_like_std_string<T>::value &&\n+      !std::is_convertible<T, std::basic_string<Char>>::value;\n };\n \n template <typename RangeT, typename Char>\n struct formatter<RangeT, Char,\n-    typename std::enable_if<fmt::is_range<RangeT>::value>::type> {\n-\n+                 enable_if_t<fmt::is_range<RangeT, Char>::value>> {\n   formatting_range<Char> formatting;\n \n   template <typename ParseContext>\n-  FMT_CONSTEXPR auto parse(ParseContext &ctx) -> decltype(ctx.begin()) {\n+  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n     return formatting.parse(ctx);\n   }\n \n   template <typename FormatContext>\n-  typename FormatContext::iterator format(\n-      const RangeT &values, FormatContext &ctx) {\n-    auto out = ctx.out();\n-    internal::copy(formatting.prefix, out);\n+  typename FormatContext::iterator format(const RangeT& values,\n+                                          FormatContext& ctx) {\n+    auto out = internal::copy(formatting.prefix, ctx.out());\n     std::size_t i = 0;\n     for (auto it = values.begin(), end = values.end(); it != end; ++it) {\n       if (i > 0) {\n-        if (formatting.add_prepostfix_space) {\n-          *out++ = ' ';\n-        }\n-        internal::copy(formatting.delimiter, out);\n+        if (formatting.add_prepostfix_space) *out++ = ' ';\n+        out = internal::copy(formatting.delimiter, out);\n       }\n-      format_to(out,\n-                internal::format_str_quoted(\n-                    (formatting.add_delimiter_spaces && i > 0), *it),\n-                *it);\n+      out = format_to(out,\n+                      internal::format_str_quoted(\n+                          (formatting.add_delimiter_spaces && i > 0), *it),\n+                      *it);\n       if (++i > formatting.range_length_limit) {\n-        format_to(out, \" ... <other elements>\");\n+        out = format_to(out, \" ... <other elements>\");\n         break;\n       }\n     }\n-    if (formatting.add_prepostfix_space) {\n-      *out++ = ' ';\n-    }\n-    internal::copy(formatting.postfix, out);\n-    return ctx.out();\n+    if (formatting.add_prepostfix_space) *out++ = ' ';\n+    return internal::copy(formatting.postfix, out);\n   }\n };\n \n FMT_END_NAMESPACE\n \n-#endif // FMT_RANGES_H_\n-\n+#endif  // FMT_RANGES_H_\ndiff --git a/include/spdlog/fmt/bundled/safe-duration-cast.h b/include/spdlog/fmt/bundled/safe-duration-cast.h\nnew file mode 100644\n--- /dev/null\n+++ b/include/spdlog/fmt/bundled/safe-duration-cast.h\n@@ -0,0 +1,293 @@\n+/*\n+ * For conversion between std::chrono::durations without undefined\n+ * behaviour or erroneous results.\n+ * This is a stripped down version of duration_cast, for inclusion in fmt.\n+ * See https://github.com/pauldreik/safe_duration_cast\n+ *\n+ * Copyright Paul Dreik 2019\n+ *\n+ * This file is licensed under the fmt license, see format.h\n+ */\n+\n+#include <chrono>\n+#include <cmath>\n+#include <limits>\n+#include <type_traits>\n+\n+#include \"format.h\"\n+\n+FMT_BEGIN_NAMESPACE\n+\n+namespace safe_duration_cast {\n+\n+template <typename To, typename From,\n+          FMT_ENABLE_IF(!std::is_same<From, To>::value &&\n+                        std::numeric_limits<From>::is_signed ==\n+                            std::numeric_limits<To>::is_signed)>\n+FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {\n+  ec = 0;\n+  using F = std::numeric_limits<From>;\n+  using T = std::numeric_limits<To>;\n+  static_assert(F::is_integer, \"From must be integral\");\n+  static_assert(T::is_integer, \"To must be integral\");\n+\n+  // A and B are both signed, or both unsigned.\n+  if (F::digits <= T::digits) {\n+    // From fits in To without any problem.\n+  } else {\n+    // From does not always fit in To, resort to a dynamic check.\n+    if (from < T::min() || from > T::max()) {\n+      // outside range.\n+      ec = 1;\n+      return {};\n+    }\n+  }\n+  return static_cast<To>(from);\n+}\n+\n+/**\n+ * converts From to To, without loss. If the dynamic value of from\n+ * can't be converted to To without loss, ec is set.\n+ */\n+template <typename To, typename From,\n+          FMT_ENABLE_IF(!std::is_same<From, To>::value &&\n+                        std::numeric_limits<From>::is_signed !=\n+                            std::numeric_limits<To>::is_signed)>\n+FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {\n+  ec = 0;\n+  using F = std::numeric_limits<From>;\n+  using T = std::numeric_limits<To>;\n+  static_assert(F::is_integer, \"From must be integral\");\n+  static_assert(T::is_integer, \"To must be integral\");\n+\n+  if (F::is_signed && !T::is_signed) {\n+    // From may be negative, not allowed!\n+    if (from < 0) {\n+      ec = 1;\n+      return {};\n+    }\n+\n+    // From is positive. Can it always fit in To?\n+    if (F::digits <= T::digits) {\n+      // yes, From always fits in To.\n+    } else {\n+      // from may not fit in To, we have to do a dynamic check\n+      if (from > static_cast<From>(T::max())) {\n+        ec = 1;\n+        return {};\n+      }\n+    }\n+  }\n+\n+  if (!F::is_signed && T::is_signed) {\n+    // can from be held in To?\n+    if (F::digits < T::digits) {\n+      // yes, From always fits in To.\n+    } else {\n+      // from may not fit in To, we have to do a dynamic check\n+      if (from > static_cast<From>(T::max())) {\n+        // outside range.\n+        ec = 1;\n+        return {};\n+      }\n+    }\n+  }\n+\n+  // reaching here means all is ok for lossless conversion.\n+  return static_cast<To>(from);\n+\n+}  // function\n+\n+template <typename To, typename From,\n+          FMT_ENABLE_IF(std::is_same<From, To>::value)>\n+FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {\n+  ec = 0;\n+  return from;\n+}  // function\n+\n+// clang-format off\n+/**\n+ * converts From to To if possible, otherwise ec is set.\n+ *\n+ * input                            |    output\n+ * ---------------------------------|---------------\n+ * NaN                              | NaN\n+ * Inf                              | Inf\n+ * normal, fits in output           | converted (possibly lossy)\n+ * normal, does not fit in output   | ec is set\n+ * subnormal                        | best effort\n+ * -Inf                             | -Inf\n+ */\n+// clang-format on\n+template <typename To, typename From,\n+          FMT_ENABLE_IF(!std::is_same<From, To>::value)>\n+FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {\n+  ec = 0;\n+  using T = std::numeric_limits<To>;\n+  static_assert(std::is_floating_point<From>::value, \"From must be floating\");\n+  static_assert(std::is_floating_point<To>::value, \"To must be floating\");\n+\n+  // catch the only happy case\n+  if (std::isfinite(from)) {\n+    if (from >= T::lowest() && from <= T::max()) {\n+      return static_cast<To>(from);\n+    }\n+    // not within range.\n+    ec = 1;\n+    return {};\n+  }\n+\n+  // nan and inf will be preserved\n+  return static_cast<To>(from);\n+}  // function\n+\n+template <typename To, typename From,\n+          FMT_ENABLE_IF(std::is_same<From, To>::value)>\n+FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {\n+  ec = 0;\n+  static_assert(std::is_floating_point<From>::value, \"From must be floating\");\n+  return from;\n+}\n+\n+/**\n+ * safe duration cast between integral durations\n+ */\n+template <typename To, typename FromRep, typename FromPeriod,\n+          FMT_ENABLE_IF(std::is_integral<FromRep>::value),\n+          FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>\n+To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,\n+                      int& ec) {\n+  using From = std::chrono::duration<FromRep, FromPeriod>;\n+  ec = 0;\n+  // the basic idea is that we need to convert from count() in the from type\n+  // to count() in the To type, by multiplying it with this:\n+  using Factor = std::ratio_divide<typename From::period, typename To::period>;\n+\n+  static_assert(Factor::num > 0, \"num must be positive\");\n+  static_assert(Factor::den > 0, \"den must be positive\");\n+\n+  // the conversion is like this: multiply from.count() with Factor::num\n+  // /Factor::den and convert it to To::rep, all this without\n+  // overflow/underflow. let's start by finding a suitable type that can hold\n+  // both To, From and Factor::num\n+  using IntermediateRep =\n+      typename std::common_type<typename From::rep, typename To::rep,\n+                                decltype(Factor::num)>::type;\n+\n+  // safe conversion to IntermediateRep\n+  IntermediateRep count =\n+      lossless_integral_conversion<IntermediateRep>(from.count(), ec);\n+  if (ec) {\n+    return {};\n+  }\n+  // multiply with Factor::num without overflow or underflow\n+  if (Factor::num != 1) {\n+    constexpr auto max1 =\n+        std::numeric_limits<IntermediateRep>::max() / Factor::num;\n+    if (count > max1) {\n+      ec = 1;\n+      return {};\n+    }\n+    constexpr auto min1 =\n+        std::numeric_limits<IntermediateRep>::min() / Factor::num;\n+    if (count < min1) {\n+      ec = 1;\n+      return {};\n+    }\n+    count *= Factor::num;\n+  }\n+\n+  // this can't go wrong, right? den>0 is checked earlier.\n+  if (Factor::den != 1) {\n+    count /= Factor::den;\n+  }\n+  // convert to the to type, safely\n+  using ToRep = typename To::rep;\n+  const ToRep tocount = lossless_integral_conversion<ToRep>(count, ec);\n+  if (ec) {\n+    return {};\n+  }\n+  return To{tocount};\n+}\n+\n+/**\n+ * safe duration_cast between floating point durations\n+ */\n+template <typename To, typename FromRep, typename FromPeriod,\n+          FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),\n+          FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>\n+To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,\n+                      int& ec) {\n+  using From = std::chrono::duration<FromRep, FromPeriod>;\n+  ec = 0;\n+  if (std::isnan(from.count())) {\n+    // nan in, gives nan out. easy.\n+    return To{std::numeric_limits<typename To::rep>::quiet_NaN()};\n+  }\n+  // maybe we should also check if from is denormal, and decide what to do about\n+  // it.\n+\n+  // +-inf should be preserved.\n+  if (std::isinf(from.count())) {\n+    return To{from.count()};\n+  }\n+\n+  // the basic idea is that we need to convert from count() in the from type\n+  // to count() in the To type, by multiplying it with this:\n+  using Factor = std::ratio_divide<typename From::period, typename To::period>;\n+\n+  static_assert(Factor::num > 0, \"num must be positive\");\n+  static_assert(Factor::den > 0, \"den must be positive\");\n+\n+  // the conversion is like this: multiply from.count() with Factor::num\n+  // /Factor::den and convert it to To::rep, all this without\n+  // overflow/underflow. let's start by finding a suitable type that can hold\n+  // both To, From and Factor::num\n+  using IntermediateRep =\n+      typename std::common_type<typename From::rep, typename To::rep,\n+                                decltype(Factor::num)>::type;\n+\n+  // force conversion of From::rep -> IntermediateRep to be safe,\n+  // even if it will never happen be narrowing in this context.\n+  IntermediateRep count =\n+      safe_float_conversion<IntermediateRep>(from.count(), ec);\n+  if (ec) {\n+    return {};\n+  }\n+\n+  // multiply with Factor::num without overflow or underflow\n+  if (Factor::num != 1) {\n+    constexpr auto max1 = std::numeric_limits<IntermediateRep>::max() /\n+                          static_cast<IntermediateRep>(Factor::num);\n+    if (count > max1) {\n+      ec = 1;\n+      return {};\n+    }\n+    constexpr auto min1 = std::numeric_limits<IntermediateRep>::lowest() /\n+                          static_cast<IntermediateRep>(Factor::num);\n+    if (count < min1) {\n+      ec = 1;\n+      return {};\n+    }\n+    count *= static_cast<IntermediateRep>(Factor::num);\n+  }\n+\n+  // this can't go wrong, right? den>0 is checked earlier.\n+  if (Factor::den != 1) {\n+    using common_t = typename std::common_type<IntermediateRep, intmax_t>::type;\n+    count /= static_cast<common_t>(Factor::den);\n+  }\n+\n+  // convert to the to type, safely\n+  using ToRep = typename To::rep;\n+\n+  const ToRep tocount = safe_float_conversion<ToRep>(count, ec);\n+  if (ec) {\n+    return {};\n+  }\n+  return To{tocount};\n+}\n+\n+}  // namespace safe_duration_cast\n+\n+FMT_END_NAMESPACE\ndiff --git a/include/spdlog/fmt/bundled/time.h b/include/spdlog/fmt/bundled/time.h\ndeleted file mode 100644\n--- a/include/spdlog/fmt/bundled/time.h\n+++ /dev/null\n@@ -1,160 +0,0 @@\n-// Formatting library for C++ - time formatting\n-//\n-// Copyright (c) 2012 - present, Victor Zverovich\n-// All rights reserved.\n-//\n-// For the license information refer to format.h.\n-\n-#ifndef FMT_TIME_H_\n-#define FMT_TIME_H_\n-\n-#include \"format.h\"\n-#include <ctime>\n-#include <locale>\n-\n-FMT_BEGIN_NAMESPACE\n-\n-// Prevents expansion of a preceding token as a function-style macro.\n-// Usage: f FMT_NOMACRO()\n-#define FMT_NOMACRO\n-\n-namespace internal{\n-inline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }\n-inline null<> localtime_s(...) { return null<>(); }\n-inline null<> gmtime_r(...) { return null<>(); }\n-inline null<> gmtime_s(...) { return null<>(); }\n-}  // namespace internal\n-\n-// Thread-safe replacement for std::localtime\n-inline std::tm localtime(std::time_t time) {\n-  struct dispatcher {\n-    std::time_t time_;\n-    std::tm tm_;\n-\n-    dispatcher(std::time_t t): time_(t) {}\n-\n-    bool run() {\n-      using namespace fmt::internal;\n-      return handle(localtime_r(&time_, &tm_));\n-    }\n-\n-    bool handle(std::tm *tm) { return tm != FMT_NULL; }\n-\n-    bool handle(internal::null<>) {\n-      using namespace fmt::internal;\n-      return fallback(localtime_s(&tm_, &time_));\n-    }\n-\n-    bool fallback(int res) { return res == 0; }\n-\n-#if !FMT_MSC_VER\n-    bool fallback(internal::null<>) {\n-      using namespace fmt::internal;\n-      std::tm *tm = std::localtime(&time_);\n-      if (tm) tm_ = *tm;\n-      return tm != FMT_NULL;\n-    }\n-#endif\n-  };\n-  dispatcher lt(time);\n-  // Too big time values may be unsupported.\n-  if (!lt.run())\n-    FMT_THROW(format_error(\"time_t value out of range\"));\n-  return lt.tm_;\n-}\n-\n-// Thread-safe replacement for std::gmtime\n-inline std::tm gmtime(std::time_t time) {\n-  struct dispatcher {\n-    std::time_t time_;\n-    std::tm tm_;\n-\n-    dispatcher(std::time_t t): time_(t) {}\n-\n-    bool run() {\n-      using namespace fmt::internal;\n-      return handle(gmtime_r(&time_, &tm_));\n-    }\n-\n-    bool handle(std::tm *tm) { return tm != FMT_NULL; }\n-\n-    bool handle(internal::null<>) {\n-      using namespace fmt::internal;\n-      return fallback(gmtime_s(&tm_, &time_));\n-    }\n-\n-    bool fallback(int res) { return res == 0; }\n-\n-#if !FMT_MSC_VER\n-    bool fallback(internal::null<>) {\n-      std::tm *tm = std::gmtime(&time_);\n-      if (tm) tm_ = *tm;\n-      return tm != FMT_NULL;\n-    }\n-#endif\n-  };\n-  dispatcher gt(time);\n-  // Too big time values may be unsupported.\n-  if (!gt.run())\n-    FMT_THROW(format_error(\"time_t value out of range\"));\n-  return gt.tm_;\n-}\n-\n-namespace internal {\n-inline std::size_t strftime(char *str, std::size_t count, const char *format,\n-                            const std::tm *time) {\n-  return std::strftime(str, count, format, time);\n-}\n-\n-inline std::size_t strftime(wchar_t *str, std::size_t count,\n-                            const wchar_t *format, const std::tm *time) {\n-  return std::wcsftime(str, count, format, time);\n-}\n-}\n-\n-template <typename Char>\n-struct formatter<std::tm, Char> {\n-  template <typename ParseContext>\n-  auto parse(ParseContext &ctx) -> decltype(ctx.begin()) {\n-    auto it = ctx.begin();\n-    if (it != ctx.end() && *it == ':')\n-      ++it;\n-    auto end = it;\n-    while (end != ctx.end() && *end != '}')\n-      ++end;\n-    tm_format.reserve(internal::to_unsigned(end - it + 1));\n-    tm_format.append(it, end);\n-    tm_format.push_back('\\0');\n-    return end;\n-  }\n-\n-  template <typename FormatContext>\n-  auto format(const std::tm &tm, FormatContext &ctx) -> decltype(ctx.out()) {\n-    basic_memory_buffer<Char> buf;\n-    std::size_t start = buf.size();\n-    for (;;) {\n-      std::size_t size = buf.capacity() - start;\n-      std::size_t count =\n-        internal::strftime(&buf[start], size, &tm_format[0], &tm);\n-      if (count != 0) {\n-        buf.resize(start + count);\n-        break;\n-      }\n-      if (size >= tm_format.size() * 256) {\n-        // If the buffer is 256 times larger than the format string, assume\n-        // that `strftime` gives an empty result. There doesn't seem to be a\n-        // better way to distinguish the two cases:\n-        // https://github.com/fmtlib/fmt/issues/367\n-        break;\n-      }\n-      const std::size_t MIN_GROWTH = 10;\n-      buf.reserve(buf.capacity() + (size > MIN_GROWTH ? size : MIN_GROWTH));\n-    }\n-    return std::copy(buf.begin(), buf.end(), ctx.out());\n-  }\n-\n-  basic_memory_buffer<Char> tm_format;\n-};\n-FMT_END_NAMESPACE\n-\n-#endif  // FMT_TIME_H_\ndiff --git a/src/fmt.cpp b/src/fmt.cpp\n--- a/src/fmt.cpp\n+++ b/src/fmt.cpp\n@@ -16,21 +16,19 @@ template FMT_API std::locale internal::locale_ref::get<std::locale>() const;\n \n // Explicit instantiations for char.\n template FMT_API char internal::thousands_sep_impl(locale_ref);\n-template FMT_API void internal::basic_buffer<char>::append(const char *, const char *);\n+template FMT_API char internal::decimal_point_impl(locale_ref);\n+template FMT_API void internal::buffer<char>::append(const char *, const char *);\n template FMT_API void internal::arg_map<format_context>::init(const basic_format_args<format_context> &args);\n-template FMT_API int internal::char_traits<char>::format_float(char *, std::size_t, const char *, int, double);\n-template FMT_API int internal::char_traits<char>::format_float(char *, std::size_t, const char *, int, long double);\n template FMT_API std::string internal::vformat<char>(string_view, basic_format_args<format_context>);\n-template FMT_API format_context::iterator internal::vformat_to(internal::buffer &, string_view, basic_format_args<format_context>);\n-template FMT_API void internal::sprintf_format(double, internal::buffer &, core_format_specs);\n-template FMT_API void internal::sprintf_format(long double, internal::buffer &, core_format_specs);\n+template FMT_API format_context::iterator internal::vformat_to(internal::buffer<char> &, string_view, basic_format_args<format_context>);\n+template FMT_API char* internal::sprintf_format(double, internal::buffer<char> &, sprintf_specs);\n+template FMT_API char* internal::sprintf_format(long double, internal::buffer<char> &, sprintf_specs);\n \n // Explicit instantiations for wchar_t.\n template FMT_API wchar_t internal::thousands_sep_impl(locale_ref);\n-template FMT_API void internal::basic_buffer<wchar_t>::append(const wchar_t *, const wchar_t *);\n+template FMT_API wchar_t internal::decimal_point_impl(locale_ref);\n+template FMT_API void internal::buffer<wchar_t>::append(const wchar_t *, const wchar_t *);\n template FMT_API void internal::arg_map<wformat_context>::init(const basic_format_args<wformat_context> &);\n-template FMT_API int internal::char_traits<wchar_t>::format_float(wchar_t *, std::size_t, const wchar_t *, int, double);\n-template FMT_API int internal::char_traits<wchar_t>::format_float(wchar_t *, std::size_t, const wchar_t *, int, long double);\n template FMT_API std::wstring internal::vformat<wchar_t>(wstring_view, basic_format_args<wformat_context>);\n FMT_END_NAMESPACE\n \n", "test_patch": "", "problem_statement": "Compiler warning with gcc-9 shipped with Fedora 30\nHere is the error.\r\n\r\n```\r\n/tmp/cmake/ws/../third_party/spdlog/include/spdlog/fmt/bundled/format.h:3475:55: warning: ISO C++ did not adopt string literal operator templates taking an argument pack of characters [-Wpedantic]\r\n 3475 | FMT_CONSTEXPR internal::udl_formatter<Char, CHARS...> operator\"\"_format() {\r\n      |                                                       ^~~~~~~~\r\n```\r\n\r\nIf someone has an idea I can help to validate the fix.\n", "hints_text": "This is part of the fmtlib code. Seems it has already been  reported [here](https://github.com/fmtlib/fmt/issues/1148).\nAh thanks for the link. It looks like they have fixed the problem so whenever you guys update fmtlib this should be fixed.\n\n> On May 15, 2019, at 4:37 PM, Gabi Melman <notifications@github.com> wrote:\n> \n> This is part of the fmtlib code. Seems it has already been reported here <https://github.com/fmtlib/fmt/issues/1148>.\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/gabime/spdlog/issues/1077?email_source=notifications&email_token=AC2O6UMLOOBPVOFKLMA52XLPVSNEZA5CNFSM4HNGGAY2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODVQHWYY#issuecomment-492862307>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AC2O6UN7X3FTBGBPREGZIHTPVSNEZANCNFSM4HNGGAYQ>.\n> \n\n\n> Ah thanks for the link. It looks like they have fixed the problem so whenever you guys update fmtlib this should be fixed.\r\n> [\u2026](#)\r\n\r\n@gabime Would it be possible to cut a new release s.t. other projects depending on it can upgrade?\nThis will have to wait for official fmt release - some time after june 17: https://github.com/fmtlib/fmt/issues/1160#issuecomment-492449920\nPlease update when that fmt release is ready and spdlog compiles again. In the meantime, I did:\r\n\r\n<pre>diff --git a/include/spdlog/fmt/bundled/format.h b/include/spdlog/fmt/bundled/format.h\r\nindex 1bb24a5..a4dc1e1 100644\r\n--- a/include/spdlog/fmt/bundled/format.h\r\n+++ b/include/spdlog/fmt/bundled/format.h\r\n@@ -126,7 +126,7 @@ FMT_END_NAMESPACE\r\n       FMT_GCC_VERSION >= 407 || FMT_MSC_VER >= 1900) && \\\r\n       (!(FMT_ICC_VERSION || FMT_CUDA_VERSION) || \\\r\n        FMT_ICC_VERSION >= 1500 || FMT_CUDA_VERSION >= 700)\r\n-#  define FMT_USE_USER_DEFINED_LITERALS 1\r\n+#  define FMT_USE_USER_DEFINED_LITERALS 0\r\n # else\r\n #  define FMT_USE_USER_DEFINED_LITERALS 0\r\n # endif\r\n</pre>I couldn't figure out a way to do this by setting #defines.", "created_at": "2019-09-06T01:17:01Z"}
{"repo": "gabime/spdlog", "pull_number": 1127, "instance_id": "gabime__spdlog-1127", "issue_numbers": ["569"], "base_commit": "fbe6f945f32d4f583bea177e890d499a344c20ca", "patch": "diff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -26,11 +26,6 @@\n #include <windows.h>\n #endif //_WIN32\n \n-#if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)\n-#include <codecvt>\n-#include <locale>\n-#endif\n-\n #ifdef SPDLOG_COMPILED_LIB\n #undef SPDLOG_HEADER_ONLY\n #define SPDLOG_INLINE\n@@ -80,11 +75,6 @@ class sink;\n #if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)\n using filename_t = std::wstring;\n #define SPDLOG_FILENAME_T(s) L##s\n-inline std::string filename_to_str(const filename_t &filename)\n-{\n-    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> c;\n-    return c.to_bytes(filename);\n-}\n #else\n using filename_t = std::string;\n #define SPDLOG_FILENAME_T(s) s\n@@ -97,10 +87,13 @@ using err_handler = std::function<void(const std::string &err_msg)>;\n \n // string_view type - either std::string_view or fmt::string_view (pre c++17)\n #if defined(FMT_USE_STD_STRING_VIEW)\n-using string_view_t = std::string_view;\n+template<typename T>\n+using basic_string_view_t = std::basic_string_view<T>;\n #else\n-using string_view_t = fmt::string_view;\n+template<typename T>\n+using basic_string_view_t = fmt::basic_string_view<T>;\n #endif\n+using string_view_t = basic_string_view_t<char>;\n \n #if defined(SPDLOG_NO_ATOMIC_LEVELS)\n using level_t = details::null_atomic_int;\ndiff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -36,6 +36,10 @@\n #include <share.h>\n #endif\n \n+#if defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)\n+#include <limits>\n+#endif\n+\n #else // unix\n \n #include <fcntl.h>\n@@ -342,13 +346,14 @@ SPDLOG_INLINE void sleep_for_millis(int milliseconds) SPDLOG_NOEXCEPT\n \n // wchar support for windows file names (SPDLOG_WCHAR_FILENAMES must be defined)\n #if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)\n-SPDLOG_INLINE std::string filename_to_str(const filename_t &filename) SPDLOG_NOEXCEPT\n+SPDLOG_INLINE std::string filename_to_str(const filename_t &filename)\n {\n-    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> c;\n-    return c.to_bytes(filename);\n+    fmt::memory_buffer buf;\n+    wstr_to_utf8buf(filename, buf);\n+    return fmt::to_string(buf);\n }\n #else\n-SPDLOG_INLINE std::string filename_to_str(const filename_t &filename) SPDLOG_NOEXCEPT\n+SPDLOG_INLINE std::string filename_to_str(const filename_t &filename)\n {\n     return filename;\n }\n@@ -398,28 +403,42 @@ SPDLOG_INLINE bool in_terminal(FILE *file) SPDLOG_NOEXCEPT\n #endif\n }\n \n-#if defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) && defined(_WIN32)\n-SPDLOG_INLINE void wbuf_to_utf8buf(const fmt::wmemory_buffer &wbuf, fmt::memory_buffer &target)\n+#if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n+SPDLOG_INLINE void wstr_to_utf8buf(basic_string_view_t<wchar_t> wstr, fmt::memory_buffer &target)\n {\n-    int wbuf_size = static_cast<int>(wbuf.size());\n-    if (wbuf_size == 0)\n+    if (wstr.size() > static_cast<size_t>(std::numeric_limits<int>::max()))\n     {\n+        throw spdlog::spdlog_ex(\"UTF-16 string is too big to be converted to UTF-8\");\n+    }\n+\n+    int wstr_size = static_cast<int>(wstr.size());\n+    if (wstr_size == 0)\n+    {\n+        target.resize(0);\n         return;\n     }\n \n-    auto result_size = ::WideCharToMultiByte(CP_UTF8, 0, wbuf.data(), wbuf_size, NULL, 0, NULL, NULL);\n+    int result_size = static_cast<int>(target.capacity());\n+    if ((wstr_size + 1) * 2 > result_size)\n+    {\n+        result_size = ::WideCharToMultiByte(CP_UTF8, 0, wstr.data(), wstr_size, NULL, 0, NULL, NULL);\n+    }\n \n     if (result_size > 0)\n     {\n         target.resize(result_size);\n-        ::WideCharToMultiByte(CP_UTF8, 0, wbuf.data(), wbuf_size, &target.data()[0], result_size, NULL, NULL);\n-    }\n-    else\n-    {\n-        throw spdlog::spdlog_ex(fmt::format(\"WideCharToMultiByte failed. Last error: {}\", ::GetLastError()));\n+        result_size = ::WideCharToMultiByte(CP_UTF8, 0, wstr.data(), wstr_size, target.data(), result_size, NULL, NULL);\n+\n+        if (result_size > 0)\n+        {\n+            target.resize(result_size);\n+            return;\n+        }\n     }\n+\n+    throw spdlog::spdlog_ex(fmt::format(\"WideCharToMultiByte failed. Last error: {}\", ::GetLastError()));\n }\n-#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT) && _WIN32\n+#endif // (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n \n } // namespace os\n } // namespace details\ndiff --git a/include/spdlog/details/os.h b/include/spdlog/details/os.h\n--- a/include/spdlog/details/os.h\n+++ b/include/spdlog/details/os.h\n@@ -68,7 +68,7 @@ size_t thread_id() SPDLOG_NOEXCEPT;\n // See https://github.com/gabime/spdlog/issues/609\n void sleep_for_millis(int milliseconds) SPDLOG_NOEXCEPT;\n \n-std::string filename_to_str(const filename_t &filename) SPDLOG_NOEXCEPT;\n+std::string filename_to_str(const filename_t &filename);\n \n int pid() SPDLOG_NOEXCEPT;\n \n@@ -80,8 +80,8 @@ bool is_color_terminal() SPDLOG_NOEXCEPT;\n // Source: https://github.com/agauniyal/rang/\n bool in_terminal(FILE *file) SPDLOG_NOEXCEPT;\n \n-#if defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) && defined(_WIN32)\n-void wbuf_to_utf8buf(const fmt::wmemory_buffer &wbuf, fmt::memory_buffer &target);\n+#if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n+void wstr_to_utf8buf(basic_string_view_t<wchar_t> wstr, fmt::memory_buffer &target);\n #endif\n \n } // namespace os\ndiff --git a/include/spdlog/logger.h b/include/spdlog/logger.h\n--- a/include/spdlog/logger.h\n+++ b/include/spdlog/logger.h\n@@ -243,8 +243,10 @@ class logger\n             // format to wmemory_buffer and convert to utf8\n             fmt::wmemory_buffer wbuf;\n             fmt::format_to(wbuf, fmt, args...);\n+\n             fmt::memory_buffer buf;\n-            details::os::wbuf_to_utf8buf(wbuf, buf);\n+            details::os::wstr_to_utf8buf(basic_string_view_t<wchar_t>(wbuf.data(), wbuf.size()), buf);\n+\n             details::log_msg log_msg(source, name_, lvl, string_view_t(buf.data(), buf.size()));\n             sink_it_(log_msg);\n         }\n", "test_patch": "", "problem_statement": "VS 2017 Update 15.5: Build Error C4996\nWith update 15.5, MSVC has drastically changed the behaviour of the std::allocator. Just wanted to give you a heads-up:\r\n\r\n`Error\tC4996\t'std::allocator<char>::allocate': warning STL4010: Various members of std::allocator are deprecated in C++17. Use std::allocator_traits instead of accessing these members directly. You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.\t...\\include\\spdlog\\fmt\\bundled\\format.h\t903\t`\r\n\r\nLemme know if you need any more info.\r\n\n", "hints_text": "Thanks i will take a look\nJust to give some additional info.  In spdlog specific code, a similar deprecated-related error appears at line 371 below when SPDLOG_WIDECHAR_FILENAMES is defined.  MSDN says to consider using MultiByteToWideChar() and WideCharToMultiByte() from <Windows.h> instead.  The error is C4996, with warning STL4017.\r\n\r\nhttps://github.com/gabime/spdlog/blob/88fe218741d46deed401f5458dbbda6fa1c1f2f2/include/spdlog/details/os.h#L366-L373\nSame problem on Visual Studio 2017 update 15.7 \r\nI couldn't build with folowing defines \r\n```\r\nSPDLOG_WCHAR_TO_UTF8_SUPPORT\r\nSPDLOG_WCHAR_FILENAMES\r\n```\r\nwith C++17", "created_at": "2019-06-30T23:06:33Z"}
{"repo": "gabime/spdlog", "pull_number": 1105, "instance_id": "gabime__spdlog-1105", "issue_numbers": ["1104"], "base_commit": "e0b4ec54bd044e414081d0554b71994b6ce74e25", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -80,12 +80,10 @@ target_link_libraries(spdlog_header_only INTERFACE Threads::Threads)\n #---------------------------------------------------------------------------------------\n if(SPDLOG_MASTER_PROJECT)\n     if (CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang|AppleClang\")\n-        target_compile_options( spdlog PUBLIC -Wall -Wextra -Wconversion -pedantic -Wfatal-errors)\n-        target_compile_options( spdlog_header_only INTERFACE -Wall -Wextra -Wconversion -pedantic -Wfatal-errors)\n+        target_compile_options( spdlog PRIVATE -Wall -Wextra -Wconversion -pedantic -Wfatal-errors)\n     endif()\n     if (CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n-        target_compile_options( spdlog PUBLIC /W3 /WX )\n-        target_compile_options( spdlog_header_only INTERFACE /W3 /WX)\n+        target_compile_options( spdlog PRIVATE /W3 /WX )\n     endif()\n \n     include(cmake/sanitizers.cmake)\n@@ -162,4 +160,4 @@ if (SPDLOG_INSTALL)\n     #---------------------------------------------------------------------------------------\n     include(cmake/spdlogCPack.cmake)\n \n-endif ()\n\\ No newline at end of file\n+endif ()\n", "test_patch": "", "problem_statement": "CMake config imposes -Wextra -Wconversion on library users\nIn my installation, file `lib64/spdlog/cmake/spdlogConfigTargets.cmake` contains the following code:\r\n```cmake\r\nset_target_properties(spdlog::spdlog_header_only PROPERTIES\r\n  INTERFACE_COMPILE_OPTIONS \"-Wall;-Wextra;-Wconversion;-pedantic;-Wfatal-errors\"\r\n  INTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"\r\n  INTERFACE_LINK_LIBRARIES \"Threads::Threads\"\r\n)\r\n```\r\nThis means that simply using `spdlog` in my application, for example like this:\r\n```cmake\r\nfind_package(spdlog REQUIRED)\r\ntarget_link_libraries(foo spdlog::spdlog)\r\n```\r\n...will build my code with `-Wall -Wextra -Wconversion -pedantic -Wfatal-errors`. That is very wrong.\r\n\r\nI think that this was introduced in 6636ae6e633b3f888ab5504db09f91091fdab9a5 and 54f1941691ac0f8b51d8122a98c259c87cf8026b. That code looks like something that was probably supposed to kick in only when building `spdlog` itself, but it actually affects the resulting CMake configuration files as well. So, when I use CMake to *build* spdlog, these only-for-spdlog options actually taint the resulting CMake config files, and these extra warnings are imposed on code which only \"uses\" `spdlog`.\n", "hints_text": "", "created_at": "2019-06-10T01:38:48Z"}
{"repo": "gabime/spdlog", "pull_number": 985, "instance_id": "gabime__spdlog-985", "issue_numbers": ["982"], "base_commit": "2d96896fae1fcc81a931b06ed244c489ca0522f4", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -54,7 +54,7 @@ option(SPDLOG_BUILD_BENCH \"Build benchmarks (Requires https://github.com/google/\n option(SPDLOG_BUILD_TESTS \"Build tests\" ${SPDLOG_MASTER_PROJECT})\n option(SPDLOG_FMT_EXTERNAL \"Use external fmt library instead of bundled\" OFF)\n \n-if(SPDLOG_FMT_EXTERNAL)\n+if(SPDLOG_FMT_EXTERNAL AND NOT TARGET fmt::fmt)\n     find_package(fmt REQUIRED CONFIG)\n endif()\n \n", "test_patch": "", "problem_statement": "Including both fmt and spdlog as subdirectories\nI have a project where I want to include both spdlog and fmt as subdirectories, and use both of them be installed as subdirectories.\r\n\r\nThis \"should\" be trivial:\r\n```\r\nSET(SPDLOG_FMT_EXTERNAL ON CACHE BOOL \"\")\r\n\r\nadd_subdirectory(path_to_fmt)\r\nadd_subdirectory(path_to_spdlog)\r\n```\r\n\r\nBut there's a problem. When using SPDLOG_FMT_EXTERNAL, spdlog always looks for fmt through `find_package()`, which will fail.\r\n\r\nThis should be fixable by changing [this](https://github.com/gabime/spdlog/blob/ac8a7bc12d389c72b508a499efbb5e9b594ef3d5/CMakeLists.txt#L57) check to:\r\n\r\n```\r\nif( SPDLOG_FMT_EXTERNAL AND NOT TARGET fmt::fmt )\r\n```\r\n\r\n(That is all unless there's some cmake magic I'm not aware about that can be used to prevent `find_package()` from running from my top-level project, of course...)\n", "hints_text": "", "created_at": "2019-02-01T17:16:04Z"}
{"repo": "gabime/spdlog", "pull_number": 978, "instance_id": "gabime__spdlog-978", "issue_numbers": ["968"], "base_commit": "00e89a23f683c135ee2315bd15ca576acef6138b", "patch": "diff --git a/include/spdlog/sinks/basic_file_sink.h b/include/spdlog/sinks/basic_file_sink.h\n--- a/include/spdlog/sinks/basic_file_sink.h\n+++ b/include/spdlog/sinks/basic_file_sink.h\n@@ -30,6 +30,11 @@ class basic_file_sink final : public base_sink<Mutex>\n         file_helper_.open(filename, truncate);\n     }\n \n+    const filename_t &filename() const\n+    {\n+        return file_helper_.filename();\n+    }\n+\n protected:\n     void sink_it_(const details::log_msg &msg) override\n     {\ndiff --git a/include/spdlog/sinks/daily_file_sink.h b/include/spdlog/sinks/daily_file_sink.h\n--- a/include/spdlog/sinks/daily_file_sink.h\n+++ b/include/spdlog/sinks/daily_file_sink.h\n@@ -63,6 +63,11 @@ class daily_file_sink final : public base_sink<Mutex>\n         rotation_tp_ = next_rotation_tp_();\n     }\n \n+    const filename_t &filename() const\n+    {\n+        return file_helper_.filename();\n+    }\n+\n protected:\n     void sink_it_(const details::log_msg &msg) override\n     {\ndiff --git a/include/spdlog/sinks/rotating_file_sink.h b/include/spdlog/sinks/rotating_file_sink.h\n--- a/include/spdlog/sinks/rotating_file_sink.h\n+++ b/include/spdlog/sinks/rotating_file_sink.h\n@@ -58,6 +58,11 @@ class rotating_file_sink final : public base_sink<Mutex>\n         return fmt::to_string(w);\n     }\n \n+    const filename_t &filename() const\n+    {\n+        return file_helper_.filename();\n+    }\n+\n protected:\n     void sink_it_(const details::log_msg &msg) override\n     {\n", "test_patch": "", "problem_statement": "Getting filename sink is pointed to\nHello, I am trying to share the same file sink between multiple loggers, but I would like to use the sink pointers that are held by a given logger instead of maintaining a list of my own.  I know I can iterate the vector of sinks in a logger, but cannot find out what the filename it is using because it's private.  Can that detail be exposed in the API?  I'm happy to submit a PR to do it if it's something desirable.\n", "hints_text": "Which specific file sink type? there are several types of file sinks. \r\nMaybe its better to expose the filename in all of them for sake of completness.\nI was using the basic file sink. With something like the daily rotating sink, I suppose you may want to know both the base file name and the current open file name.  The same method name should be shared for the file sinks, my guess would be that it would be for the file name passed in to the constructor, and include an additional method to return the calculated file name.\nThe file_helper member already has ```const filename_t &filename() const```. All that is needed is to expose in the sinks.\nIn the case of the rotating sinks, I can think of use-cases where you'd want to know both, the current file name and the base file name.\nwhich usecases for example?\nIn the case that you are trying to retrieve the sink pointer from a logger, getting the whole filename instead of the base filename would make the comparison more difficult than necessary.\r\nIn the case that you are trying to identify the file a given sink is writing to, it would be useful to have the actual filename.\nLets start with the simpe case of returning the filename. If there is future demand for getting the base, we would add it.", "created_at": "2019-01-23T18:39:18Z"}
{"repo": "gabime/spdlog", "pull_number": 977, "instance_id": "gabime__spdlog-977", "issue_numbers": ["975"], "base_commit": "a7148b718ea2fabb8387cb90aee9bf448da63e65", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -30,7 +30,6 @@ if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\" OR \"${CMAKE_CXX_COMPILER_ID}\" MATCH\n     add_compile_options(\"-Wconversion\")\n     add_compile_options(\"-pedantic\")\n     add_compile_options(\"-Wfatal-errors\")\n-    \n endif()\n \n #---------------------------------------------------------------------------------------\n@@ -47,11 +46,11 @@ add_library(spdlog::spdlog ALIAS spdlog)\n # Check if spdlog is being used directly or via add_subdirectory\n set(SPDLOG_MASTER_PROJECT OFF)\n if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n-  set(SPDLOG_MASTER_PROJECT ON)\n+    set(SPDLOG_MASTER_PROJECT ON)\n endif()\n \n option(SPDLOG_BUILD_EXAMPLES \"Build examples\" ${SPDLOG_MASTER_PROJECT})\n-option(SPDLOG_BUILD_BENCH \"Build benchmarks\" ${SPDLOG_MASTER_PROJECT})\n+option(SPDLOG_BUILD_BENCH \"Build benchmarks (Requires https://github.com/google/benchmark.git to be installed)\" OFF)\n option(SPDLOG_BUILD_TESTS \"Build tests\" ${SPDLOG_MASTER_PROJECT})\n option(SPDLOG_FMT_EXTERNAL \"Use external fmt library instead of bundled\" OFF)\n \n", "test_patch": "", "problem_statement": "Configuration with cmake failes in 1.3.1\nWhen running this:\r\n\r\n`cd $(mktemp -d) && git clone https://github.com/gabime/spdlog.git && cd spdlog && git checkout v1.3.1 && mkdir build && cd build && cmake .. && make -j;`\r\n\r\nI get this:\r\n\r\n```\r\n-- The CXX compiler identification is GNU 8.2.1\r\n-- Check for working CXX compiler: /usr/bin/c++\r\n-- Check for working CXX compiler: /usr/bin/c++ -- works\r\n-- Detecting CXX compiler ABI info\r\n-- Detecting CXX compiler ABI info - done\r\n-- Detecting CXX compile features\r\n-- Detecting CXX compile features - done\r\n-- Build type: Release\r\n-- Looking for C++ include pthread.h\r\n-- Looking for C++ include pthread.h - found\r\n-- Looking for pthread_create\r\n-- Looking for pthread_create - not found\r\n-- Looking for pthread_create in pthreads\r\n-- Looking for pthread_create in pthreads - not found\r\n-- Looking for pthread_create in pthread\r\n-- Looking for pthread_create in pthread - found\r\n-- Found Threads: TRUE  \r\nCMake Error at bench/CMakeLists.txt:33 (find_package):\r\n  Could not find a package configuration file provided by \"benchmark\" with\r\n  any of the following names:\r\n\r\n    benchmarkConfig.cmake\r\n    benchmark-config.cmake\r\n\r\n  Add the installation prefix of \"benchmark\" to CMAKE_PREFIX_PATH or set\r\n  \"benchmark_DIR\" to a directory containing one of the above files.  If\r\n  \"benchmark\" provides a separate development package or SDK, be sure it has\r\n  been installed.\r\n\r\n\r\n-- Configuring incomplete, errors occurred!\r\nSee also \"/tmp/tmp.dnMfTPt6TI/spdlog/build/CMakeFiles/CMakeOutput.log\".\r\nSee also \"/tmp/tmp.dnMfTPt6TI/spdlog/build/CMakeFiles/CMakeError.log\".\r\n```\r\n\r\nMy cmake version is `3.13.2`.\n", "hints_text": "spdlog doesn't install google-benchmark. You need to install it beforehand if you want to compile the bench\nNot very intuitive for the baseline configuration.\r\nThis might be worth a hint in the `INSTALL` section: `...Use -DSPDLOG_BUILD_BENCH=OFF if you don't want to build the benchmark for which you need google-benchmark to be installed...`.\r\n\r\nWhat do you think?\nok. PR would be welcome. maybe even it should be OFF by default.\nThank you for that opportunity. Will do so!", "created_at": "2019-01-23T09:42:22Z"}
{"repo": "gabime/spdlog", "pull_number": 962, "instance_id": "gabime__spdlog-962", "issue_numbers": ["961"], "base_commit": "0a4ccf22da852692410940584f754cc0be36ecee", "patch": "diff --git a/bench/CMakeLists.txt b/bench/CMakeLists.txt\n--- a/bench/CMakeLists.txt\n+++ b/bench/CMakeLists.txt\n@@ -30,20 +30,19 @@ if(NOT TARGET spdlog)\n endif()\n \n find_package(Threads REQUIRED)\n+find_package(benchmark CONFIG REQUIRED)\n \n add_executable(bench bench.cpp)\n-target_link_libraries(bench spdlog::spdlog Threads::Threads)\n+target_link_libraries(bench PRIVATE spdlog::spdlog Threads::Threads)\n \n add_executable(async_bench async_bench.cpp)\n-target_link_libraries(async_bench spdlog::spdlog Threads::Threads)\n+target_link_libraries(async_bench PRIVATE spdlog::spdlog Threads::Threads)\n \n add_executable(latency latency.cpp)\n-set(CMAKE_CXX_STANDARD_LIBRARIES -lbenchmark)\n-target_link_libraries(latency spdlog::spdlog Threads::Threads)\n+target_link_libraries(latency PRIVATE benchmark::benchmark spdlog::spdlog Threads::Threads)\n \n \n add_executable(formatter-bench formatter-bench.cpp)\n-set(CMAKE_CXX_STANDARD_LIBRARIES -lbenchmark)\n-target_link_libraries(formatter-bench spdlog::spdlog Threads::Threads)\n+target_link_libraries(formatter-bench PRIVATE benchmark::benchmark spdlog::spdlog Threads::Threads)\n \n file(MAKE_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}/logs\")\n", "test_patch": "", "problem_statement": "Win32: failed to link to benchmark\nWhen I was trying to update `vcpkg`'s spdlog to 1.3.0, the linker complains that: \r\n>LINK : warning LNK4044: unrecognized option '/lbenchmark'; ignored\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"void __cdecl benchmark::Initialize(int *,char * *)\" (?Initialize@benchmark@@YAXPAHPAPAD@Z) referenced in function _main\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"unsigned int __cdecl benchmark::RunSpecifiedBenchmarks(void)\" (?RunSpecifiedBenchmarks@benchmark@@YAIXZ) referenced in function _main\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"void __cdecl benchmark::internal::UseCharPointer(char const volatile *)\" (?UseCharPointer@internal@benchmark@@YAXPDD@Z) referenced in function \"void __cdecl benchmark::DoNotOptimize<int>(int const &)\" (??$DoNotOptimize@H@benchmark@@YAXABH@Z)\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"class benchmark::internal::Benchmark * __cdecl benchmark::internal::RegisterBenchmarkInternal(class benchmark::internal::Benchmark *)\" (?RegisterBenchmarkInternal@internal@benchmark@@YAPAVBenchmark@12@PAV312@@Z) referenced in function \"class benchmark::internal::Benchmark * __cdecl benchmark::RegisterBenchmark<class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> >(char const *,class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> &&)\" (??$RegisterBenchmark@V<lambda_217ee79a96ba3e5823c7b6e5b5e8b443>@@@benchmark@@YAPAVBenchmark@internal@0@PBD$$QAV<lambda_217ee79a96ba3e5823c7b6e5b5e8b443>@@@Z)\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"int __cdecl benchmark::internal::InitializeStreams(void)\" (?InitializeStreams@internal@benchmark@@YAHXZ) referenced in function \"void __cdecl benchmark::internal::`dynamic initializer for 'stream_init_anchor''(void)\" (??__Estream_init_anchor@internal@benchmark@@YAXXZ)\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"private: void __thiscall benchmark::State::StartKeepRunning(void)\" (?StartKeepRunning@State@benchmark@@AAEXXZ) referenced in function \"public: struct benchmark::State::StateIterator __thiscall benchmark::State::end(void)\" (?end@State@benchmark@@QAE?AUStateIterator@12@XZ)\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"private: void __thiscall benchmark::State::FinishKeepRunning(void)\" (?FinishKeepRunning@State@benchmark@@AAEXXZ) referenced in function \"public: bool __thiscall benchmark::State::StateIterator::operator!=(struct benchmark::State::StateIterator const &)const \" (??9StateIterator@State@benchmark@@QBE_NABU012@@Z)\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"public: virtual __thiscall benchmark::internal::Benchmark::~Benchmark(void)\" (??1Benchmark@internal@benchmark@@UAE@XZ) referenced in function \"public: virtual __thiscall benchmark::internal::LambdaBenchmark<class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> >::~LambdaBenchmark<class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> >(void)\" (??1?$LambdaBenchmark@V<lambda_217ee79a96ba3e5823c7b6e5b5e8b443>@@@internal@benchmark@@UAE@XZ)\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"public: class benchmark::internal::Benchmark * __thiscall benchmark::internal::Benchmark::UseRealTime(void)\" (?UseRealTime@Benchmark@internal@benchmark@@QAEPAV123@XZ) referenced in function _main\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"public: class benchmark::internal::Benchmark * __thiscall benchmark::internal::Benchmark::Threads(int)\" (?Threads@Benchmark@internal@benchmark@@QAEPAV123@H@Z) referenced in function _main\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"protected: __thiscall benchmark::internal::Benchmark::Benchmark(char const *)\" (??0Benchmark@internal@benchmark@@IAE@PBD@Z) referenced in function \"private: __thiscall benchmark::internal::LambdaBenchmark<class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> >::LambdaBenchmark<class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> ><class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> >(char const *,class <lambda_217ee79a96ba3e5823c7b6e5b5e8b443> &&)\" (??$?0V<lambda_217ee79a96ba3e5823c7b6e5b5e8b443>@@@?$LambdaBenchmark@V<lambda_217ee79a96ba3e5823c7b6e5b5e8b443>@@@internal@benchmark@@AAE@PBD$$QAV<lambda_217ee79a96ba3e5823c7b6e5b5e8b443>@@@Z)\r\nlatency.cpp.obj : error LNK2019: unresolved external symbol \"public: static struct benchmark::CPUInfo const & __cdecl benchmark::CPUInfo::Get(void)\" (?Get@CPUInfo@benchmark@@SAABU12@XZ) referenced in function _main\r\nbench\\latency.exe : fatal error LNK1120: 12 unresolved externals\r\n[23/26] cmd.exe /C \"cd . && E:\\vcpkg\\downloads\\tools\\cmake-3.12.4-windows\\cmake-3.12.4-win32-x86\\bin\\cmake.exe -E vs_link_exe --intdir=bench\\CMakeFiles\\bench.dir --manifests  -- C:\\PROGRA~2\\MIB055~1\\2017\\ENTERP~1\\VC\\Tools\\MSVC\\1415~1.267\\bin\\Hostx64\\x86\\link.exe  bench\\CMakeFiles\\bench.dir\\bench.cpp.obj  /out:bench\\bench.exe /implib:bench\\bench.lib /pdb:bench\\bench.pdb /version:0.0  /machine:X86 /debug /INCREMENTAL  /subsystem:console  E:\\vcpkg\\installed\\x86-windows\\debug\\lib\\fmtd.lib -lbenchmark && cd .\"\n", "hints_text": "", "created_at": "2019-01-14T12:19:10Z"}
{"repo": "gabime/spdlog", "pull_number": 917, "instance_id": "gabime__spdlog-917", "issue_numbers": ["914"], "base_commit": "e601ebe19b8afe8198f8df4e6c2523bbdd23a196", "patch": "diff --git a/include/spdlog/details/fmt_helper.h b/include/spdlog/details/fmt_helper.h\n--- a/include/spdlog/details/fmt_helper.h\n+++ b/include/spdlog/details/fmt_helper.h\n@@ -18,6 +18,7 @@ inline spdlog::string_view_t to_string_view(const fmt::basic_memory_buffer<char,\n {\n     return spdlog::string_view_t(buf.data(), buf.size());\n }\n+\n template<size_t Buffer_Size1, size_t Buffer_Size2>\n inline void append_buf(const fmt::basic_memory_buffer<char, Buffer_Size1> &buf, fmt::basic_memory_buffer<char, Buffer_Size2> &dest)\n {\n@@ -42,6 +43,12 @@ inline void append_int(T n, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\n     dest.append(i.data(), i.data() + i.size());\n }\n \n+template<typename T>\n+inline unsigned count_digits(T n)\n+{\n+    using count_type = std::conditional<(sizeof(T) > sizeof(std::uint32_t)), std::uint64_t, std::uint32_t>::type;\n+    return fmt::internal::count_digits(static_cast<count_type>(n));\n+}\n \n template<size_t Buffer_Size>\n inline void pad2(int n, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\n@@ -60,23 +67,21 @@ inline void pad2(int n, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\n         dest.push_back('0');\n         dest.push_back(static_cast<char>('0' + n));\n     }\n-    else    // negatives (unlikely, but just in case, let fmt deal with it)\n+    else // negatives (unlikely, but just in case, let fmt deal with it)\n     {\n         fmt::format_to(dest, \"{:02}\", n);\n     }\n }\n \n-\n-\n template<typename T, size_t Buffer_Size>\n inline void pad_uint(T n, unsigned int width, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\n {\n     static_assert(std::is_unsigned<T>::value, \"append_uint must get unsigned T\");\n-    auto digits = fmt::internal::count_digits(n);\n-    if(width > digits)\n+    auto digits = count_digits(n);\n+    if (width > digits)\n     {\n-        const char* zeroes = \"0000000000000000000\";\n-        dest.append(zeroes, zeroes + width-digits);\n+        const char *zeroes = \"0000000000000000000\";\n+        dest.append(zeroes, zeroes + width - digits);\n     }\n     append_int(n, dest);\n }\n@@ -87,7 +92,6 @@ inline void pad3(T n, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\n     pad_uint(n, 3, dest);\n }\n \n-\n template<typename T, size_t Buffer_Size>\n inline void pad6(T n, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\n {\n@@ -100,8 +104,6 @@ inline void pad9(T n, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\n     pad_uint(n, 9, dest);\n }\n \n-\n-\n // return fraction of a second of the given time_point.\n // e.g.\n // fraction<std::milliseconds>(tp) -> will return the millis part of the second\ndiff --git a/include/spdlog/details/pattern_formatter.h b/include/spdlog/details/pattern_formatter.h\n--- a/include/spdlog/details/pattern_formatter.h\n+++ b/include/spdlog/details/pattern_formatter.h\n@@ -487,7 +487,6 @@ class F_formatter final : public flag_formatter\n \n         auto ns = fmt_helper::time_fraction<std::chrono::nanoseconds>(msg.time);\n         fmt_helper::pad9(static_cast<size_t>(ns.count()), dest);\n-\n     }\n };\n \n@@ -653,7 +652,7 @@ class t_formatter final : public flag_formatter\n \n     void format(const details::log_msg &msg, const std::tm &, fmt::memory_buffer &dest) override\n     {\n-        const size_t field_size = fmt::internal::count_digits(msg.thread_id);\n+        const auto field_size = fmt_helper::count_digits(msg.thread_id);\n         scoped_pad p(field_size, padinfo_, dest);\n         fmt_helper::append_int(msg.thread_id, dest);\n     }\n", "test_patch": "", "problem_statement": "OSX: Getting the following error: call to 'count_digits' is ambiguous\nPlease let me know if a fix if available?\r\n\r\n```\r\nXXX/lib/spdlog/include/spdlog/details/pattern_formatter.h:656:35: error: call to 'count_digits' is ambiguous\r\n        const size_t field_size = fmt::internal::count_digits(msg.thread_id);\r\n                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nXXX/lib/spdlog/include/spdlog/fmt/bundled/format.h:904:17: note: candidate function\r\ninline unsigned count_digits(uint64_t n) {\r\n                ^\r\nXXX/lib/spdlog/include/spdlog/fmt/bundled/format.h:1009:17: note: candidate function\r\ninline unsigned count_digits(uint32_t n) {\r\n                ^\r\nIn file included from XXX/lib/spdlog/include/spdlog/spdlog.h:13:\r\nIn file included from XXX/lib/spdlog/include/spdlog/details/registry.h:15:\r\nIn file included from XXX/lib/spdlog/include/spdlog/logger.h:23:\r\nIn file included from XXX/lib/spdlog/include/spdlog/sinks/sink.h:9:\r\nIn file included from XXX/lib/spdlog/include/spdlog/details/pattern_formatter.h:8:\r\nXXX/lib/spdlog/include/spdlog/details/fmt_helper.h:75:19: error: call to 'count_digits' is ambiguous\r\n    auto digits = fmt::internal::count_digits(n);\r\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nXXX/lib/spdlog/include/spdlog/details/fmt_helper.h:94:5: note: in instantiation of function template specialization 'spdlog::details::fmt_helper::pad_uint<unsigned long, 500>' requested here\r\n    pad_uint(n, 6, dest);\r\n    ^\r\nXXX/lib/spdlog/include/spdlog/details/pattern_formatter.h:472:21: note: in instantiation of function template specialization 'spdlog::details::fmt_helper::pad6<unsigned long, 500>' requested here\r\n        fmt_helper::pad6(static_cast<size_t>(micros.count()), dest);\r\n                    ^\r\nXXX/lib/spdlog/include/spdlog/fmt/bundled/format.h:904:17: note: candidate function\r\ninline unsigned count_digits(uint64_t n) {\r\n                ^\r\nXXX/lib/spdlog/include/spdlog/fmt/bundled/format.h:1009:17: note: candidate function\r\ninline unsigned count_digits(uint32_t n) {\r\n                ^\r\nIn file included from XXX/lib/spdlog/include/spdlog/spdlog.h:13:\r\nIn file included from XXX/lib/spdlog/include/spdlog/details/registry.h:15:\r\nIn file included from XXX/lib/spdlog/include/spdlog/logger.h:23:\r\nIn file included from XXX/lib/spdlog/include/spdlog/sinks/sink.h:9:\r\nIn file included from XXX/lib/spdlog/include/spdlog/details/pattern_formatter.h:8:\r\n/Users/vadimmelnicuk/Developer/c/hazel/lib/spdlog/include/spdlog/details/fmt_helper.h:100:5: error: no matching function for call to 'pad_uint'\r\n    pad_uint(n, 9, dest);\r\n    ^~~~~~~~\r\nXXX/lib/spdlog/include/spdlog/details/pattern_formatter.h:489:21: note: in instantiation of function template specialization 'spdlog::details::fmt_helper::pad9<unsigned long, 500>' requested here\r\n        fmt_helper::pad9(static_cast<size_t>(ns.count()), dest);\r\n                    ^\r\nXXX/lib/spdlog/include/spdlog/details/fmt_helper.h:72:13: note: candidate template ignored: substitution failure [with T = unsigned long, Buffer_Size = 500]\r\ninline void pad_uint(T n, unsigned int width, fmt::basic_memory_buffer<char, Buffer_Size> &dest)\r\n```\n", "hints_text": "", "created_at": "2018-11-19T13:47:46Z"}
{"repo": "gabime/spdlog", "pull_number": 892, "instance_id": "gabime__spdlog-892", "issue_numbers": ["712"], "base_commit": "1aace95c8d14944358c0374bbda3ce44d759bef7", "patch": "diff --git a/include/spdlog/async.h b/include/spdlog/async.h\n--- a/include/spdlog/async.h\n+++ b/include/spdlog/async.h\n@@ -52,7 +52,7 @@ struct async_factory_impl\n \n         auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n         auto new_logger = std::make_shared<async_logger>(std::move(logger_name), std::move(sink), std::move(tp), OverflowPolicy);\n-        registry_inst.register_and_init(new_logger);\n+        registry_inst.initialize_logger(new_logger);\n         return new_logger;\n     }\n };\ndiff --git a/include/spdlog/details/registry.h b/include/spdlog/details/registry.h\n--- a/include/spdlog/details/registry.h\n+++ b/include/spdlog/details/registry.h\n@@ -47,13 +47,9 @@ class registry\n         loggers_[logger_name] = std::move(new_logger);\n     }\n \n-    void register_and_init(std::shared_ptr<logger> new_logger)\n+    void initialize_logger(std::shared_ptr<logger> new_logger)\n     {\n         std::lock_guard<std::mutex> lock(logger_map_mutex_);\n-        auto logger_name = new_logger->name();\n-        throw_if_exists_(logger_name);\n-\n-        // set the global formatter pattern\n         new_logger->set_formatter(formatter_->clone());\n \n         if (err_handler_)\n@@ -64,8 +60,11 @@ class registry\n         new_logger->set_level(level_);\n         new_logger->flush_on(flush_level_);\n \n-        // add to registry\n-        loggers_[logger_name] = std::move(new_logger);\n+        if (automatic_registration_)\n+        {\n+            throw_if_exists_(new_logger->name());\n+            loggers_[new_logger->name()] = std::move(new_logger);\n+        }\n     }\n \n     std::shared_ptr<logger> get(const std::string &logger_name)\n@@ -223,6 +222,12 @@ class registry\n         return tp_mutex_;\n     }\n \n+    void set_automatic_registration(bool automatic_regsistration)\n+    {\n+        std::lock_guard<std::mutex> lock(logger_map_mutex_);\n+        automatic_registration_ = automatic_regsistration;\n+    }\n+\n     static registry &instance()\n     {\n         static registry s_instance;\n@@ -269,6 +274,7 @@ class registry\n     std::shared_ptr<thread_pool> tp_;\n     std::unique_ptr<periodic_worker> periodic_flusher_;\n     std::shared_ptr<logger> default_logger_;\n+    bool automatic_registration_ = true;\n };\n \n } // namespace details\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -29,7 +29,7 @@ struct synchronous_factory\n     {\n         auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n         auto new_logger = std::make_shared<logger>(std::move(logger_name), std::move(sink));\n-        details::registry::instance().register_and_init(new_logger);\n+        details::registry::instance().initialize_logger(new_logger);\n         return new_logger;\n     }\n };\n@@ -125,6 +125,12 @@ inline void shutdown()\n     details::registry::instance().shutdown();\n }\n \n+// Automatic registration of loggers when using spdlog::create() or spdlog::create_async\n+inline void set_automatic_registration(bool automatic_registation)\n+{\n+    details::registry::instance().set_automatic_registration(automatic_registation);\n+}\n+\n // API for using default logger (stdout_color_mt),\n // e.g: spdlog::info(\"Message {}\", 1);\n //\n", "test_patch": "diff --git a/tests/test_registry.cpp b/tests/test_registry.cpp\n--- a/tests/test_registry.cpp\n+++ b/tests/test_registry.cpp\n@@ -93,3 +93,20 @@ TEST_CASE(\"set_default_logger(nullptr)\", \"[registry]\")\n     spdlog::set_default_logger(nullptr);\n     REQUIRE_FALSE(spdlog::default_logger());\n }\n+\n+TEST_CASE(\"disable automatic registration\", \"[registry]\")\n+{\n+    // set some global parameters\n+    spdlog::level::level_enum log_level = spdlog::level::level_enum::warn;\n+    spdlog::set_level(log_level);\n+    // but disable automatic registration\n+    spdlog::set_automatic_registration(false);\n+    auto logger1 = spdlog::create<spdlog::sinks::daily_file_sink_st>(tested_logger_name, \"filename\", 11, 59);\n+    auto logger2 = spdlog::create_async<spdlog::sinks::stdout_color_sink_mt>(tested_logger_name2);\n+    // loggers should not be part of the registry\n+    REQUIRE_FALSE(spdlog::get(tested_logger_name));\n+    REQUIRE_FALSE(spdlog::get(tested_logger_name2));\n+    // but make sure they are still initialized according to global defaults\n+    REQUIRE(logger1->level() == log_level);\n+    REQUIRE(logger2->level() == log_level);\n+}\n", "problem_statement": "Create logger without automatic registration\nIt is treacherous that if one wants to create loggers on the spot or have loggers with the same name, they have to do manually everything that `create` does (choose async or not, set level, flush policy, etc). Same things for many other functions whose documentation starts with \"Create and register\"...\r\n\r\nPersonally I do not foresee a case when I will need to register my loggers, so automatic registration is just an impediment. \r\n\r\nSome proposition for backward compatible changes:\r\n- a global flag (`set_automatic_registration`) to disable registration in convenience functions\r\n- an optional argument added to `create` (and maybe every other function automatically registering)\r\n- extra functions which would not register, naming is tricky, `create_local` ? `create_noregister`?\r\n- have the constructor of `logger`lookup the different global variables like `create` does (most intuitive, but casting for `async_logger` would be an issue)\r\n... ?\r\n\n", "hints_text": "I think the first option would be the easiest. \nthat would be fine yes", "created_at": "2018-11-04T19:31:48Z"}
{"repo": "gabime/spdlog", "pull_number": 831, "instance_id": "gabime__spdlog-831", "issue_numbers": ["830"], "base_commit": "f2ac7d730cb8afd386d897a3900ed145c392c1d9", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -45,11 +45,17 @@ include(cmake/sanitizers.cmake)\n add_library(spdlog INTERFACE)\n add_library(spdlog::spdlog ALIAS spdlog)\n \n-option(SPDLOG_BUILD_EXAMPLES \"Build examples\" ON)\n-option(SPDLOG_BUILD_BENCH \"Build benchmarks\" ON)\n+# Check if spdlog is being used directly or via add_subdirectory\n+set(SPDLOG_MASTER_PROJECT OFF)\n+if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n+  set(SPDLOG_MASTER_PROJECT ON)\n+endif()\n+\n+option(SPDLOG_BUILD_EXAMPLES \"Build examples\" ${SPDLOG_MASTER_PROJECT})\n+option(SPDLOG_BUILD_BENCH \"Build benchmarks\" ${SPDLOG_MASTER_PROJECT})\n \n cmake_dependent_option(SPDLOG_BUILD_TESTING\n-    \"Build spdlog tests\" ON\n+    \"Build spdlog tests\" ${SPDLOG_MASTER_PROJECT}\n     \"BUILD_TESTING\" OFF\n )\n \n", "test_patch": "", "problem_statement": "Change default value for SPDLOG_BUILD_TESTING\nConsider the following usage scenario: _spdlog_ is added as a Git submodule and then in the project CMakeLists included using: \r\n\r\n```cmake\r\nadd_subdirectory(third-party/spdlog)\r\n```\r\n\r\nThis will result in _spdlog_ test targets being created because `SPDLOG_BUILD_TESTING` defaults to `ON`. One can force-reset this variable after the `add_subdirectory` call, but this is not convenient.\r\n\r\nI propose to chose the default value based on whether _spdlog_ is used as a third-party dependency or as a standalone project. In other words, if _spdlog_ is included through `add_subdirectory` as in my scenario, the tests are disabled by default, and if _spdlog_ is configured standalone, then the tests are enabled by default (like they are now).\r\n\r\nSome other projects follow this approach, for example [_pybind11_](https://github.com/pybind/pybind11/blob/ef13fb2e1c89f3e67f83eb860e8f6f37954a8cb1/CMakeLists.txt#L22-L29). Here is how they do this:\r\n\r\n```cmake\r\n# Check if pybind11 is being used directly or via add_subdirectory\r\nset(PYBIND11_MASTER_PROJECT OFF)\r\nif (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\r\n  set(PYBIND11_MASTER_PROJECT ON)\r\nendif()\r\n\r\n\r\noption(PYBIND11_INSTALL \"Install pybind11 header files?\" ${PYBIND11_MASTER_PROJECT})\r\noption(PYBIND11_TEST    \"Build pybind11 test suite?\"     ${PYBIND11_MASTER_PROJECT})\r\n```\r\n\r\nI can submit a PR if you support such a change.\r\n\n", "hints_text": "Sounds good. Thanks!\nI'm a bit confused. Against which branch do you want the pull request to be? \nThe v1.x branch please. The \u201cmaster\u201d is only for legacy", "created_at": "2018-09-12T20:15:29Z"}
{"repo": "gabime/spdlog", "pull_number": 804, "instance_id": "gabime__spdlog-804", "issue_numbers": ["803"], "base_commit": "2870afdeaef1ae5041f54e4583e7e10a5d4cbc85", "patch": "diff --git a/include/spdlog/details/console_globals.h b/include/spdlog/details/console_globals.h\n--- a/include/spdlog/details/console_globals.h\n+++ b/include/spdlog/details/console_globals.h\n@@ -8,6 +8,19 @@\n #include <cstdio>\n #include <mutex>\n \n+#ifdef _WIN32\n+\n+#ifndef NOMINMAX\n+#define NOMINMAX // prevent windows redefining min/max\n+#endif\n+\n+#ifndef WIN32_LEAN_AND_MEAN\n+#define WIN32_LEAN_AND_MEAN\n+#endif\n+\n+#include <windows.h>\n+#endif\n+\n namespace spdlog {\n namespace details {\n struct console_stdout\n", "test_patch": "", "problem_statement": "Compile error under Visual Studio 2015 when wrong order of #include directives\nThe code\r\n\r\n```\r\n#include <spdlog/sinks/stdout_sinks.h>\r\n#include <spdlog/spdlog.h>\r\n\r\nint main() {\r\n\tspdlog::set_level(spdlog::level::debug);\r\n\tauto logger = spdlog::stdout_logger_st(\"stdout\");\r\n\tspdlog::get(\"stdout\")->debug(\"Log entry\");\r\n}\r\n```\r\n\r\ndoes not compile under Microsoft Visual Studio Community 2015 (Version 14.0.25431.01 Update 3). Switching the #include's removes the compile error.\n", "hints_text": "@katastrofa999 Please remember to include the actual error message next time :)\r\n\r\nSo the error presents as follows:\r\n```\r\n1>c:\\projects\\spdlog\\include\\spdlog\\details\\console_globals.h(20): error C3646: 'handle': unknown override specifier\r\n1>c:\\projects\\spdlog\\include\\spdlog\\details\\console_globals.h(20): error C2059: syntax error: ')'\r\n1>c:\\projects\\spdlog\\include\\spdlog\\details\\console_globals.h(21): error C2334: unexpected token(s) preceding '{'; skipping apparent function body\r\n```\r\n\r\nIt seems that include to \"os.h\" is missing in console_globals.h. I'll prepare a PR.\nSorry, and thanks!", "created_at": "2018-08-22T20:01:38Z"}
{"repo": "gabime/spdlog", "pull_number": 789, "instance_id": "gabime__spdlog-789", "issue_numbers": ["783"], "base_commit": "f8f2d7b9505a68e15dd1a4bc0c3b8b6f5d36380c", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -14,15 +14,19 @@ include(GNUInstallDirs)\n #---------------------------------------------------------------------------------------\n set(CMAKE_CXX_STANDARD 11)\n set(CMAKE_CXX_STANDARD_REQUIRED ON)\n+set(CMAKE_CXX_EXTENSIONS OFF)\n \n if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\" OR \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\")\n     set(CMAKE_CXX_FLAGS \"-Wall -O3 ${CMAKE_CXX_FLAGS}\")\n endif()\n \n+include(cmake/sanitizers.cmake)\n+\n #---------------------------------------------------------------------------------------\n # spdlog target\n #---------------------------------------------------------------------------------------\n add_library(spdlog INTERFACE)\n+add_library(spdlog::spdlog ALIAS spdlog)\n \n option(SPDLOG_BUILD_EXAMPLES \"Build examples\" OFF)\n cmake_dependent_option(SPDLOG_BUILD_TESTING\ndiff --git a/example/CMakeLists.txt b/example/CMakeLists.txt\n--- a/example/CMakeLists.txt\n+++ b/example/CMakeLists.txt\n@@ -24,10 +24,7 @@\n cmake_minimum_required(VERSION 3.1)\n project(SpdlogExamples CXX)\n \n-if(TARGET spdlog)\n-  # Part of the main project\n-  add_library(spdlog::spdlog ALIAS spdlog)\n-else()\n+if(NOT TARGET spdlog)\n   # Stand-alone build\n   find_package(spdlog CONFIG REQUIRED)\n endif()\n@@ -37,13 +34,10 @@ find_package(Threads REQUIRED)\n add_executable(example example.cpp)\n target_link_libraries(example spdlog::spdlog Threads::Threads)\n \n-add_executable(benchmark bench.cpp)\n-target_link_libraries(benchmark spdlog::spdlog Threads::Threads)\n-\n add_executable(multisink multisink.cpp)\n target_link_libraries(multisink spdlog::spdlog Threads::Threads)\n \n enable_testing()\n file(MAKE_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}/logs\")\n-add_test(NAME RunExample COMMAND example)\n-add_test(NAME RunBenchmark COMMAND benchmark)\n+add_test(NAME example COMMAND example)\n+add_test(NAME multisink COMMAND multisink)\ndiff --git a/example/multisink.cpp b/example/multisink.cpp\n--- a/example/multisink.cpp\n+++ b/example/multisink.cpp\n@@ -1,4 +1,4 @@\n-#include \"spdlog/sinks/file_sinks.h\"\n+#include \"spdlog/sinks/basic_file_sink.h\"\n #include \"spdlog/sinks/stdout_sinks.h\"\n #include \"spdlog/spdlog.h\"\n #include <iostream>\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -18,7 +18,7 @@ set(SPDLOG_UTESTS_SOURCES\n \n add_executable(${PROJECT_NAME} ${SPDLOG_UTESTS_SOURCES})\n target_link_libraries(${PROJECT_NAME} PRIVATE Threads::Threads)\n-target_link_libraries(${PROJECT_NAME} PRIVATE spdlog)\n+target_link_libraries(${PROJECT_NAME} PRIVATE spdlog::spdlog)\n \n add_test(NAME ${PROJECT_NAME} COMMAND ${PROJECT_NAME})\n file(MAKE_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}/logs\")\n", "problem_statement": "Cannot find source file: bench.cpp\nin examples CMakeLists.txt was mentioned bench.cpp , but it is not in the folder.\n", "hints_text": "", "created_at": "2018-08-11T00:30:41Z"}
{"repo": "gabime/spdlog", "pull_number": 719, "instance_id": "gabime__spdlog-719", "issue_numbers": ["717", "717"], "base_commit": "d033ccc0c70b3705cd799535a8658a9e9aae3192", "patch": "diff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -143,11 +143,6 @@ enum class pattern_time_type\n //\n // Log exception\n //\n-namespace details {\n-namespace os {\n-std::string errno_str(int err_num);\n-}\n-} // namespace details\n class spdlog_ex : public std::exception\n {\n public:\n@@ -158,7 +153,15 @@ class spdlog_ex : public std::exception\n \n     spdlog_ex(const std::string &msg, int last_errno)\n     {\n-        _msg = msg + \": \" + details::os::errno_str(last_errno);\n+        char buf[256], *buf_ptr = buf;\n+        SPDLOG_CONSTEXPR auto buf_size = sizeof(buf);\n+        if (fmt::safe_strerror(last_errno, buf_ptr, buf_size) != 0)\n+        {\n+            buf_ptr = buf;\n+            char unknown[] = \"Unknown error\";\n+            std::copy(unknown, unknown + sizeof(unknown), buf_ptr);\n+        }\n+        _msg = msg + \": \" + std::string(buf_ptr);\n     }\n \n     const char *what() const SPDLOG_NOEXCEPT override\ndiff --git a/include/spdlog/details/os.h b/include/spdlog/details/os.h\n--- a/include/spdlog/details/os.h\n+++ b/include/spdlog/details/os.h\n@@ -383,54 +383,6 @@ inline std::string filename_to_str(const filename_t &filename)\n }\n #endif\n \n-inline std::string errno_to_string(char[256], char *res)\n-{\n-    return std::string(res);\n-}\n-\n-inline std::string errno_to_string(char buf[256], int res)\n-{\n-    if (res == 0)\n-    {\n-        return std::string(buf);\n-    }\n-    return \"Unknown error\";\n-}\n-\n-// Return errno string (thread safe)\n-inline std::string errno_str(int err_num)\n-{\n-    char buf[256];\n-    SPDLOG_CONSTEXPR auto buf_size = sizeof(buf);\n-\n-#ifdef _WIN32\n-    if (strerror_s(buf, buf_size, err_num) == 0)\n-    {\n-        return std::string(buf);\n-    }\n-    else\n-    {\n-        return \"Unknown error\";\n-    }\n-\n-#elif defined(__FreeBSD__) || defined(__APPLE__) || defined(ANDROID) || defined(__SUNPRO_CC) ||                                            \\\n-    ((_POSIX_C_SOURCE >= 200112L) && !defined(_GNU_SOURCE)) // posix version\n-\n-    if (strerror_r(err_num, buf, buf_size) == 0)\n-    {\n-        return std::string(buf);\n-    }\n-    else\n-    {\n-        return \"Unknown error\";\n-    }\n-\n-#else // gnu version (might not use the given buf, so its retval pointer must be used)\n-    auto err = strerror_r(err_num, buf, buf_size); // let compiler choose type\n-    return errno_to_string(buf, err);              // use overloading to select correct stringify function\n-#endif\n-}\n-\n inline int pid()\n {\n \n", "test_patch": "", "problem_statement": "Compile failure on sparc Solaris 9\nCompile fails on Solaris 9 as Solaris 9 does not have `strerror_r`:\r\n```\r\n[solaris_sparc] /home/jenkins/build/workspace/Fractions_XPlatform@2/3rdparty/spdlog_1fcc89/include/spdlog/details/os.h:430:36: error: no matching function for call to \u2018errno_to_string(char [256], fmt::internal::Null<>&)\u2019\r\n[solaris_sparc]      return errno_to_string(buf, err);              // use overloading to select correct stringify function\r\n```\r\nthis is technically a failure in `fmt` for not falling back to a thread-unsafe version on systems where there is no thread-safe version perhaps?\r\n\r\nHowever, this can be fixed in `spdlog` by adding an inline overload for `::Null<>` - will submit a PR soon.\nCompile failure on sparc Solaris 9\nCompile fails on Solaris 9 as Solaris 9 does not have `strerror_r`:\r\n```\r\n[solaris_sparc] /home/jenkins/build/workspace/Fractions_XPlatform@2/3rdparty/spdlog_1fcc89/include/spdlog/details/os.h:430:36: error: no matching function for call to \u2018errno_to_string(char [256], fmt::internal::Null<>&)\u2019\r\n[solaris_sparc]      return errno_to_string(buf, err);              // use overloading to select correct stringify function\r\n```\r\nthis is technically a failure in `fmt` for not falling back to a thread-unsafe version on systems where there is no thread-safe version perhaps?\r\n\r\nHowever, this can be fixed in `spdlog` by adding an inline overload for `::Null<>` - will submit a PR soon.\n", "hints_text": "\n", "created_at": "2018-06-01T11:25:17Z"}
{"repo": "gabime/spdlog", "pull_number": 715, "instance_id": "gabime__spdlog-715", "issue_numbers": ["74"], "base_commit": "67a6eaf23ed38cf37ee872dbf513443ca28869dd", "patch": "diff --git a/include/spdlog/details/os.h b/include/spdlog/details/os.h\n--- a/include/spdlog/details/os.h\n+++ b/include/spdlog/details/os.h\n@@ -282,7 +282,7 @@ inline int utc_minutes_offset(const std::tm &tm = details::os::localtime())\n     return offset;\n #else\n \n-#if defined(sun) || defined(__sun)\n+#if defined(sun) || defined(__sun) || defined(_AIX)\n     // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris\n     struct helper\n     {\n", "test_patch": "", "problem_statement": "Compile Errors on Mac OSX Yosemite\nWhen compiling on mac against clang LLVM 3.5, I have the following compilation error,\n\n```\nspdlog/include/spdlog/sinks/../details/./os.h:188:12: error: cannot initialize return object of type 'size_t' (aka 'unsigned long') with an rvalue of type 'pthread_t' (aka '_opaque_pthread_t *')\n    return pthread_self();\n```\n\nif you look at the file `os.h`, under the function:\n\n```\ninline size_t thread_id()\n{\n\n#ifdef SPDLOG_NO_THREAD_ID\n    return 0;\n#else\n\n#ifdef _WIN32\n    return ::GetCurrentThreadId();\n#elif __linux__\n    return  syscall(SYS_gettid);\n#else\n    return pthread_self();\n#endif\n#endif //SPDLOG_NO_THREAD_ID\n}\n```\n\nspdlog attempts to return the `struct pthread_t` which resolves to a pointer of type `_opaque_pthread_t *` of the current thread as the thread id however there is no implicit conversion for this to `size_t`. A workaround is to cast the pointer to `size_t`.\n\n", "hints_text": "Would something like \n`return static_cast<size_t>(pthread_self());` work?\n\nI don't have OSX here to try myself. \nAlso could you verify that indeed  `return  syscall(SYS_gettid);` is not supported ?\n\nHi gabime,\nThanks for the replies,\n\n`syscall(SYS_gettid)` is not supported on OSX,\n\n`return static_cast<size_t>(pthread_self());` fails because the types are different between `_opaque_pthread_t*` and `size_t`, only `reinterpret_cast<size_t>(pthread_self())` will work in this case which will cast the pointer address to type `size_t`\n\nFixed in b715378ff55eb40664d215e9264407b0310ec763 :\nUnder OSX, spdlog will use the standard c++11\n\n```\nstd::hash<std::thread::id>()(std::this_thread::get_id())\n```\n\nPlease feeback if it works for you..\n\nHi Gabime,\n\nAs far as I have tested, no issues with Mac OSX using `std::hash<std::thread::id>()(std::this_thread::get_id())`\n\nThank you for the fixes.\n\nRegards,\nZuwei\n\nWould be interesting to see if there are performance issues using this method under OSX.\n", "created_at": "2018-05-30T09:47:01Z"}
{"repo": "gabime/spdlog", "pull_number": 610, "instance_id": "gabime__spdlog-610", "issue_numbers": ["609", "609"], "base_commit": "32177aa77a0a20453d3e7455cac42406fc49b6ca", "patch": "diff --git a/include/spdlog/details/async_log_helper.h b/include/spdlog/details/async_log_helper.h\n--- a/include/spdlog/details/async_log_helper.h\n+++ b/include/spdlog/details/async_log_helper.h\n@@ -358,7 +358,6 @@ inline void spdlog::details::async_log_helper::set_formatter(formatter_ptr msg_f\n // spin, yield or sleep. use the time passed since last message as a hint\n inline void spdlog::details::async_log_helper::sleep_or_yield(const spdlog::log_clock::time_point& now, const spdlog::log_clock::time_point& last_op_time)\n {\n-    using namespace std::this_thread;\n     using std::chrono::milliseconds;\n     using std::chrono::microseconds;\n \n@@ -374,10 +373,10 @@ inline void spdlog::details::async_log_helper::sleep_or_yield(const spdlog::log_\n \n     // sleep for 20 ms upto 200 ms\n     if (time_since_op <= milliseconds(200))\n-        return sleep_for(milliseconds(20));\n+        return details::os::sleep_for_millis(20);\n \n     // sleep for 500 ms\n-    return sleep_for(milliseconds(500));\n+    return details::os::sleep_for_millis(500);\n }\n \n // wait for the queue to be empty\ndiff --git a/include/spdlog/details/file_helper.h b/include/spdlog/details/file_helper.h\n--- a/include/spdlog/details/file_helper.h\n+++ b/include/spdlog/details/file_helper.h\n@@ -55,7 +55,7 @@ class file_helper\n             if (!os::fopen_s(&_fd, fname, mode))\n                 return;\n \n-            std::this_thread::sleep_for(std::chrono::milliseconds(open_interval));\n+            details::os::sleep_for_millis(open_interval);\n         }\n \n         throw spdlog_ex(\"Failed opening file \" + os::filename_to_str(_filename) + \" for writing\", errno);\n@@ -129,7 +129,7 @@ class file_helper\n         if (ext_index == filename_t::npos || ext_index == 0 || ext_index == fname.size() - 1)\n             return std::make_tuple(fname, spdlog::filename_t());\n \n-        // treat casese like \"/etc/rc.d/somelogfile or \"/abc/.hiddenfile\"        \n+        // treat casese like \"/etc/rc.d/somelogfile or \"/abc/.hiddenfile\"\n         auto folder_index = fname.rfind(details::os::folder_sep);\n         if (folder_index != fname.npos && folder_index >= ext_index - 1)\n             return std::make_tuple(fname, spdlog::filename_t());\ndiff --git a/include/spdlog/details/os.h b/include/spdlog/details/os.h\n--- a/include/spdlog/details/os.h\n+++ b/include/spdlog/details/os.h\n@@ -362,6 +362,15 @@ inline size_t thread_id()\n \n }\n \n+// from https://github.com/gabime/spdlog/issues/609\n+inline void sleep_for_millis(int milliseconds)\n+{\n+#if defined(_WIN32)\n+    Sleep(milliseconds);\n+#else\n+    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));\n+#endif\n+}\n \n // wchar support for windows file names (SPDLOG_WCHAR_FILENAMES must be defined)\n #if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)\ndiff --git a/include/spdlog/sinks/android_sink.h b/include/spdlog/sinks/android_sink.h\n--- a/include/spdlog/sinks/android_sink.h\n+++ b/include/spdlog/sinks/android_sink.h\n@@ -8,6 +8,7 @@\n #if defined(__ANDROID__)\n \n #include \"sink.h\"\n+#include \"../details/os.h\"\n \n #include <mutex>\n #include <string>\n@@ -43,7 +44,7 @@ class android_sink : public sink\n         int retry_count = 0;\n         while ((ret == -11/*EAGAIN*/) && (retry_count < SPDLOG_ANDROID_RETRIES))\n         {\n-            std::this_thread::sleep_for(std::chrono::milliseconds(5));\n+            details::os::sleep_for_millis(5);\n             ret = __android_log_write(priority, _tag.c_str(), msg_output);\n             retry_count++;\n         }\n", "test_patch": "", "problem_statement": "Windows: sleep_for is dependent on system clock\nHey there! \ud83d\udc4b \r\n\r\nWe've hit this issue in VS Code: https://github.com/Microsoft/vscode/issues/41136\r\n\r\nUltimately here's the problem: `std::this_thread::sleep_for` is poorly implemented in Windows and depends on the system clock. When the thread is sleeping and the system clock is changed to a previous time, the sleep takes longer than expected, apparently by as much as the system clock was changed.\r\n\r\nThe bug easily reproduces with this snippet:\r\n\r\n```cpp\r\n#include \"stdafx.h\"\r\n#include <iostream>\r\n#include <chrono>\r\n#include <thread>\r\n\r\nint main()\r\n{\r\n\twhile (true) {\r\n\t\tstd::cout << \"sleeping for 500ms\" << std::endl;\r\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(500));\r\n\t}\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nSimply go back in time and one of the 500ms `sleep_for` calls will take much longer.\r\n\r\n---\r\n\r\nI found a comment in [here](https://developercommunity.visualstudio.com/content/problem/61684/stdthis-threadsleep-for-depends-on-system-time.html) which indicates that `sleep_until` doesn't have the same issue, though I don't really verify that. I tried using both `system_clock` and `steady_clock` to compute the `sleep_until` argument; the bug still happens.\r\n\r\nOf course, using the WinAPI call `Sleep` works like a charm.\r\n\r\nWould you accept a PR in which I replace `sleep_for` calls for `Sleep` calls in Windows?\nWindows: sleep_for is dependent on system clock\nHey there! \ud83d\udc4b \r\n\r\nWe've hit this issue in VS Code: https://github.com/Microsoft/vscode/issues/41136\r\n\r\nUltimately here's the problem: `std::this_thread::sleep_for` is poorly implemented in Windows and depends on the system clock. When the thread is sleeping and the system clock is changed to a previous time, the sleep takes longer than expected, apparently by as much as the system clock was changed.\r\n\r\nThe bug easily reproduces with this snippet:\r\n\r\n```cpp\r\n#include \"stdafx.h\"\r\n#include <iostream>\r\n#include <chrono>\r\n#include <thread>\r\n\r\nint main()\r\n{\r\n\twhile (true) {\r\n\t\tstd::cout << \"sleeping for 500ms\" << std::endl;\r\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(500));\r\n\t}\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nSimply go back in time and one of the 500ms `sleep_for` calls will take much longer.\r\n\r\n---\r\n\r\nI found a comment in [here](https://developercommunity.visualstudio.com/content/problem/61684/stdthis-threadsleep-for-depends-on-system-time.html) which indicates that `sleep_until` doesn't have the same issue, though I don't really verify that. I tried using both `system_clock` and `steady_clock` to compute the `sleep_until` argument; the bug still happens.\r\n\r\nOf course, using the WinAPI call `Sleep` works like a charm.\r\n\r\nWould you accept a PR in which I replace `sleep_for` calls for `Sleep` calls in Windows?\n", "hints_text": "Sure. I prefer it the be implemented in the details/os.h file for obvoius reasons\nSure. I prefer it the be implemented in the details/os.h file for obvoius reasons", "created_at": "2018-01-11T13:52:05Z"}
{"repo": "gabime/spdlog", "pull_number": 555, "instance_id": "gabime__spdlog-555", "issue_numbers": ["554"], "base_commit": "8ca1d84a324f93d67fea535fa13e53065719c5be", "patch": "diff --git a/include/spdlog/sinks/msvc_sink.h b/include/spdlog/sinks/msvc_sink.h\n--- a/include/spdlog/sinks/msvc_sink.h\n+++ b/include/spdlog/sinks/msvc_sink.h\n@@ -5,12 +5,12 @@\n \n #pragma once\n \n-#if defined(_MSC_VER)\n+#if defined(_WIN32)\n \n #include \"base_sink.h\"\n #include \"../details/null_mutex.h\"\n \n-#include <WinBase.h>\n+#include <winbase.h>\n \n #include <mutex>\n #include <string>\ndiff --git a/include/spdlog/sinks/windebug_sink.h b/include/spdlog/sinks/windebug_sink.h\nnew file mode 100644\n--- /dev/null\n+++ b/include/spdlog/sinks/windebug_sink.h\n@@ -0,0 +1,29 @@\n+//\n+// Copyright(c) 2017 Alexander Dalshov.\n+// Distributed under the MIT License (http://opensource.org/licenses/MIT)\n+//\n+\n+#pragma once\n+\n+#if defined(_WIN32)\n+\n+#include \"msvc_sink.h\"\n+\n+namespace spdlog\n+{\n+namespace sinks\n+{\n+\n+/*\n+* Windows debug sink (logging using OutputDebugStringA, synonym for msvc_sink)\n+*/\n+template<class Mutex>\n+using windebug_sink = msvc_sink<Mutex>;\n+\n+typedef msvc_sink_mt windebug_sink_mt;\n+typedef msvc_sink_st windebug_sink_st;\n+\n+}\n+}\n+\n+#endif\n", "test_patch": "", "problem_statement": "Windows debugging output\nHi. The windows debug sink can be useful out of Visual Studio and should not be limited to that IDE.\r\nThere are other tools to access the debug log, including Sysinternals Debugview, which works even in Wine.\r\nIn my opinion the support should be extended to all the Windows compilers.\r\n\r\nI propose to do these changes:\r\n* rename msvc_sink (windebug_sink? maybe also keep the old name for compatibility)\r\n* check for _WIN32 instead of _MSC_VER\r\n* rename WinBase.h to winbase.h (mingw compilation on case-sensitive fs)\n", "hints_text": "", "created_at": "2017-11-14T13:38:22Z"}
{"repo": "gabime/spdlog", "pull_number": 447, "instance_id": "gabime__spdlog-447", "issue_numbers": ["446"], "base_commit": "def86e6e204da0aa19931a2d39fadddf1614a9f7", "patch": "diff --git a/include/spdlog/details/os.h b/include/spdlog/details/os.h\n--- a/include/spdlog/details/os.h\n+++ b/include/spdlog/details/os.h\n@@ -13,8 +13,8 @@\n #include <chrono>\n #include <thread>\n #include <algorithm>\n-#include <stdio.h>\n-#include <string.h>\n+#include <cstring>\n+#include <cstdlib>\n #include <sys/stat.h>\n #include <sys/types.h>\n \n", "test_patch": "", "problem_statement": "Compilation fails on OS X due to `getenv` not being a member of namespace `std`\nCompilation errors occured in two Travis CI build jobs when spdlog commit def86e6 (HEAD of origin/master as of writing this) was checked out. Xcode images version 7.3 and 6.4 were used, with Apple Clang/LLVM version 7.3.0 and 6.1.0 as compilers, respectively. I can't verify this issue myself, as I don't own an OS X machine.\r\n\r\nThe error message:\r\n```\r\n.../spdlog/include/spdlog/details/os.h:436:25: error: no member named 'getenv' in namespace 'std'; did you mean simply 'getenv'?\r\n    const char *env_p = std::getenv(\"TERM\");\r\n                        ^~~~~\r\n/usr/include/stdlib.h:144:7: note: 'getenv' declared here\r\n    char *getenv(const char *);\r\n```\r\n\r\nWe can see the compiler being unable to find `std::getenv`. The function is declared in the headers `<stdlib.h>` (without `std::`) and `<cstdlib>` (with `std::`). The probable cause for this is, that `<cstdlib>` isn't included anywhere, but `<stdlib.h>` is.\r\n\r\nAt this moment, the includes of `details/os.h` are:\r\n\r\n```\r\n#include <spdlog/common.h>\r\n\r\n#include <cstdio>\r\n#include <ctime>\r\n#include <functional>\r\n#include <string>\r\n#include <chrono>\r\n#include <thread>\r\n#include <algorithm>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n```\r\n\r\nWe can see a mixture of C (`<stdio.h>` and `<string.h>`) and C++ (`<cstdio>` and `<ctime>`) implementations of the C standard library headers being included. I'd propose the removal of `<stdio.h>`, changing `<string.h>` to `<cstring>` and addition of `<cstdlib>` to the included headers of `detail/os.h`.\r\n\r\nThis error doesn't occur on my system (Arch Linux, libstdc++ version 3.4), probably because the headers are different and include `<cstdlib>` somewhere.\r\n\r\nThe specific build jobs with logs are here:\r\nhttps://travis-ci.org/varuna-lang/varuna/jobs/233227104 (Xcode 7.3, Apple clang 7.3.0)\r\nhttps://travis-ci.org/varuna-lang/varuna/jobs/233227106 (Xcode 6.4, Apple clang 6.1.0)\r\n\r\nI'll submit a PR if it's needed.\n", "hints_text": "Thanks. A PR would be appriciated", "created_at": "2017-05-17T18:16:56Z"}
{"repo": "gabime/spdlog", "pull_number": 436, "instance_id": "gabime__spdlog-436", "issue_numbers": ["435"], "base_commit": "e9b82867144cbb70993ce3680bfb8c30a30ca273", "patch": "diff --git a/include/spdlog/details/os.h b/include/spdlog/details/os.h\n--- a/include/spdlog/details/os.h\n+++ b/include/spdlog/details/os.h\n@@ -364,6 +364,17 @@ inline std::string filename_to_str(const filename_t& filename)\n }\n #endif\n \n+inline std::string errno_to_string(char [256], char* res) {\n+    return std::string(res);\n+}\n+    \n+inline std::string errno_to_string(char buf[256], int res) {\n+    if (res == 0) {\n+        return std::string(buf);\n+    } else {\n+        return \"Unknown error\";\n+    }\n+}\n \n // Return errno string (thread safe)\n inline std::string errno_str(int err_num)\n@@ -386,7 +397,8 @@ inline std::string errno_str(int err_num)\n         return \"Unknown error\";\n \n #else  // gnu version (might not use the given buf, so its retval pointer must be used)\n-    return std::string(strerror_r(err_num, buf, buf_size));\n+    auto err = strerror_r(err_num, buf, buf_size); // let compiler choose type\n+    return errno_to_string(buf, err); // use overloading to select correct stringify function\n #endif\n }\n \n", "test_patch": "", "problem_statement": "Spdlog can't compile on alpine linux because it doesn't detect musl correctly\n```\r\nFAILED: src/logging/CMakeFiles/logging.dir/logger.cpp.o \r\nccache /usr/bin/c++    -I/usr/local/include -I/project/src/. -Isrc -isystem /project/3rd-party/spdlog/include -Wall -Werror -Wshadow -Wextra   -std=gnu++14 -MD -MT src/logging/CMakeFiles/logging.dir/logger.cpp.o -MF src/logging/CMakeFiles/logging.dir/logger.cpp.o.d -o src/logging/CMakeFiles/logging.dir/logger.cpp.o -c /project/src/logging/logger.cpp\r\nIn file included from /project/3rd-party/spdlog/include/spdlog/details/log_msg.h:9:0,\r\n                 from /project/3rd-party/spdlog/include/spdlog/sinks/sink.h:9,\r\n                 from /project/3rd-party/spdlog/include/spdlog/sinks/base_sink.h:13,\r\n                 from /project/3rd-party/spdlog/include/spdlog/logger.h:15,\r\n                 from /project/3rd-party/spdlog/include/spdlog/spdlog.h:14,\r\n                 from /project/src/logging/logger.h:5,\r\n                 from /project/src/logging/logger.cpp:2:\r\n/project/3rd-party/spdlog/include/spdlog/details/os.h: In function 'std::__cxx11::string spdlog::details::os::errno_str(int)':\r\n/project/3rd-party/spdlog/include/spdlog/details/os.h:389:58: error: no matching function for call to 'std::__cxx11::basic_string<char>::basic_string(int)'\r\n     return std::string(strerror_r(err_num, buf, buf_size));\r\n                                                          ^\r\nIn file included from /usr/include/c++/6.2.1/string:52:0,\r\n                 from /usr/include/c++/6.2.1/stdexcept:39,\r\n                 from /usr/include/c++/6.2.1/array:39,\r\n                 from /usr/include/c++/6.2.1/tuple:39,\r\n                 from /usr/include/c++/6.2.1/functional:55,\r\n                 from /usr/include/c++/6.2.1/memory:79,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/bundled/format.h:37,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/fmt.h:21,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/ostr.h:11,\r\n                 from /project/src/logging/logger.h:4,\r\n                 from /project/src/logging/logger.cpp:2:\r\n/usr/include/c++/6.2.1/bits/basic_string.h:549:9: note: candidate: template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\r\n         basic_string(_InputIterator __beg, _InputIterator __end,\r\n         ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:549:9: note:   template argument deduction/substitution failed:\r\nIn file included from /project/3rd-party/spdlog/include/spdlog/details/log_msg.h:9:0,\r\n                 from /project/3rd-party/spdlog/include/spdlog/sinks/sink.h:9,\r\n                 from /project/3rd-party/spdlog/include/spdlog/sinks/base_sink.h:13,\r\n                 from /project/3rd-party/spdlog/include/spdlog/logger.h:15,\r\n                 from /project/3rd-party/spdlog/include/spdlog/spdlog.h:14,\r\n                 from /project/src/logging/logger.h:5,\r\n                 from /project/src/logging/logger.cpp:2:\r\n/project/3rd-party/spdlog/include/spdlog/details/os.h:389:58: note:   candidate expects 3 arguments, 1 provided\r\n     return std::string(strerror_r(err_num, buf, buf_size));\r\n                                                          ^\r\nIn file included from /usr/include/c++/6.2.1/string:52:0,\r\n                 from /usr/include/c++/6.2.1/stdexcept:39,\r\n                 from /usr/include/c++/6.2.1/array:39,\r\n                 from /usr/include/c++/6.2.1/tuple:39,\r\n                 from /usr/include/c++/6.2.1/functional:55,\r\n                 from /usr/include/c++/6.2.1/memory:79,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/bundled/format.h:37,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/fmt.h:21,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/ostr.h:11,\r\n                 from /project/src/logging/logger.h:4,\r\n                 from /project/src/logging/logger.cpp:2:\r\n/usr/include/c++/6.2.1/bits/basic_string.h:511:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\r\n       basic_string(basic_string&& __str, const _Alloc& __a)\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:511:7: note:   candidate expects 2 arguments, 1 provided\r\n/usr/include/c++/6.2.1/bits/basic_string.h:507:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\r\n       basic_string(const basic_string& __str, const _Alloc& __a)\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:507:7: note:   candidate expects 2 arguments, 1 provided\r\n/usr/include/c++/6.2.1/bits/basic_string.h:503:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\r\n       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:503:7: note:   no known conversion for argument 1 from 'int' to 'std::initializer_list<char>'\r\n/usr/include/c++/6.2.1/bits/basic_string.h:476:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\r\n       basic_string(basic_string&& __str) noexcept\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:476:7: note:   no known conversion for argument 1 from 'int' to 'std::__cxx11::basic_string<char>&&'\r\n/usr/include/c++/6.2.1/bits/basic_string.h:464:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\r\n       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:464:7: note:   candidate expects 3 arguments, 1 provided\r\n/usr/include/c++/6.2.1/bits/basic_string.h:454:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] <near match>\r\n       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:454:7: note:   conversion of argument 1 would be ill-formed:\r\nIn file included from /project/3rd-party/spdlog/include/spdlog/details/log_msg.h:9:0,\r\n                 from /project/3rd-party/spdlog/include/spdlog/sinks/sink.h:9,\r\n                 from /project/3rd-party/spdlog/include/spdlog/sinks/base_sink.h:13,\r\n                 from /project/3rd-party/spdlog/include/spdlog/logger.h:15,\r\n                 from /project/3rd-party/spdlog/include/spdlog/spdlog.h:14,\r\n                 from /project/src/logging/logger.h:5,\r\n                 from /project/src/logging/logger.cpp:2:\r\n/project/3rd-party/spdlog/include/spdlog/details/os.h:389:34: error: invalid conversion from 'int' to 'const char*' [-fpermissive]\r\n     return std::string(strerror_r(err_num, buf, buf_size));\r\n                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\r\nIn file included from /usr/include/c++/6.2.1/string:52:0,\r\n                 from /usr/include/c++/6.2.1/stdexcept:39,\r\n                 from /usr/include/c++/6.2.1/array:39,\r\n                 from /usr/include/c++/6.2.1/tuple:39,\r\n                 from /usr/include/c++/6.2.1/functional:55,\r\n                 from /usr/include/c++/6.2.1/memory:79,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/bundled/format.h:37,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/fmt.h:21,\r\n                 from /project/3rd-party/spdlog/include/spdlog/fmt/ostr.h:11,\r\n                 from /project/src/logging/logger.h:4,\r\n                 from /project/src/logging/logger.cpp:2:\r\n/usr/include/c++/6.2.1/bits/basic_string.h:444:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\r\n       basic_string(const _CharT* __s, size_type __n,\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:444:7: note:   candidate expects 3 arguments, 1 provided\r\n/usr/include/c++/6.2.1/bits/basic_string.h:426:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\r\n       basic_string(const basic_string& __str, size_type __pos,\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:426:7: note:   candidate expects 4 arguments, 1 provided\r\n/usr/include/c++/6.2.1/bits/basic_string.h:410:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]\r\n       basic_string(const basic_string& __str, size_type __pos,\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:410:7: note:   candidate expects 3 arguments, 1 provided\r\n/usr/include/c++/6.2.1/bits/basic_string.h:397:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\r\n       basic_string(const basic_string& __str)\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:397:7: note:   no known conversion for argument 1 from 'int' to 'const std::__cxx11::basic_string<char>&'\r\n/usr/include/c++/6.2.1/bits/basic_string.h:389:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\r\n       basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:389:7: note:   no known conversion for argument 1 from 'int' to 'const std::allocator<char>&'\r\n/usr/include/c++/6.2.1/bits/basic_string.h:380:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\r\n       basic_string()\r\n       ^~~~~~~~~~~~\r\n/usr/include/c++/6.2.1/bits/basic_string.h:380:7: note:   candidate expects 0 arguments, 1 provided\r\nninja: build stopped: subcommand failed.\r\n```\r\n\r\n\n", "hints_text": "", "created_at": "2017-05-10T01:38:08Z"}
{"repo": "gabime/spdlog", "pull_number": 405, "instance_id": "gabime__spdlog-405", "issue_numbers": ["404"], "base_commit": "2b5c3615fde7494bd030de0e6eb4d8c4de2075a1", "patch": "diff --git a/include/spdlog/details/logger_impl.h b/include/spdlog/details/logger_impl.h\n--- a/include/spdlog/details/logger_impl.h\n+++ b/include/spdlog/details/logger_impl.h\n@@ -18,11 +18,11 @@ template<class It>\n inline spdlog::logger::logger(const std::string& logger_name, const It& begin, const It& end):\n     _name(logger_name),\n     _sinks(begin, end),\n-    _formatter(std::make_shared<pattern_formatter>(\"%+\"))\n+    _formatter(std::make_shared<pattern_formatter>(\"%+\")),\n+\t_level(level::info),\n+\t_flush_level(level::off),\n+\t_last_err_time(0)\n {\n-    _level = level::info;\n-    _flush_level = level::off;\n-    _last_err_time = 0;\n     _err_handler = [this](const std::string &msg)\n     {\n         this->_default_err_handler(msg);\n", "test_patch": "", "problem_statement": "Reading past valid address with multisink logger\nI am using a multisink logger in a Windows app and testing the app with [dr memory](http://www.drmemory.org) tool.  I get several errors related to reading past allowed memory address.\r\n\r\nThe code is taken from the [multisink example](https://github.com/gabime/spdlog/blob/master/example/multisink.cpp). Here is a minimal example:\r\n\r\n```\r\nstd::vector<spdlog::sink_ptr> sinks;\r\nsinks.push_back(std::make_shared<spdlog::sinks::wincolor_stdout_sink_mt>());\r\nsinks.push_back(std::make_shared<spdlog::sinks::rotating_file_sink_mt>(\"c:\\\\a\", \"log\",  128, 3));\r\nauto logger = std::make_shared<spdlog::logger>(\"logger\", sinks.begin(), sinks.end());  <<< HERE!\r\n```\r\n\r\nI think it is something to do with the `sinks.end()` pointer. According to [`vector::end()`](http://www.cplusplus.com/reference/vector/vector/end/) docs: \r\n\r\n> Returns an iterator referring to the past-the-end element in the vector container.The past-the-end element is the theoretical element that would follow the last element in the vector. It does not point to any element, and thus shall not be dereferenced.\r\n\r\n\r\nThis doesn't crash my app, but it looks like something that needs to be looked at as a potential security concern\r\n\r\n```\r\nError #1: UNINITIALIZED READ: reading 0x03824528-0x03824530 8 byte(s)\r\n# 0 _InterlockedExchange64_INLINE                           [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:96]\r\n# 1 std::_Store_seq_cst_8                                   [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:1834]\r\n# 2 std::_Atomic_store_8                                    [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:1852]\r\n# 3 std::atomic_store_explicit                              [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:507]\r\n# 4 std::atomic_store                                       [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:519]\r\n# 5 std::_Atomic_llong::operator=                           [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:643]\r\n# 6 std::atomic<>::operator=                                [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:197]\r\n# 7 spdlog::logger::logger<>                                [c:\\git\\vcpkg\\installed\\x86-windows\\include\\spdlog\\details\\logger_impl.h:25]\r\n# 8 std::_Ref_count_obj<>::_Ref_count_obj<><>               [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory:901]\r\n# 9 std::make_shared<>                                      [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory:971]\r\n#10 Log::ConfigureLogWithSeverity                           [c:\\***\\log.h:53] << My logging init code\r\n\r\nNote: @0:00:04.391 in thread 23268\r\nNote: instruction: lock cmpxchg8b (%esi) %eax %edx %ecx %ebx -> (%esi) %eax %edx\r\n\r\nError #2: UNINITIALIZED READ: reading register eax\r\n# 0 _InterlockedExchange64_INLINE                           [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:96]\r\n# 1 std::_Store_seq_cst_8                                   [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:1834]\r\n# 2 std::_Atomic_store_8                                    [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:1852]\r\n# 3 std::atomic_store_explicit                              [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:507]\r\n# 4 std::atomic_store                                       [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:519]\r\n# 5 std::_Atomic_llong::operator=                           [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:643]\r\n# 6 std::atomic<>::operator=                                [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:197]\r\n# 7 spdlog::logger::logger<>                                [c:\\git\\vcpkg\\installed\\x86-windows\\include\\spdlog\\details\\logger_impl.h:25]\r\n# 8 std::_Ref_count_obj<>::_Ref_count_obj<><>               [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory:901]\r\n# 9 std::make_shared<>                                      [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory:971]\r\n#10 Log::ConfigureLogWithSeverity                           [c:\\***\\log.h:53] << My logging init code\r\n\r\nNote: @0:00:04.393 in thread 23268\r\nNote: instruction: cmp    %eax 0xfffffff0(%ebp)\r\n\r\nError #3: UNINITIALIZED READ: reading register ecx\r\n# 0 _InterlockedExchange64_INLINE                           [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:96]\r\n# 1 std::_Store_seq_cst_8                                   [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:1834]\r\n# 2 std::_Atomic_store_8                                    [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic.h:1852]\r\n# 3 std::atomic_store_explicit                              [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:507]\r\n# 4 std::atomic_store                                       [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:519]\r\n# 5 std::_Atomic_llong::operator=                           [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:643]\r\n# 6 std::atomic<>::operator=                                [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xxatomic:197]\r\n# 7 spdlog::logger::logger<>                                [c:\\git\\vcpkg\\installed\\x86-windows\\include\\spdlog\\details\\logger_impl.h:25]\r\n# 8 std::_Ref_count_obj<>::_Ref_count_obj<><>               [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory:901]\r\n# 9 std::make_shared<>                                      [c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory:971]\r\n#10 Log::ConfigureLogWithSeverity                           [c:\\***\\log.h:53] << My logging init code\r\nNote: @0:00:04.394 in thread 23268\r\nNote: instruction: cmp    %ecx 0xfffffff4(%ebp)\r\n```\n", "hints_text": "Could you provide details about the exact compiler and platform?\r\n\r\n> I think it is something to do with the sinks.end() pointer.\r\n\r\nWhy is that ? what is in line 53 in log.h?\r\n\r\n\nVS 2015, platform 140_xp\r\nI will try and make a self contained example. Meanwhile, here is the content of the file\r\n\r\n```\r\n#pragma once\r\n\r\n#include <codeanalysis\\warnings.h>\r\n#pragma warning( push )\r\n#pragma warning( disable : ALL_CODE_ANALYSIS_WARNINGS )\r\n\r\n// Fix for https://github.com/gabime/spdlog/issues/327\r\n// otherwise we get message pop up in runtime on Win Xp \r\n// GetDynamicTimeZoneInformation not found for program compiled with v140_xp toolset running on Windows XP\r\n#ifdef _WIN32_WINNT\r\n#undef _WIN32_WINNT\r\n#define _WIN32_WINNT _WIN32_WINNT_WINXP\r\n#endif\r\n#include \"spdlog/spdlog.h\"\r\n#undef _WIN32_WINNT\r\n#define _WIN32_WINNT _WIN32_WINNT_WIN7\r\n#pragma warning( pop )\r\n\r\n#include \"Utility/Path.h\"\r\n#include <spdlog/sinks/wincolor_sink.h>\r\n\r\nclass Log\r\n{\r\nprivate:\r\n\tLog() {}\r\n\tLog(Log const&);              // Don't implement\r\n\tvoid operator=(Log const&);   // Don't implement\r\n\r\n\tstatic std::shared_ptr<spdlog::logger> logger;\r\n\r\npublic:\r\n\tstatic std::shared_ptr<spdlog::logger> instance()\r\n\t{\r\n\t\treturn logger;\r\n\t}\r\n\r\n\tstatic void ConfigureLogWithSeverity(int severity)\r\n\t{\r\n\t\t// Create console logger and\r\n\t\t// a file rotating logger with 5mb size max and 3 rotated files\r\n\t\tstd::string path = Path::GetLogPath();\r\n\t\t\r\n\t\tstd::vector<spdlog::sink_ptr> sinks;\r\n\t\tsinks.push_back(std::make_shared<spdlog::sinks::wincolor_stdout_sink_mt>());\r\n\t\tsinks.push_back(std::make_shared<spdlog::sinks::rotating_file_sink_mt>(path, \"log\", 5 * 1024 * 1024, 3));\r\n\t\t\r\n\t\tsinks[0]->set_level(static_cast<spdlog::level::level_enum>(severity));\r\n\t\tsinks[1]->set_level(static_cast<spdlog::level::level_enum>(severity));\r\n\t\t\r\n\r\n\r\n/*  HERE */     logger = std::make_shared<spdlog::logger>(\"logger\", sinks.begin(), sinks.end()); /*  HERE */\r\n\t\tlogger->set_pattern(\"[%Y-%b-%dT%H:%M:%S] [%t] [%l] %v\");\r\n\t}\r\n};\r\n\r\n```\nCould it be that the *static* logger is the cause? Could you try to create a local, non static logger variable and see if it helps?\nI'll try that. Meanwhile, here is a self-contained example\r\n\r\n```\r\n#include \"stdafx.h\"\r\n#include <vector>\r\n#include <memory>\r\n#include \"spdlog/spdlog.h\"\r\n\r\nint main()\r\n{\r\n   std::vector<spdlog::sink_ptr> sinks;\t\r\n   sinks.push_back(std::make_shared<spdlog::sinks::rotating_file_sink_mt>(\"c:\\\\logs\", \"log\", 5 * 1024 * 1024, 3));\r\n   auto logger = std::make_shared<spdlog::logger>(\"logger\", sinks.begin(), sinks.end());\r\n   return 0;\r\n}\r\n```\r\n\r\nTo run this against dr memory:\r\n\r\n1.  Download and install dr memory\r\n2. `cd ***\\multisink\\Debug`\r\n3. `drmemory -- multisink.exe`\r\n\r\n\r\n- Source [multisink.zip](https://github.com/gabime/spdlog/files/875664/multisink.zip)\r\n- [Dr memory report](https://github.com/gabime/spdlog/files/875669/results.txt)\r\n\r\n\r\n", "created_at": "2017-03-29T10:30:04Z"}
{"repo": "gabime/spdlog", "pull_number": 375, "instance_id": "gabime__spdlog-375", "issue_numbers": ["333"], "base_commit": "d7a8db8f6357856c7ac1eb3bde1f3a90a9ab9e0c", "patch": "diff --git a/example/example.cpp b/example/example.cpp\n--- a/example/example.cpp\n+++ b/example/example.cpp\n@@ -39,7 +39,7 @@ int main(int, char*[])\n \n \n         // Create basic file logger (not rotated)\n-        auto my_logger = spd::basic_logger_mt(\"basic_logger\", \"logs/basic.txt\");\n+        auto my_logger = spd::basic_logger_mt(\"basic_logger\", \"logs/basic\");\n         my_logger->info(\"Some log message\");\n \n         // Create a file rotating logger with 5mb size max and 3 rotated files\n@@ -106,7 +106,7 @@ void async_example()\n {\n     size_t q_size = 4096; //queue size must be power of 2\n     spdlog::set_async_mode(q_size);\n-    auto async_file = spd::daily_logger_st(\"async_file_logger\", \"logs/async_log.txt\");\n+    auto async_file = spd::daily_logger_st(\"async_file_logger\", \"logs/async_log\");\n \n     for (int i = 0; i < 100; ++i)\n         async_file->info(\"Async message #{}\", i);\ndiff --git a/include/spdlog/details/spdlog_impl.h b/include/spdlog/details/spdlog_impl.h\n--- a/include/spdlog/details/spdlog_impl.h\n+++ b/include/spdlog/details/spdlog_impl.h\n@@ -61,23 +61,23 @@ inline std::shared_ptr<spdlog::logger> spdlog::basic_logger_st(const std::string\n // Create multi/single threaded rotating file logger\n inline std::shared_ptr<spdlog::logger> spdlog::rotating_logger_mt(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files)\n {\n-    return create<spdlog::sinks::rotating_file_sink_mt>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), max_file_size, max_files);\n+    return create<spdlog::sinks::rotating_file_sink_mt>(logger_name, filename, max_file_size, max_files);\n }\n \n inline std::shared_ptr<spdlog::logger> spdlog::rotating_logger_st(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files)\n {\n-    return create<spdlog::sinks::rotating_file_sink_st>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), max_file_size, max_files);\n+    return create<spdlog::sinks::rotating_file_sink_st>(logger_name, filename, max_file_size, max_files);\n }\n \n // Create file logger which creates new file at midnight):\n inline std::shared_ptr<spdlog::logger> spdlog::daily_logger_mt(const std::string& logger_name, const filename_t& filename, int hour, int minute)\n {\n-    return create<spdlog::sinks::daily_file_sink_mt>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), hour, minute);\n+    return create<spdlog::sinks::daily_file_sink_mt>(logger_name, filename, hour, minute);\n }\n \n inline std::shared_ptr<spdlog::logger> spdlog::daily_logger_st(const std::string& logger_name, const filename_t& filename, int hour, int minute)\n {\n-    return create<spdlog::sinks::daily_file_sink_st>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), hour, minute);\n+    return create<spdlog::sinks::daily_file_sink_st>(logger_name, filename, hour, minute);\n }\n \n \ndiff --git a/include/spdlog/sinks/file_sinks.h b/include/spdlog/sinks/file_sinks.h\n--- a/include/spdlog/sinks/file_sinks.h\n+++ b/include/spdlog/sinks/file_sinks.h\n@@ -64,16 +64,15 @@ template<class Mutex>\n class rotating_file_sink : public base_sink < Mutex >\n {\n public:\n-    rotating_file_sink(const filename_t &base_filename, const filename_t &extension,\n-                       std::size_t max_size, std::size_t max_files                       ) :\n+    rotating_file_sink(const filename_t &base_filename,\n+                       std::size_t max_size, std::size_t max_files) :\n         _base_filename(base_filename),\n-        _extension(extension),\n         _max_size(max_size),\n         _max_files(max_files),\n         _current_size(0),\n         _file_helper()\n     {\n-        _file_helper.open(calc_filename(_base_filename, 0, _extension));\n+        _file_helper.open(calc_filename(_base_filename, 0));\n         _current_size = _file_helper.size(); //expensive. called only once\n     }\n \n@@ -95,21 +94,21 @@ class rotating_file_sink : public base_sink < Mutex >\n     }\n \n private:\n-    static filename_t calc_filename(const filename_t& filename, std::size_t index, const filename_t& extension)\n+    static filename_t calc_filename(const filename_t& filename, std::size_t index)\n     {\n         std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;\n         if (index)\n-            w.write(SPDLOG_FILENAME_T(\"{}.{}.{}\"), filename, index, extension);\n+            w.write(SPDLOG_FILENAME_T(\"{}.{}\"), filename, index);\n         else\n-            w.write(SPDLOG_FILENAME_T(\"{}.{}\"), filename, extension);\n+            w.write(SPDLOG_FILENAME_T(\"{}\"), filename);\n         return w.str();\n     }\n \n     // Rotate files:\n-    // log.txt -> log.1.txt\n-    // log.1.txt -> log2.txt\n-    // log.2.txt -> log3.txt\n-    // log.3.txt -> delete\n+    // log.txt -> log.txt.1\n+    // log.txt.1 -> log.txt.2\n+    // log.txt.2 -> log.txt.3\n+    // lo3.txt.3 -> delete\n \n     void _rotate()\n     {\n@@ -117,8 +116,8 @@ class rotating_file_sink : public base_sink < Mutex >\n         _file_helper.close();\n         for (auto i = _max_files; i > 0; --i)\n         {\n-            filename_t src = calc_filename(_base_filename, i - 1, _extension);\n-            filename_t target = calc_filename(_base_filename, i, _extension);\n+            filename_t src = calc_filename(_base_filename, i - 1);\n+            filename_t target = calc_filename(_base_filename, i);\n \n             if (details::file_helper::file_exists(target))\n             {\n@@ -135,7 +134,6 @@ class rotating_file_sink : public base_sink < Mutex >\n         _file_helper.reopen(true);\n     }\n     filename_t _base_filename;\n-    filename_t _extension;\n     std::size_t _max_size;\n     std::size_t _max_files;\n     std::size_t _current_size;\n@@ -150,27 +148,27 @@ typedef rotating_file_sink<details::null_mutex>rotating_file_sink_st;\n  */\n struct default_daily_file_name_calculator\n {\n-    // Create filename for the form basename.YYYY-MM-DD_hh-mm.extension\n-    static filename_t calc_filename(const filename_t& basename, const filename_t& extension)\n+    // Create filename for the form basename.YYYY-MM-DD_hh-mm\n+    static filename_t calc_filename(const filename_t& basename)\n     {\n         std::tm tm = spdlog::details::os::localtime();\n         std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;\n-        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}.{}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, extension);\n+        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n         return w.str();\n     }\n };\n \n /*\n- * Generator of daily log file names in format basename.YYYY-MM-DD.extension\n+ * Generator of daily log file names in format basename.YYYY-MM-DD\n  */\n struct dateonly_daily_file_name_calculator\n {\n-    // Create filename for the form basename.YYYY-MM-DD.extension\n-    static filename_t calc_filename(const filename_t& basename, const filename_t& extension)\n+    // Create filename for the form basename.YYYY-MM-DD\n+    static filename_t calc_filename(const filename_t& basename)\n     {\n         std::tm tm = spdlog::details::os::localtime();\n         std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;\n-        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}.{}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, extension);\n+        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n         return w.str();\n     }\n };\n@@ -185,17 +183,15 @@ class daily_file_sink :public base_sink < Mutex >\n     //create daily file sink which rotates on given time\n     daily_file_sink(\n         const filename_t& base_filename,\n-        const filename_t& extension,\n         int rotation_hour,\n         int rotation_minute) : _base_filename(base_filename),\n-        _extension(extension),\n         _rotation_h(rotation_hour),\n         _rotation_m(rotation_minute)\n     {\n         if (rotation_hour < 0 || rotation_hour > 23 || rotation_minute < 0 || rotation_minute > 59)\n             throw spdlog_ex(\"daily_file_sink: Invalid rotation time in ctor\");\n         _rotation_tp = _next_rotation_tp();\n-        _file_helper.open(FileNameCalc::calc_filename(_base_filename, _extension));\n+        _file_helper.open(FileNameCalc::calc_filename(_base_filename));\n     }\n \n     void flush() override\n@@ -208,7 +204,7 @@ class daily_file_sink :public base_sink < Mutex >\n     {\n         if (std::chrono::system_clock::now() >= _rotation_tp)\n         {\n-            _file_helper.open(FileNameCalc::calc_filename(_base_filename, _extension));\n+            _file_helper.open(FileNameCalc::calc_filename(_base_filename));\n             _rotation_tp = _next_rotation_tp();\n         }\n         _file_helper.write(msg);\n@@ -231,7 +227,6 @@ class daily_file_sink :public base_sink < Mutex >\n     }\n \n     filename_t _base_filename;\n-    filename_t _extension;\n     int _rotation_h;\n     int _rotation_m;\n     std::chrono::system_clock::time_point _rotation_tp;\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -124,7 +124,7 @@ std::shared_ptr<logger> create(const std::string& logger_name, const It& sinks_b\n \n // Create and register a logger with templated sink type\n // Example:\n-// spdlog::create<daily_file_sink_st>(\"mylog\", \"dailylog_filename\", \"txt\");\n+// spdlog::create<daily_file_sink_st>(\"mylog\", \"dailylog_filename\");\n template <typename Sink, typename... Args>\n std::shared_ptr<spdlog::logger> create(const std::string& logger_name, Args...);\n \n", "test_patch": "diff --git a/tests/file_log.cpp b/tests/file_log.cpp\n--- a/tests/file_log.cpp\n+++ b/tests/file_log.cpp\n@@ -7,7 +7,7 @@\n TEST_CASE(\"simple_file_logger\", \"[simple_logger]]\")\n {\n     prepare_logdir();\n-    std::string filename = \"logs/simple_log.txt\";\n+    std::string filename = \"logs/simple_log\";\n \n     auto logger = spdlog::create<spdlog::sinks::simple_file_sink_mt>(\"logger\", filename);\n     logger->set_pattern(\"%v\");\n@@ -24,7 +24,7 @@ TEST_CASE(\"simple_file_logger\", \"[simple_logger]]\")\n TEST_CASE(\"flush_on\", \"[flush_on]]\")\n {\n     prepare_logdir();\n-    std::string filename = \"logs/simple_log.txt\";\n+    std::string filename = \"logs/simple_log\";\n \n     auto logger = spdlog::create<spdlog::sinks::simple_file_sink_mt>(\"logger\", filename);\n     logger->set_pattern(\"%v\");\n@@ -50,7 +50,7 @@ TEST_CASE(\"rotating_file_logger1\", \"[rotating_logger]]\")\n         logger->info(\"Test message {}\", i);\n \n     logger->flush();\n-    auto filename = basename + \".txt\";\n+    auto filename = basename;\n     REQUIRE(count_lines(filename) == 10);\n }\n \n@@ -64,14 +64,14 @@ TEST_CASE(\"rotating_file_logger2\", \"[rotating_logger]]\")\n         logger->info(\"Test message {}\", i);\n \n     logger->flush();\n-    auto filename = basename + \".txt\";\n+    auto filename = basename;\n     REQUIRE(count_lines(filename) == 10);\n     for (int i = 0; i < 1000; i++)\n         logger->info(\"Test message {}\", i);\n \n     logger->flush();\n     REQUIRE(get_filesize(filename) <= 1024);\n-    auto filename1 = basename + \".1.txt\";\n+    auto filename1 = basename + \".1\";\n     REQUIRE(get_filesize(filename1) <= 1024);\n }\n \n@@ -83,7 +83,7 @@ TEST_CASE(\"daily_logger\", \"[daily_logger]]\")\n     std::string basename = \"logs/daily_log\";\n     std::tm tm = spdlog::details::os::localtime();\n     fmt::MemoryWriter w;\n-    w.write(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}.txt\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n+    w.write(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n \n     auto logger = spdlog::daily_logger_mt(\"logger\", basename, 0, 0);\n     logger->flush_on(spdlog::level::info);\n@@ -106,9 +106,9 @@ TEST_CASE(\"daily_logger with dateonly calculator\", \"[daily_logger_dateonly]]\")\n     std::string basename = \"logs/daily_dateonly\";\n     std::tm tm = spdlog::details::os::localtime();\n     fmt::MemoryWriter w;\n-    w.write(\"{}_{:04d}-{:02d}-{:02d}.txt\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n+    w.write(\"{}_{:04d}-{:02d}-{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n \n-    auto logger = spdlog::create<sink_type>(\"logger\", basename, \"txt\", 0, 0);\n+    auto logger = spdlog::create<sink_type>(\"logger\", basename, 0, 0);\n     for (int i = 0; i < 10; ++i)\n         logger->info(\"Test message {}\", i);\n     logger->flush();\n@@ -118,11 +118,11 @@ TEST_CASE(\"daily_logger with dateonly calculator\", \"[daily_logger_dateonly]]\")\n \n struct custom_daily_file_name_calculator\n {\n-    static spdlog::filename_t calc_filename(const spdlog::filename_t& basename, const spdlog::filename_t& extension)\n+    static spdlog::filename_t calc_filename(const spdlog::filename_t& basename)\n     {\n         std::tm tm = spdlog::details::os::localtime();\n         fmt::MemoryWriter w;\n-        w.write(\"{}{:04d}{:02d}{:02d}.{}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, extension);\n+        w.write(\"{}{:04d}{:02d}{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n         return w.str();\n     }\n };\n@@ -138,9 +138,9 @@ TEST_CASE(\"daily_logger with custom calculator\", \"[daily_logger_custom]]\")\n     std::string basename = \"logs/daily_dateonly\";\n     std::tm tm = spdlog::details::os::localtime();\n     fmt::MemoryWriter w;\n-    w.write(\"{}{:04d}{:02d}{:02d}.txt\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n+    w.write(\"{}{:04d}{:02d}{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n \n-    auto logger = spdlog::create<sink_type>(\"logger\", basename, \"txt\", 0, 0);\n+    auto logger = spdlog::create<sink_type>(\"logger\", basename, 0, 0);\n     for (int i = 0; i < 10; ++i)\n         logger->info(\"Test message {}\", i);\n \n", "problem_statement": "Unexpected appending of \"txt\" at the end of a log filename\nI was confused by the usage of the filename parameter for `rotating_logger_mt`. It's called `filename`, so I interpreted that as being the absolute path to the file. Instead, it seems like `.txt` is appended onto the end of whatever is provided, so I ended up getting something like `mylog.txt.txt`. Is there a reason that the extension is hardcoded to `.txt`? Why not allow the entire filename to be specified by the caller?\r\n\r\nAs a result of this behaviour, I have to implement two functions in my code: one to output the desired log filename *without* an extension (to provide to `spdlog`), and one to output the log filename *with* an extension (when I want to operate on the log file myself).\n", "hints_text": "+1\nThe intention was to try to keep the extension for the rotated files. Maybe this it is not really needed (i.e. rotated log files would be just named log.txt.1, log.txt.2) and maybe there is a better way to achieve this. I will happy to consider alternative ways.\r\n\r\nA possible fix would be to ignore the extension if it is empty string\r\n\r\n\nhi @gabime , looking shortly into my /var/log - most logs just add number on the end of file i.e.\r\n<pre>\r\nfilename.ext\r\nfilename.ext.0\r\nfilename.ext.1\r\nfilename.ext.2\r\n</pre>\r\neventuelly, extra suffix is for rotated/compressed file i.e.:\r\n<pre>\r\nfilename.ext\r\nfilename.ext.0.xz\r\nfilename.ext.1.xz\r\nfilename.ext.2.xz\r\n</pre>\r\n\r\nI vote for rotating file and let user use plain filename or filename with extension.\nYes, I think you are right. It would also simplify things a little which is always good..\nI can try create a PR  (?)\nSure. Please do", "created_at": "2017-02-28T00:01:12Z"}
{"repo": "gabime/spdlog", "pull_number": 95, "instance_id": "gabime__spdlog-95", "issue_numbers": ["94"], "base_commit": "8208b49298da0a43a293a23292a3167702d5ca14", "patch": "diff --git a/include/spdlog/sinks/file_sinks.h b/include/spdlog/sinks/file_sinks.h\n--- a/include/spdlog/sinks/file_sinks.h\n+++ b/include/spdlog/sinks/file_sinks.h\n@@ -47,6 +47,10 @@ class simple_file_sink : public base_sink < Mutex >\n     {\n         _file_helper.open(filename);\n     }\n+    void flush() override\n+    {\n+        _file_helper.flush();\n+    }\n \n protected:\n     void _sink_it(const details::log_msg& msg) override\n", "test_patch": "", "problem_statement": "Did something changed in `simple_file_sink` ?\nHi the latest commits break my builds with the following error:\n\n``` bash\nerror: field type 'spdlog::sinks::simple_file_sink<spdlog::details::null_mutex>' \nis an abstract class\n\n...\n\nspdlog/include/spdlog/sinks/../details/../sinks/sink.h:38:18: \nnote: unimplemented pure virtual method 'flush' in 'simple_file_sink'\n    virtual void flush() = 0;\n                 ^\n```\n\nwhen doing:\n\n`std::make_shared<spdlog::sinks::simple_file_sink_st>(name + \".log\", false);`\n\nIf `spdlog::sinks::simple_file_sink_st` is deprecated maybe it could be better to mark it with an attribute containing how to fix it and maybe the reason: `[[deprecated(\"reason + how to fix it\")]]`.\n\n", "hints_text": "", "created_at": "2015-05-11T08:18:19Z"}
